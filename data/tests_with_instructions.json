[{"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<1> but was:<0> test2947660 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   dataset.addValue(1.0, \"S1\", \"C1\");  LegendItemCollection lic = r.getLegendItems();  assertEquals(1, lic.getItemCount());  assertEquals(\"S1\", lic.get(0).getLabel()); }", "input": "[BUG] [BUGGY] if (dataset != null) { [FE] AssertionFailedError: expected:<1> but was:<0> test2947660 [CONTEXT] public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); [BUGGY] if (dataset != null) { [BUGGY] return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } [CLASS] AbstractCategoryItemRenderer [METHOD] getLegendItems [RETURN_TYPE] LegendItemCollection [VARIABLES] LegendItemCollection result CategoryURLGenerator baseURLGenerator generator CategoryItemLabelGenerator baseItemLabelGenerator generator long serialVersionUID CategoryPlot cp p plot int column columnCount columnIndex datasetIndex i index result row rowCount s series seriesCount visibleSeriesCount boolean LegendItem item CategorySeriesLabelGenerator generator legendItemLabelGenerator legendItemToolTipGenerator legendItemURLGenerator CategoryToolTipGenerator baseToolTipGenerator generator result CategoryDataset dataset ObjectList itemLabelGeneratorList toolTipGeneratorList urlGeneratorList List backgroundAnnotations foregroundAnnotations visibleSeriesKeys ", "output": "[PATCH] if (dataset == null) { ", "bugid": "0"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<1010> but was:<1020> testCreateCopy3 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   s1.add(new Year(2011), 102.0);  assertEquals(100.0, s1.getMinY(), EPSILON);  assertEquals(102.0, s1.getMaxY(), EPSILON);  TimeSeries s2 = s1.createCopy(0, 1);", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: expected:<1010> but was:<1020> testCreateCopy3 [CONTEXT] public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException { if (start < 0) { throw new IllegalArgumentException(\"Requires start >= 0.\"); } if (end < start) { throw new IllegalArgumentException(\"Requires start <= end.\"); } TimeSeries copy = (TimeSeries) super.clone(); [BUGGY] [BUGGY] copy.data = new java.util.ArrayList(); if (this.data.size() > 0) { for (int index = start; index <= end; index++) { TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index); TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone(); try { copy.add(clone); } catch (SeriesException e) { e.printStackTrace(); [CLASS] TimeSeries [METHOD] createCopy [RETURN_TYPE] TimeSeries int start int end [VARIABLES] TimeSeries copy boolean double maxY minY oldY value yy TimeSeriesDataItem clone item Class c periodClass timePeriodClass List data String DEFAULT_DOMAIN_DESCRIPTION DEFAULT_RANGE_DESCRIPTION description domain msg old range SeriesException e long index latest maximumItemAge periods serialVersionUID int count end i index maximum maximumItemCount start ", "output": "[PATCH] copy.minY = Double.NaN; copy.maxY = Double.NaN; ", "bugid": "1"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<orgjfreechartutilShapeList@cef18a3f> but was:<orgjfreechartutilShapeList@e657ea8d> testSerialization . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] return super.equals(obj); [FE] AssertionFailedError: expected:<orgjfreechartutilShapeList@cef18a3f> but was:<orgjfreechartutilShapeList@e657ea8d> testSerialization [CONTEXT] public boolean equals(Object obj) { if (obj == this) { return true; } if (!(obj instanceof ShapeList)) { return false; } [BUGGY] return super.equals(obj); [BUGGY] } [CLASS] ShapeList [METHOD] equals [RETURN_TYPE] boolean Object obj [VARIABLES] boolean Object obj ", "output": "[PATCH] ShapeList that = (ShapeList) obj; int listSize = size(); for (int i = 0; i < listSize; i++) { if (!ShapeUtilities.equal((Shape) get(i), (Shape) that.get(i))) { return false; } } return true; ", "bugid": "2"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<35> but was:<34> testConstructor . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   t = cal.getTime();  w = new Week(t, TimeZone.getTimeZone(\"Europe/Copenhagen\"));  assertEquals(35, w.getWeek());  w = new Week(t, TimeZone.getTimeZone(\"Europe/Copenhagen\"),    new Locale(\"da\", \"DK\"));", "input": "[BUG] [BUGGY] this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); [FE] AssertionFailedError: expected:<35> but was:<34> testConstructor [CONTEXT] public Week(Date time, TimeZone zone) { [BUGGY] this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); [BUGGY] } [CLASS] Week [METHOD] <init> [RETURN_TYPE] TimeZone) Date time TimeZone zone [VARIABLES] TimeZone zone boolean byte week short year long firstMillisecond lastMillisecond serialVersionUID int FIRST_WEEK_IN_YEAR LAST_WEEK_IN_YEAR week year Date time ", "output": "[PATCH] this(time, zone, Locale.getDefault()); ", "bugid": "4"}, {"instruction": "The following code contains a buggy line with the following test error: IllegalArgumentException: Requires start <= end testBug1864222 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   boolean pass = true;  try {   s.createCopy(new Day(1, 12, 2005), new Day(18, 1, 2006));  }  catch (CloneNotSupportedException e) {", "input": "[BUG] [BUGGY] if (endIndex < 0) { [FE] IllegalArgumentException: Requires start <= end testBug1864222 [CONTEXT] startIndex = -(startIndex + 1); if (startIndex == this.data.size()) { emptyRange = true; } } int endIndex = getIndex(end); if (endIndex < 0) { endIndex = -(endIndex + 1); endIndex = endIndex - 1; } [BUGGY] if (endIndex < 0) { [BUGGY] emptyRange = true; } if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); return copy; } else { return createCopy(startIndex, endIndex); } [CLASS] TimeSeries [METHOD] createCopy [RETURN_TYPE] TimeSeries RegularTimePeriod start RegularTimePeriod end [VARIABLES] boolean emptyRange TimeSeries copy Class timePeriodClass List data String DEFAULT_DOMAIN_DESCRIPTION DEFAULT_RANGE_DESCRIPTION description domain old range RegularTimePeriod end start long index latest maximumItemAge periods serialVersionUID int count end endIndex i index maximum maximumItemCount start startIndex ", "output": "[PATCH] if ((endIndex < 0) || (endIndex < startIndex)) { ", "bugid": "5"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:< title=\"Series [&quot;A&quot;], 1000\" alt=\"\"> but was:< title=\"Series [\"A\"], 1000\" alt=\"\"> testGenerateURLFragment . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertEquals(\" title=\\\"abc\\\" alt=\\\"\\\"\",    g.generateToolTipFragment(\"abc\"));  assertEquals(\" title=\\\"Series &quot;A&quot;, 100.0\\\" alt=\\\"\\\"\",    g.generateToolTipFragment(\"Series \\\"A\\\", 100.0\")); }", "input": "[BUG] [BUGGY] return\" title=\\\\\"\" + toolTipText [FE] ComparisonFailure: expected:< title=\"Series [&quot;A&quot;], 1000\" alt=\"\"> but was:< title=\"Series [\"A\"], 1000\" alt=\"\"> testGenerateURLFragment [CONTEXT] public String generateToolTipFragment(String toolTipText) { [BUGGY] return\" title=\\\"\" + toolTipText [BUGGY] +\"\\\" alt=\\\"\\\"\"; } [CLASS] StandardToolTipTagFragmentGenerator [METHOD] generateToolTipFragment [RETURN_TYPE] String String toolTipText [VARIABLES] boolean String toolTipText ", "output": "[PATCH] return\" title=\\\\\"\" + ImageMapUtilities.htmlEscape(toolTipText) ", "bugid": "6"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testEqualGeneralPaths . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   g2.quadTo(1.0f, 2.0f, 3.0f, 4.0f);  g2.closePath();  assertTrue(ShapeUtilities.equal(g1, g2));  g2 = new GeneralPath();", "input": "[BUG] [BUGGY] PathIterator iterator2 = p1.getPathIterator(null); [FE] AssertionFailedError testEqualGeneralPaths [CONTEXT] if (p1 == null) { return (p2 == null); } if (p2 == null) { return false; } if (p1.getWindingRule() != p2.getWindingRule()) { return false; } PathIterator iterator1 = p1.getPathIterator(null); [BUGGY] PathIterator iterator2 = p1.getPathIterator(null); [BUGGY] double[] d1 = new double[6]; double[] d2 = new double[6]; boolean done = iterator1.isDone() && iterator2.isDone(); while (!done) { if (iterator1.isDone() != iterator2.isDone()) { return false; } int seg1 = iterator1.currentSegment(d1); int seg2 = iterator2.currentSegment(d2); if (seg1 != seg2) { [CLASS] ShapeUtilities [METHOD] equal [RETURN_TYPE] boolean GeneralPath p1 GeneralPath p2 [VARIABLES] boolean done float SQRT2 GeneralPath p1 p2 double[] d1 d2 PathIterator iterator1 iterator2 int seg1 seg2 ", "output": "[PATCH] PathIterator iterator2 = p2.getPathIterator(null); ", "bugid": "7"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testConstructor . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  \tDefaultCategoryDataset dataset = new DefaultCategoryDataset(); \tplot = new MultiplePiePlot(dataset); \tassertTrue(dataset.hasListener(plot)); }", "input": "[BUG] [BUGGY] this.dataset = dataset; [FE] AssertionFailedError testConstructor [CONTEXT] public MultiplePiePlot(CategoryDataset dataset) { super(); [BUGGY] this.dataset = dataset; [BUGGY] PiePlot piePlot = new PiePlot(null); this.pieChart = new JFreeChart(piePlot); this.pieChart.removeLegend(); this.dataExtractOrder = TableOrder.BY_COLUMN; this.pieChart.setBackgroundPaint(null); TextTitle seriesTitle = new TextTitle(\"Series Title\", new Font(\"SansSerif\", Font.BOLD, 12)); seriesTitle.setPosition(RectangleEdge.BOTTOM); this.pieChart.setTitle(seriesTitle); this.aggregatedItemsKey =\"Other\"; [CLASS] MultiplePiePlot [METHOD] <init> [RETURN_TYPE] CategoryDataset) CategoryDataset dataset [VARIABLES] TextTitle seriesTitle Comparable aggregatedItemsKey TableOrder dataExtractOrder boolean double limit CategoryDataset dataset PiePlot piePlot Paint aggregatedItemsPaint Map sectionPaints long serialVersionUID JFreeChart pieChart ", "output": "[PATCH] setDataset(dataset); ", "bugid": "8"}, {"instruction": "The following code contains a buggy line with the following test error: IllegalArgumentException: Range(double, double): require lower (00) <= upper (-23000000000000007) testSizingWithWidthConstraint . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   // 00001 - center item only  container.add(new EmptyBlock(5.0, 6.0));  Size2D size = container.arrange(g2, constraint);  assertEquals(10.0, size.width, EPSILON);  assertEquals(6.0, size.height, EPSILON);", "input": "[BUG] [BUGGY] new Range(0.0, constraint.getWidth() - w[2]), [FE] IllegalArgumentException: Range(double, double): require lower (00) <= upper (-23000000000000007) testSizingWithWidthConstraint [CONTEXT] RectangleConstraint c3 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth()), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED); Size2D size = this.leftBlock.arrange(g2, c3); w[2] = size.width; } h[3] = h[2]; if (this.rightBlock != null) { RectangleConstraint c4 = new RectangleConstraint(0.0, [BUGGY] new Range(0.0, constraint.getWidth() - w[2]), [BUGGY] LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED); Size2D size = this.rightBlock.arrange(g2, c4); w[3] = size.width; } h[4] = h[2]; w[4] = constraint.getWidth() - w[3] - w[2]; RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]); if (this.centerBlock != null) { this.centerBlock.arrange(g2, c5); [CLASS] BorderArrangement [METHOD] arrangeFF [RETURN_TYPE] Size2D BlockContainer container Graphics2D g2 RectangleConstraint constraint [VARIABLES] Size2D size boolean double[] h w BlockContainer container Block block bottomBlock centerBlock leftBlock rightBlock topBlock RectangleConstraint c1 c2 c3 c4 c5 constraint long serialVersionUID Graphics2D g2 ", "output": "[PATCH] new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)), ", "bugid": "9"}, {"instruction": "The following code contains a buggy line with the following test error: IllegalArgumentException: Requires start <= end testBug1832432 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   TimeSeries s2 = null;  try {   s2 = (TimeSeries) s1.clone();  }  catch (CloneNotSupportedException e) {", "input": "[BUG] [BUGGY] Object clone = createCopy(0, getItemCount() - 1); [FE] IllegalArgumentException: Requires start <= end testBug1832432 [CONTEXT] public Object clone() throws CloneNotSupportedException { [BUGGY] Object clone = createCopy(0, getItemCount() - 1); [BUGGY] return clone; } [CLASS] TimeSeries [METHOD] clone [RETURN_TYPE] Object [VARIABLES] boolean Class timePeriodClass List data Object clone String DEFAULT_DOMAIN_DESCRIPTION DEFAULT_RANGE_DESCRIPTION description domain old range long index latest maximumItemAge periods serialVersionUID int count end i index maximum maximumItemCount start ", "output": "[PATCH] TimeSeries clone = (TimeSeries) super.clone(); clone.data = (List) ObjectUtilities.deepClone(this.data); ", "bugid": "10"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<javaawtColor[r=0,g=0,b=255]> but was:<javaawtColor[r=255,g=0,b=0]> test1808376 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertEquals(Color.red, m.getPaint());  assertEquals(stroke, m.getStroke());  assertEquals(Color.blue, m.getOutlinePaint());  assertEquals(outlineStroke, m.getOutlineStroke());  assertEquals(0.5f, m.getAlpha(), EPSILON);", "input": "[BUG] [BUGGY] super(paint, stroke, paint, stroke, alpha); [FE] AssertionFailedError: expected:<javaawtColor[r=0,g=0,b=255]> but was:<javaawtColor[r=255,g=0,b=0]> test1808376 [CONTEXT] public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { [BUGGY] super(paint, stroke, paint, stroke, alpha); [BUGGY] this.value = value; } [CLASS] ValueMarker [METHOD] <init> [RETURN_TYPE] Stroke,float) double value Paint paint Stroke stroke Paint outlinePaint Stroke outlineStroke float alpha [VARIABLES] Stroke outlineStroke stroke Paint outlinePaint paint boolean float alpha double value ", "output": "[PATCH] super(paint, stroke, outlinePaint, outlineStroke, alpha); ", "bugid": "11"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testEquals . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:     r1.setDrawLines(true);  assertFalse(r1.equals(r2));  r2.setDrawLines(true);  assertTrue(r1.equals(r2));", "input": "[BUG] [BUGGY] [FE] AssertionFailedError testEquals [CONTEXT]  [BUGGY] [BUGGY]   private Icon getIcon(Shape shape, final Paint fillPaint, [CLASS] ", "output": "[PATCH] public boolean equals(Object obj) { if (obj == this) { return true; } if (!(obj instanceof MinMaxCategoryRenderer)) { return false; } MinMaxCategoryRenderer that = (MinMaxCategoryRenderer) obj; if (this.plotLines != that.plotLines) { return false; } if (!PaintUtilities.equal(this.groupPaint, that.groupPaint)) { return false; } if (!this.groupStroke.equals(that.groupStroke)) { return false; } return super.equals(obj); } ", "bugid": "12"}, {"instruction": "The following code contains a buggy line with the following test error: IllegalArgumentException testGetPaint . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void testGetPaint() {  GrayPaintScale gps = new GrayPaintScale();  Color c = (Color) gps.getPaint(0.0);  assertTrue(c.equals(Color.black));  c = (Color) gps.getPaint(1.0);", "input": "[BUG] [BUGGY]   [FE] IllegalArgumentException testGetPaint [CONTEXT] (double value) { double v = Math.max(value, this.lowerBound);  v = Math.min(v, this.upperBound);  [BUGGY] [BUGGY]  int g = (int) (( value - this.lowerBound) / (this.upperBound  [CLASS] GrayPaintScale [METHOD] getPaint [RETURN_TYPE] Paint double value [VARIABLES] double v value lowerBound upperBound int g ", "output": "[PATCH]  ", "bugid": "13"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: sample=-50 testMath1021 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   for (int i = 0; i < 100; i++) {   final int sample = dist.sample();   Assert.assertTrue(\"sample=\" + sample, 0 <= sample);   Assert.assertTrue(\"sample=\" + sample, sample <= n);  }", "input": "[BUG] [BUGGY] return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize(); [FE] AssertionFailedError: sample=-50 testMath1021 [CONTEXT] public double getNumericalMean() { [BUGGY] return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize(); [BUGGY] } [CLASS] HypergeometricDistribution [METHOD] getNumericalMean [RETURN_TYPE] double [VARIABLES] boolean numericalVarianceIsCalculated double numericalVariance p p1 p2 p3 q ret long serialVersionUID int dx k m n numberOfSuccesses populationSize sampleSize x x0 x1 ", "output": "[PATCH] return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize()); ", "bugid": "14"}, {"instruction": "The following code contains a buggy line with the following test error: ArrayIndexOutOfBoundsException: 1 testLinearCombinationWithSingleElementArray . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   final double[] b = { 98765432.1 };  Assert.assertEquals(a[0] * b[0], MathArrays.linearCombination(a, b), 0d); }", "input": "[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException: 1 testLinearCombinationWithSingleElementArray [CONTEXT] throws DimensionMismatchException { final int len = a.length; if (len != b.length) { throw new DimensionMismatchException(len, b.length); } [BUGGY] [BUGGY] final double[] prodHigh = new double[len]; double prodLowSum = 0; for (int i = 0; i < len; i++) { final double ai = a[i]; final double ca = SPLIT_FACTOR * ai; final double aHigh = ca - (ca - ai); final double aLow = ai - aHigh; [CLASS] MathArrays OrderDirection 1 2 [METHOD] linearCombination [RETURN_TYPE] double final double[] a final double[] b [VARIABLES] boolean double[] a b prodHigh int SPLIT_FACTOR comp i index j len lenMinusOne max numElements startIndex sum yListLen OrderDirection DECREASING INCREASING dir double aHigh aLow ai bHigh bLow bi ca cb prodHighCur prodHighNext prodLow prodLowSum result sHighCur sHighPrev sLowSum sPrime ", "output": "[PATCH] if (len == 1) { return a[0] * b[0]; } ", "bugid": "15"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<(NaN, NaN)> but was:<(Infinity, Infinity)> testReciprocalZero . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  }", "input": "[BUG] [BUGGY] return NaN; [FE] AssertionFailedError: expected:<(NaN, NaN)> but was:<(Infinity, Infinity)> testReciprocalZero [CONTEXT] public Complex reciprocal() { if (isNaN) { return NaN; } if (real == 0.0 && imaginary == 0.0) { [BUGGY] return NaN; [BUGGY] } if (isInfinite) { return ZERO; } if (FastMath.abs(real) < FastMath.abs(imaginary)) { double q = real / imaginary; double scale = 1. / (real * q + imaginary); return createComplex(scale * q, -scale); [CLASS] Complex [METHOD] reciprocal [RETURN_TYPE] Complex [VARIABLES] boolean isInfinite isNaN double addend c d denominator divisor imaginary q real scale long serialVersionUID Complex I INF NaN ONE ZERO addend divisor ", "output": "[PATCH] return INF; ", "bugid": "16"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: arrays first differed at element [0]; expected:<0028581782127907646> but was:<0028581782243293483> testRevert . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   Line line = new Line(new Vector3D(1653345.6696423641, 6170370.041579291, 90000),    new Vector3D(1650757.5050732433, 6160710.879908984, 0.9));  Vector3D expected = line.getDirection().negate();  // action", "input": "[BUG] [BUGGY] final Line reverted = new Line(zero, zero.subtract(direction)); [FE] AssertionFailedError: arrays first differed at element [0]; expected:<0028581782127907646> but was:<0028581782243293483> testRevert [CONTEXT] public Line revert() { [BUGGY] final Line reverted = new Line(zero, zero.subtract(direction)); [BUGGY] return reverted; } [CLASS] Line [METHOD] revert [RETURN_TYPE] Line [VARIABLES] Line reverted Vector3D delta direction p1 p2 zero boolean ", "output": "[PATCH] final Line reverted = new Line(this); reverted.direction = reverted.direction.negate(); ", "bugid": "17"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<00> but was:<NaN> testAtan2SpecialCases . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:     DerivativeStructure.atan2(new DerivativeStructure(2, 2, 1, +0.0),    new DerivativeStructure(2, 2, 1, +0.0));  Assert.assertEquals(0, pp.getValue(), 1.0e-15);  Assert.assertEquals(+1, FastMath.copySign(1, pp.getValue()), 1.0e-15);", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: expected:<00> but was:<NaN> testAtan2SpecialCases [CONTEXT] atan(tmp1, 0, tmp2, 0); result[resultOffset] = ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]; for (int i = 1; i < tmp2.length; ++i) { result[resultOffset + i] = -2 * tmp2[i]; } }  [BUGGY] [BUGGY] }   [CLASS] ", "output": "[PATCH] result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]); ", "bugid": "18"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<023644016090654427> but was:<05926675925866471> testUnivariateDistribution . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   for (int i = 0; i < numCases; i++) {   final double v = rng.nextDouble() * 10 - 5;   Assert.assertEquals(uni.density(v), multi.density(new double[] { v }), tol);  } }", "input": "[BUG] [BUGGY] return FastMath.pow(2 * FastMath.PI, -dim / 2) * [FE] AssertionFailedError: expected:<023644016090654427> but was:<05926675925866471> testUnivariateDistribution [CONTEXT] public double density(final double[] vals) throws DimensionMismatchException { final int dim = getDimension(); if (vals.length != dim) { throw new DimensionMismatchException(vals.length, dim); } [BUGGY] return FastMath.pow(2 * FastMath.PI, -dim / 2) * [BUGGY] FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals); } [CLASS] MultivariateNormalDistribution [METHOD] density [RETURN_TYPE] double final double[] vals [VARIABLES] boolean double[] covMatEigenvalues evec means vals RealMatrix covarianceMatrix covarianceMatrixInverse samplingMatrix tmpMatrix double covarianceMatrixDeterminant factor int dim ", "output": "[PATCH] return FastMath.pow(2 * FastMath.PI, -0.5 * dim) * ", "bugid": "19"}, {"instruction": "The following code contains a buggy line with the following test error: OutOfMemoryError: Java heap space testLargeSample . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   double maxError = 0;  for (int degree = 0; degree < 10; ++degree) {   PolynomialFunction p = buildRandomPolynomial(degree, randomizer);   PolynomialFitter fitter = new PolynomialFitter(new LevenbergMarquardtOptimizer());", "input": "[BUG] [BUGGY] [FE] OutOfMemoryError: Java heap space testLargeSample [CONTEXT] private RealMatrix squareRoot(RealMatrix m) { [BUGGY] [BUGGY] final EigenDecomposition dec = new EigenDecomposition(m); return dec.getSquareRoot(); } [CLASS] AbstractLeastSquaresOptimizer [METHOD] squareRoot [RETURN_TYPE] RealMatrix RealMatrix m [VARIABLES] EigenDecomposition dec boolean double[] errors objective objectiveValue params point res residuals sig startPoint target weightedResiduals weights MultivariateDifferentiableVectorFunction f jF RealMatrix j jTj m weightMatrixSqrt weightedJacobian double DEFAULT_SINGULARITY_THRESHOLD c cost covarianceSingularityThreshold threshold double[][] cov covar jacobianData weightedResidualJacobian int cols i j jacobianEvaluations maxEval nC nR rows ", "output": "[PATCH] if (m instanceof DiagonalMatrix) { final int dim = m.getRowDimension(); final RealMatrix sqrtM = new DiagonalMatrix(dim); for (int i = 0; i < dim; i++) { sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i))); } return sqrtM; } else { } ", "bugid": "20"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: assersion failed Multiply #37 x = NaN flags = 1 testMultiply . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:     0, \"Multiply #36\");  test(field.newDfp(\"1\").multiply(10000),    field.newDfp(\"10000\"),    0, \"Multiply #37\");", "input": "[BUG] [BUGGY] return multiplyFast(x); [FE] AssertionFailedError: assersion failed Multiply #37 x = NaN flags = 1 testMultiply [CONTEXT] public Dfp multiply(final int x) { [BUGGY] return multiplyFast(x); [BUGGY] } [CLASS] Dfp [METHOD] multiply [RETURN_TYPE] Dfp final int x [VARIABLES] DfpField field int[] mant product String ADD_TRAP ALIGN_TRAP DIVIDE_TRAP GREATER_THAN_TRAP LESS_THAN_TRAP MULTIPLY_TRAP NAN_STRING NEG_INFINITY_STRING NEW_INSTANCE_TRAP NEXT_AFTER_TRAP POS_INFINITY_STRING SQRT_TRAP TRUNC_TRAP fpdecimal fpexp s boolean byte FINITE INFINITE QNAN SNAN asign bsign code nans rsign sig sign x int ERR_SCALE MAX_EXP MIN_EXP RADIX adiff aextradigit bextradigit decimalPos diff e excp exp exponent extra i j lostdigit md n offset p q r result rh rsize sciexp significantDigits x ", "output": "[PATCH] if (x >= 0 && x < RADIX) { return multiplyFast(x); } else { return multiply(newInstance(x)); } ", "bugid": "21"}, {"instruction": "The following code contains a buggy line with the following test error: Exception: Unexpected exception, expected<orgapachecommonsmath3exceptionNumberIsTooLargeException> but was<orgapachecommonsmath3exceptionMathIllegalStateException> testBoundaryRangeTooLarge . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   final double[] lower = { -tooLarge };  final double[] upper = { tooLarge };  final double[] result = optimizer.optimize(10000, fitnessFunction, GoalType.MINIMIZE,   start, lower, upper).getPoint(); }", "input": "[BUG] [BUGGY] [FE] Exception: Unexpected exception, expected<orgapachecommonsmath3exceptionNumberIsTooLargeException> but was<orgapachecommonsmath3exceptionMathIllegalStateException> testBoundaryRangeTooLarge [CONTEXT]  throw new MathUnsupportedOperationException(); } else { boundaries = new double[2][]; boundaries[0] = lB; boundaries[1] = uB;  [BUGGY] [BUGGY] } } else { boundaries = null; } if (inputSigma != null) { if (inputSigma.length != init.length) { throw new DimensionMismatchException(inputSigma.length, init.length); } for (int i = 0; i < init.length; i++) { [CLASS] ", "output": "[PATCH] for (int i = 0; i < lB.length; i++) { if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) { final double max = Double.MAX_VALUE + boundaries[0][i]; final NumberIsTooLargeException e = new NumberIsTooLargeException(boundaries[1][i], max, true); e.getContext().addMessage(LocalizedFormats.OVERFLOW); e.getContext().addMessage(LocalizedFormats.INDEX, i); throw e; } } ", "bugid": "22"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Out of bounds (05246031767455861 > 05) testMath864 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   final double[] result = optimizer.optimize(10000, fitnessFunction, GoalType.MINIMIZE,   start, lower, upper).getPoint();  Assert.assertTrue(\"Out of bounds (\" + result[0] + \" > \" + upper[0] + \")\",    result[0] <= upper[0]); }", "input": "[BUG] [BUGGY] return decode(x); [FE] AssertionFailedError: Out of bounds (05246031767455861 > 05) testMath864 [CONTEXT] public double[] repairAndDecode(final double[] x) { [BUGGY] return decode(x); [BUGGY] } [CLASS] CMAESOptimizer DoubleIndex FitnessFunction [METHOD] repairAndDecode [RETURN_TYPE] double[] final double[] x [VARIABLES] boolean DEFAULT_ISACTIVECMA generateStatistics hasFiniteBounds hasInfiniteBounds hsig isActiveCMA isMinimize isRepairMode double[] doubles fitness fitnessHistory guess init inputSigma lB pcCol res sqrtDiagC uB vals x RealMatrix B BD C Cneg D arnorms arnormsInv arnormsReverse arnormsSorted arpos artmp arx arxk arz arzneg bestArx bestArz diagC diagD insigma pc ps roneu weights xmean xold zmean double DEFAULT_STOPFITNESS bestFitness bestValue cc ccov1 ccov1Sep ccovmu ccovmuSep chiN cs damps diff historyBest historyWorst logMu2 mueff negalphaold negccov negcovMax negminresidualvariance normps oldFac range sigma stopFitness stopTolFun stopTolHistFun stopTolUpX stopTolX sumw sumwq tfac val value valueRange w worstFitness double[][] boundaries sigmaArray List statisticsDHistory statisticsFitnessHistory statisticsMeanHistory statisticsSigmaHistory int DEFAULT_CHECKFEASABLECOUNT DEFAULT_DIAGONALONLY DEFAULT_MAXITERATIONS checkFeasableCount diagonalOnly dimension historySize i index iterations k lambda maxIterations mu RandomGenerator DEFAULT_RANDOMGENERATOR random ", "output": "[PATCH] return boundaries != null && isRepairMode ? decode(repair(x)) : decode(x); ", "bugid": "23"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Expected exception: orgapachecommonsmath3exceptionMathIllegalStateException testMath844 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: None", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: Expected exception: orgapachecommonsmath3exceptionMathIllegalStateException testMath844 [CONTEXT] final double y = observations[i].getY(); if (y < yMin) { yMin = y; } if (y > yMax) { yMax = y; } } a = 0.5 * (yMax - yMin); } else { [BUGGY] [BUGGY]  a = FastMath.sqrt(c1 / c2); omega = FastMath.sqrt(c2 / c3); } } [CLASS] HarmonicFitter ParameterGuesser [METHOD] guessAOmega [RETURN_TYPE] void [VARIABLES] boolean WeightedObservedPoint[] observations double a c1 c2 c3 currentX currentY dx dy f2Integral f2StepIntegral fPrime2Integral fPrime2StepIntegral omega phi previousX previousY startX sx2 sxy sxz sy2 syz x xRange y yMax yMin int i last ", "output": "[PATCH] if (c2 == 0) { throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR); } ", "bugid": "24"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<21691754E9> but was:<-2125791896E9> testMath835 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   // With the implementation that preceded the fix suggested in MATH-835,  // this test was failing, due to overflow.  Assert.assertEquals(percentage, frac.percentageValue(), Math.ulp(percentage)); }", "input": "[BUG] [BUGGY] return multiply(100).doubleValue(); [FE] AssertionFailedError: expected:<21691754E9> but was:<-2125791896E9> testMath835 [CONTEXT] public double percentageValue() { [BUGGY] return multiply(100).doubleValue(); [BUGGY] } [CLASS] Fraction [METHOD] percentageValue [RETURN_TYPE] double [VARIABLES] Fraction FOUR_FIFTHS MINUS_ONE ONE ONE_FIFTH ONE_HALF ONE_QUARTER ONE_THIRD THREE_FIFTHS THREE_QUARTERS TWO TWO_FIFTHS TWO_QUARTERS TWO_THIRDS ZERO fraction object ret rhs boolean long a0 a1 dOn nOd overflow p0 p1 p2 q0 q1 q2 serialVersionUID int d d1 d2 den denominator i maxDenominator maxIterations n num numerator tmodd1 upv uvp ", "output": "[PATCH] return 100 * doubleValue(); ", "bugid": "25"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testBigDataSet . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   }  double result = testStatistic.mannWhitneyUTest(d1, d2);  Assert.assertTrue(result > 0.1); }", "input": "[BUG] [BUGGY] final int n1n2prod = n1 * n2; [FE] AssertionFailedError testBigDataSet [CONTEXT] private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { [BUGGY] final int n1n2prod = n1 * n2; [BUGGY] final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); [CLASS] MannWhitneyUTest [METHOD] calculateAsymptoticPValue [RETURN_TYPE] double final double Umin final int n1 final int n2 [VARIABLES] NaturalRanking naturalRanking boolean NormalDistribution standardNormal double EU Umin VarU z int n1 n1n2prod n2 ", "output": "[PATCH] final double n1n2prod = n1 * n2; ", "bugid": "26"}, {"instruction": "The following code contains a buggy line with the following test error: ClassCastException: orgapachecommonsmath3geometrypartitioningBoundaryAttribute cannot be cast to javalangBoolean testIssue780 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   }  PolyhedronsSet polyhedronsSet = new PolyhedronsSet(subHyperplaneList);  Assert.assertEquals( 8.0, polyhedronsSet.getSize(), 3.0e-6);  Assert.assertEquals(24.0, polyhedronsSet.getBoundarySize(), 5.0e-6); }", "input": "[BUG] [BUGGY] if ((Boolean) tree.getAttribute()) { [FE] ClassCastException: orgapachecommonsmath3geometrypartitioningBoundaryAttribute cannot be cast to javalangBoolean testIssue780 [CONTEXT] protected void computeGeometricalProperties() { final Vector2D[][] v = getVertices(); if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); [BUGGY] if ((Boolean) tree.getAttribute()) { [BUGGY] setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(0); setBarycenter(new Vector2D(0, 0)); } } else if (v[0][0] == null) { setSize(Double.POSITIVE_INFINITY); [CLASS] PolygonsSet ComparableSegment SegmentsBuilder [METHOD] computeGeometricalProperties [RETURN_TYPE] void [VARIABLES] BSPTree tree boolean Vector2D point double factor sum sumX sumY x0 x1 y0 y1 AVLTree sorted OrderedTuple sortingKey Vector2D[][] v vertices Vector2D[] loop ", "output": "[PATCH] if (tree.getCut() == null && (Boolean) tree.getAttribute()) { ", "bugid": "27"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testMath781 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   PointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);  Assert.assertTrue(Precision.compareTo(solution.getPoint()[0], 0.0d, epsilon) > 0);  Assert.assertTrue(Precision.compareTo(solution.getPoint()[1], 0.0d, epsilon) > 0);  Assert.assertTrue(Precision.compareTo(solution.getPoint()[2], 0.0d, epsilon) < 0);", "input": "[BUG] [BUGGY] if (Precision.compareTo(entry, 0d, maxUlps) > 0) { [FE] AssertionFailedError testMath781 [CONTEXT] final double entry = tableau.getEntry(0, i); [BUGGY] if (Precision.compareTo(entry, 0d, maxUlps) > 0) { [BUGGY]  [CLASS] SimplexTableau [METHOD] dropPhase1Objective [RETURN_TYPE] void [VARIABLES] boolean maximize restrictToNonNegative RealMatrix tableau double coefficient entry epsilon sum maxUlps numArtificialVariables numDecisionVariables numSlackVariables ", "output": "[PATCH] if (Precision.compareTo(entry, 0d, epsilon) > 0) { ", "bugid": "28"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Expected exception: javalangUnsupportedOperationException testIterator . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: None", "input": "[BUG] [BUGGY] return chromosomes.iterator(); [FE] AssertionFailedError: Expected exception: javalangUnsupportedOperationException testIterator [CONTEXT] public Iterator<Chromosome> iterator() { [BUGGY] return chromosomes.iterator(); [BUGGY] } [CLASS] ListPopulation [METHOD] iterator [RETURN_TYPE] Iterator [VARIABLES] List chromosomes int populationLimit boolean ", "output": "[PATCH] return getChromosomes().iterator(); ", "bugid": "29"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testTooLargeFirstStep . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] [FE] AssertionFailedError testTooLargeFirstStep [CONTEXT] for (int i = 0; i < scale.length; ++i) { scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]); } } hNew = initializeStep(forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]); firstTime = false; } stepSize = hNew; [BUGGY] [BUGGY] for (int k = 1; k < stages; ++k) { for (int j = 0; j < y0.length; ++j) { double sum = a[k-1][0] * yDotK[0][j]; for (int l = 1; l < k; ++l) { sum += a[k-1][l] * yDotK[l][j]; } yTmp[j] = y[j] + stepSize * sum; } [CLASS] EmbeddedRungeKuttaIntegrator [METHOD] integrate [RETURN_TYPE] void ExpandableStatefulODE equations final double t [VARIABLES] ExpandableStatefulODE equations boolean filteredNextIsLast firstTime forward fsal nextIsLast double[] b c scale vecAbsoluteTolerance vecRelativeTolerance y y0 yDotTmp yTmp double error exp factor filteredNextT hNew maxGrowth maxStep minReduction minStep nextT safety scalAbsoluteTolerance scalRelativeTolerance scaledH sum t double[][] a yDotK RungeKuttaStepInterpolator interpolator prototype int i j k l stages ", "output": "[PATCH] if (forward) { if (stepStart + stepSize >= t) { stepSize = t - stepStart; } } else { if (stepStart + stepSize <= t) { stepSize = t - stepStart; } } ", "bugid": "30"}, {"instruction": "The following code contains a buggy line with the following test error: commonsmathexceptionTooManyEvaluationsException: illegal state: maximal count (100) exceeded: evaluations testIssue716 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    }  };  double result = solver.solve(100, sharpTurn, -0.9999999, 30, 15, AllowedSolution.RIGHT_SIDE);  Assert.assertEquals(0, sharpTurn.value(result), solver.getFunctionValueAccuracy());  Assert.assertTrue(sharpTurn.value(result) >= 0);", "input": "[BUG] [BUGGY] targetY = -REDUCTION_FACTOR * yB; targetY = -REDUCTION_FACTOR * yA; [FE] commonsmathexceptionTooManyEvaluationsException: illegal state: maximal count (100) exceeded: evaluations testIssue716 [CONTEXT] default : throw new MathInternalError(null); } } double targetY; if (agingA >= MAXIMAL_AGING) { [BUGGY] targetY = -REDUCTION_FACTOR * yB; } else if (agingB >= MAXIMAL_AGING) { [BUGGY] targetY = -REDUCTION_FACTOR * yA; } else { targetY = 0; } double nextX; [CLASS] BracketingNthOrderBrentSolver [METHOD] doSolve [RETURN_TYPE] double [VARIABLES] AllowedSolution allowed boolean double[] tmpX x y double DEFAULT_ABSOLUTE_ACCURACY REDUCTION_FACTOR absYA absYB absoluteAccuracy functionValueAccuracy nextX nextY relativeAccuracy targetY xA xB xTol yA yB int DEFAULT_MAXIMAL_ORDER MAXIMAL_AGING agingA agingB end maximalOrder nbPoints signChangeIndex start ", "output": "[PATCH] final int p = agingA - MAXIMAL_AGING; final double weightA = (1 << p) - 1; final double weightB = p + 1; targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB); final int p = agingB - MAXIMAL_AGING; final double weightA = p + 1; final double weightB = (1 << p) - 1; targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB); ", "bugid": "31"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<16644508338125354> but was:<031909161062727365> testEvaluateArraySegmentWeighted . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: None", "input": "[BUG] [BUGGY] for (int i = 0; i < weights.length; i++) { [FE] AssertionFailedError: expected:<16644508338125354> but was:<031909161062727365> testEvaluateArraySegmentWeighted [CONTEXT] double accum = 0.0; double dev = 0.0; double accum2 = 0.0; for (int i = begin; i < begin + length; i++) { dev = values[i] - mean; accum += weights[i] * (dev * dev); accum2 += weights[i] * dev; } double sumWts = 0; [BUGGY] for (int i = 0; i < weights.length; i++) { [BUGGY] sumWts += weights[i]; } if (isBiasCorrected) { var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0); } else { var = (accum - (accum2 * accum2 / sumWts)) / sumWts; } } } [CLASS] Variance [METHOD] evaluate [RETURN_TYPE] double final double[] values final double[] weights final double mean final int begin final int length [VARIABLES] boolean incMoment isBiasCorrected double[] values weights long serialVersionUID SecondMoment m2 moment double accum accum2 dev mean sumWts var int begin i length ", "output": "[PATCH] for (int i = begin; i < begin + length; i++) { ", "bugid": "32"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<25> but was:<NaN> testOverrideMeanWithMathClass . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:     stats.addValue(i);  }  Assert.assertEquals((new Mean()).evaluate(scores),stats.getMean(), 0);  }", "input": "[BUG] [BUGGY] if (!(meanImpl instanceof Mean)) { if (!(varianceImpl instanceof Variance)) { if (!(geoMeanImpl instanceof GeometricMean)) { [FE] AssertionFailedError: expected:<25> but was:<NaN> testOverrideMeanWithMathClass [CONTEXT] public void addValue(double value) { sumImpl.increment(value); sumsqImpl.increment(value); minImpl.increment(value); maxImpl.increment(value); sumLogImpl.increment(value); secondMoment.increment(value);  [BUGGY] if (!(meanImpl instanceof Mean)) { meanImpl.increment(value); } [BUGGY] if (!(varianceImpl instanceof Variance)) { varianceImpl.increment(value); } if (!(geoMeanImpl instanceof GeometricMean)) { geoMeanImpl.increment(value); } n++; } [CLASS] SummaryStatistics [METHOD] addValue [RETURN_TYPE] void double value [VARIABLES] SumOfLogs sumLog Mean mean SumOfSquares sumsq StorelessUnivariateStatistic geoMeanImpl maxImpl meanImpl minImpl sumImpl sumLogImpl sumsqImpl varianceImpl Max max double value GeometricMean geoMean Sum sum long n serialVersionUID Variance variance Min min boolean SecondMoment secondMoment ", "output": "[PATCH] if (meanImpl != mean) { if (varianceImpl != variance) { if (geoMeanImpl != geoMean) { ", "bugid": "33"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Expected exception: orgapachecommonsmathexceptionNumberIsTooLargeException testMath679 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: None", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: Expected exception: orgapachecommonsmathexceptionNumberIsTooLargeException testMath679 [CONTEXT] public OpenMapRealMatrix(int rowDimension, int columnDimension) { super(rowDimension, columnDimension); [BUGGY] [BUGGY] this.rows = rowDimension; this.columns = columnDimension; this.entries = new OpenIntToDoubleHashMap(0.0); } [CLASS] OpenMapRealMatrix [METHOD] <init> [RETURN_TYPE] OpenMapRealMatrix(int,int) int rowDimension int columnDimension [VARIABLES] boolean OpenIntToDoubleHashMap entries long serialVersionUID int columnDimension columns rowDimension rows ", "output": "[PATCH] long lRow = (long) rowDimension; long lCol = (long) columnDimension; if (lRow * lCol >= (long) Integer.MAX_VALUE) { throw new NumberIsTooLargeException(lRow * lCol, Integer.MAX_VALUE, false); } ", "bugid": "34"}, {"instruction": "The following code contains a buggy line with the following test error: Exception: Unexpected exception, expected<orgapachecommonsmathexceptionConvergenceException> but was<orgapachecommonsmathexceptionTooManyEvaluationsException> testIssue631 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   final UnivariateRealSolver solver = new RegulaFalsiSolver();  final double root = solver.solve(3624, f, 1, 10);  Assert.assertEquals(3.4341896575482003, root, 1e-15);\t}", "input": "[BUG] [BUGGY] [FE] Exception: Unexpected exception, expected<orgapachecommonsmathexceptionConvergenceException> but was<orgapachecommonsmathexceptionTooManyEvaluationsException> testIssue631 [CONTEXT] switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI:  [BUGGY] [BUGGY] break; default: throw new MathInternalError(); } } x1 = x; f1 = fx;  [CLASS] ", "output": "[PATCH] if (x == x1) { throw new ConvergenceException(); } ", "bugid": "35"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Expected exception: orgapachecommonsmathexceptionTooManyEvaluationsException testIssue631 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: None", "input": "[BUG] [BUGGY] if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } [FE] AssertionFailedError: Expected exception: orgapachecommonsmathexceptionTooManyEvaluationsException testIssue631 [CONTEXT] } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: [BUGGY] if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } [BUGGY] break; default: throw new MathInternalError(); } } [CLASS] BaseSecantSolver Method [METHOD] doSolve [RETURN_TYPE] double [VARIABLES] AllowedSolution allowed allowedSolution Method ILLINOIS PEGASUS REGULA_FALSI method boolean inverted double DEFAULT_ABSOLUTE_ACCURACY absoluteAccuracy atol f0 f1 ftol functionValueAccuracy fx max min relativeAccuracy rtol startValue x x0 x1 ", "output": "[PATCH] [Delete] ", "bugid": "36"}, {"instruction": "The following code contains a buggy line with the following test error: commonsmathexceptionTooManyEvaluationsException: illegal state: maximal count (3,624) exceeded: evaluations testIssue631 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   final UnivariateRealSolver solver = new RegulaFalsiSolver();  final double root = solver.solve(3624, f, 1, 10);  Assert.assertEquals(3.4341896575482003, root, 1e-15);\t}", "input": "[BUG] [BUGGY] [FE] commonsmathexceptionTooManyEvaluationsException: illegal state: maximal count (3,624) exceeded: evaluations testIssue631 [CONTEXT] f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; [BUGGY] [BUGGY]  default: } } [CLASS] BaseSecantSolver Method [METHOD] doSolve [RETURN_TYPE] double [VARIABLES] AllowedSolution allowed allowedSolution Method ILLINOIS PEGASUS REGULA_FALSI method boolean inverted double DEFAULT_ABSOLUTE_ACCURACY absoluteAccuracy atol f0 f1 ftol functionValueAccuracy fx max min relativeAccuracy rtol startValue x x0 x1 ", "output": "[PATCH] case REGULA_FALSI: if (x == x1) { final double delta = FastMath.max(rtol * FastMath.abs(x1), atol); x0 = 0.5 * (x0 + x1 - delta); f0 = computeObjectiveValue(x0); } break; throw new MathInternalError(); ", "bugid": "37"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testAddNaN . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   z = new Complex(1, nan);  Complex w = x.add(z);  Assert.assertTrue(Double.isNaN(w.getReal()));  Assert.assertTrue(Double.isNaN(w.getImaginary())); }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError testAddNaN [CONTEXT] public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); [BUGGY] [BUGGY] return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); } [CLASS] Complex [METHOD] add [RETURN_TYPE] Complex Complex rhs [VARIABLES] boolean isInfinite isNaN double imaginary q real long serialVersionUID Complex I INF NaN ONE ZERO rhs ", "output": "[PATCH] if (isNaN || rhs.isNaN) { return NaN; } ", "bugid": "38"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Wrong multidimensional index for [3][2] expected:<3> but was:<2> testIterationConsistency . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    final int[] indices = c.getCounts(uniDimIndex);   for (int dimIndex = 0; dimIndex < nDim; dimIndex++) {    Assert.assertEquals(\"Wrong multidimensional index for [\" + i + \"][\" + dimIndex + \"]\",     expected[i][dimIndex], indices[dimIndex]);   }", "input": "[BUG] [BUGGY] int idx = 1; while (count < index) { count += idx; ++idx; } --idx; indices[last] = idx; [FE] AssertionFailedError: Wrong multidimensional index for [3][2] expected:<3> but was:<2> testIterationConsistency [CONTEXT] final int offset = uniCounterOffset[i]; while (count <= index) { count += offset; ++idx; } --idx; count -= offset; indices[i] = idx; } [BUGGY] int idx = 1; while (count < index) { count += idx; ++idx; } --idx; indices[last] = idx; [BUGGY] return indices; } [CLASS] MultidimensionalCounter Iterator [METHOD] getCounts [RETURN_TYPE] int[] int index [VARIABLES] int[] counter indices size uniCounterOffset int count dim dimension i idx index j last offset tS totalSize boolean ", "output": "[PATCH] indices[last] = index - count; ", "bugid": "39"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testSmallDistances . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    }  }  assertTrue(uniquePointIsCenter); }", "input": "[BUG] [BUGGY] int sum = 0; [FE] AssertionFailedError testSmallDistances [CONTEXT] final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>(); final T firstPoint = pointSet.remove(random.nextInt(pointSet.size())); resultSet.add(new Cluster<T>(firstPoint)); final double[] dx2 = new double[pointSet.size()]; while (resultSet.size() < k) {  [BUGGY] int sum = 0; [BUGGY] for (int i = 0; i < pointSet.size(); i++) { final T p = pointSet.get(i); final Cluster<T> nearest = getNearestCluster(resultSet, p); final double d = p.distanceFrom(nearest.getCenter()); sum += d * d; dx2[i] = sum; }  [CLASS] ", "output": "[PATCH] double sum = 0; ", "bugid": "40"}, {"instruction": "The following code contains a buggy line with the following test error: commonsmathexceptionNotStrictlyPositiveException: -1277 is smaller than, or equal to, the minimum (0) testMath519 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void testMath519() {  // The optimizer will try negative sigma values but \"GaussianFitter\"  // will catch the raised exceptions and return NaN values instead.  final double[] data = { ", "input": "[BUG] [BUGGY] return fit(new Gaussian.Parametric(), guess); [FE] commonsmathexceptionNotStrictlyPositiveException: -1277 is smaller than, or equal to, the minimum (0) testMath519 [CONTEXT] public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); [BUGGY] return fit(new Gaussian.Parametric(), guess); [BUGGY] } [CLASS] GaussianFitter 1 ParameterGuesser 1 [METHOD] fit [RETURN_TYPE] double[] [VARIABLES] ParametricUnivariateRealFunction f g boolean WeightedObservedPoint[] observations double[] guess initialGuess p parameters v ", "output": "[PATCH] return fit(guess); ", "bugid": "41"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: max(500, -500) expected:<500> but was:<-500> testMinMaxFloat . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:     FastMath.max(pair[0], pair[1]),    MathUtils.EPSILON);   Assert.assertEquals(\"max(\" + pair[1] + \", \" + pair[0] + \")\",    Math.max(pair[1], pair[0]),    FastMath.max(pair[1], pair[0]),", "input": "[BUG] [BUGGY] return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b); [FE] AssertionFailedError: max(500, -500) expected:<500> but was:<-500> testMinMaxFloat [CONTEXT] public static float max(final float a, final float b) { [BUGGY] return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b); [BUGGY] } [CLASS] FastMath [METHOD] max [RETURN_TYPE] float final float a final float b [VARIABLES] double[][] LN_HI_PREC_COEF LN_MANT LN_QUICK_COEF LN_SPLIT_COEF boolean double[] CBRTTWO COSINE_TABLE_A COSINE_TABLE_B EIGHTHES EXP_FRAC_TABLE_A EXP_FRAC_TABLE_B EXP_INT_TABLE_A EXP_INT_TABLE_B FACT SINE_TABLE_A SINE_TABLE_B TANGENT_TABLE_A TANGENT_TABLE_B a ans as b bs facts hiPrec hiPrecOut in lnm lns reduceResults result split temps x x2 xs y ys zs float a b long[] PI_O_4_BITS RECIP_2PI double E LN_2_A LN_2_B PI a a2 aa ab absAsinh absAtanh b baseA baseB c cosEpsA cosEpsB cosa cosaa cosab cosb costA costB d da daa dab db denom denomb denomr direction dx epsA epsA2 epsB epsilon err est esta estb extra facta factb fracPartA fracPartB fx1 intPartA intPartB invx invy lna lnb lnza lnzb mant na nb numer p p2 pi2a pi2b pia pib r ra ratio ratioa ratiob rb recip recipa recipb remA remB result resultb rln10a rln10b sinEpsA sinEpsB sina sinb sintA sintB sumA sumB t temp temp2 tempA tempB tempC tmp tmp1 tmp2 tmpA tmpB x x2 xa xb xbadj xi xpa xpb xs y ya yaa yab yb z za zaa zab zb ", "output": "[PATCH] return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a); ", "bugid": "42"}, {"instruction": "The following code contains a buggy line with the following test error: commonsmathConvergenceException: Continued fraction diverged to NaN for value testExtremeValues . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   }    assertEquals(distribution.cumulativeProbability(Double.MAX_VALUE), 1, 0);  assertEquals(distribution.cumulativeProbability(-Double.MAX_VALUE), 0, 0);  assertEquals(distribution.cumulativeProbability(Double.POSITIVE_INFINITY), 1, 0);", "input": "[BUG] [BUGGY] try { } catch (MaxIterationsExceededException ex) { if (x < (mean - 20 * standardDeviation)) { return 0; } else if (x > (mean + 20 * standardDeviation)) { return 1; } else { throw ex; } } [FE] commonsmathConvergenceException: Continued fraction diverged to NaN for value testExtremeValues [CONTEXT] public double cumulativeProbability(double x) throws MathException { final double dev = x - mean; [BUGGY] try { return 0.5 * (1.0 + Erf.erf((dev) / (standardDeviation * FastMath.sqrt(2.0)))); } catch (MaxIterationsExceededException ex) { if (x < (mean - 20 * standardDeviation)) { return 0; } else if (x > (mean + 20 * standardDeviation)) { return 1; } else { throw ex; [BUGGY] } [CLASS] NormalDistributionImpl [METHOD] cumulativeProbability [RETURN_TYPE] double double x [VARIABLES] MaxIterationsExceededException ex boolean double DEFAULT_INVERSE_ABSOLUTE_ACCURACY SQRT2PI dev inverseCumAccuracy mean sd solverAbsoluteAccuracy standardDeviation x x0 x1 long serialVersionUID ", "output": "[PATCH] if (FastMath.abs(dev) > 40 * standardDeviation) { return dev < 0 ? 0.0d : 1.0d; } ", "bugid": "43"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testArrayEquals . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    Double.NEGATIVE_INFINITY, 1d, 0d     }));  assertFalse(MathUtils.equals(new double[] { Double.NaN },  new double[] { Double.NaN }));  assertFalse(MathUtils.equals(new double[] { Double.POSITIVE_INFINITY },", "input": "[BUG] [BUGGY] return (Double.isNaN(x) && Double.isNaN(y)) || x == y; [FE] AssertionFailedError testArrayEquals [CONTEXT] public static boolean equals(double x, double y) { [BUGGY] return (Double.isNaN(x) && Double.isNaN(y)) || x == y; [BUGGY] } [CLASS] MathUtils OrderDirection [METHOD] equals [RETURN_TYPE] boolean double x double y [VARIABLES] boolean long[] FACTORIALS double EPSILON SAFE_MIN TWO_PI eps logSum result x y byte NB PB ZB short NS PS ZS int NAN_GAP i j k n x y long SGN_MASK a b d result ret s OrderDirection DECREASING INCREASING ", "output": "[PATCH] return equals(x, y, 1); ", "bugid": "44"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testPValueNearZero . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   }  PearsonsCorrelation corrInstance = new PearsonsCorrelation(data);  assertTrue(corrInstance.getCorrelationPValues().getEntry(0, 1) > 0); }", "input": "[BUG] [BUGGY] out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t)); [FE] AssertionFailedError testPValueNearZero [CONTEXT] TDistribution tDistribution = new TDistributionImpl(nObs - 2); int nVars = correlationMatrix.getColumnDimension(); double[][] out = new double[nVars][nVars]; for (int i = 0; i < nVars; i++) { for (int j = 0; j < nVars; j++) { if (i == j) { out[i][j] = 0d; } else { double r = correlationMatrix.getEntry(i, j); double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r))); [BUGGY] out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t)); [BUGGY] } } } return new BlockRealMatrix(out); } [CLASS] PearsonsCorrelation [METHOD] getCorrelationPValues [RETURN_TYPE] RealMatrix [VARIABLES] double[][] out TDistribution tDistribution boolean RealMatrix correlationMatrix covarianceMatrix matrix int i j nObs nVars numberOfObservations double r t ", "output": "[PATCH] out[i][j] = 2 * tDistribution.cumulativeProbability(-t); ", "bugid": "45"}, {"instruction": "The following code contains a buggy line with the following test error: null  testMath369 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   UnivariateRealFunction f = new SinFunction();  UnivariateRealSolver solver = new BisectionSolver();  assertEquals(Math.PI, solver.solve(f, 3.0, 3.2, 3.1), solver.getAbsoluteAccuracy()); }", "input": "[BUG] [BUGGY] return solve(min, max); [FE] null  testMath369 [CONTEXT] public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { [BUGGY] return solve(min, max); [BUGGY] } [CLASS] BisectionSolver [METHOD] solve [RETURN_TYPE] double UnivariateRealFunction f double min double max double initial [VARIABLES] boolean double initial max min UnivariateRealFunction f ", "output": "[PATCH] return solve(f, min, max); ", "bugid": "46"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Expecting IllegalArgumentException - non-bracketing testBadEndpoints . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   try {  // bad interval   solver.solve(f, 1, -1);   fail(\"Expecting IllegalArgumentException - bad interval\");  } catch (IllegalArgumentException ex) {   // expected", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: Expecting IllegalArgumentException - non-bracketing testBadEndpoints [CONTEXT] if (Math.abs(yMax) <= functionValueAccuracy) { setResult(yMax, 0); return result; } if (yInitial * yMax < 0) { return solve(f, initial, yInitial, max, yMax, initial, yInitial); } [BUGGY] [BUGGY] return solve(f, min, yMin, max, yMax, initial, yInitial); } [CLASS] BrentSolver [METHOD] solve [RETURN_TYPE] double UnivariateRealFunction f final double min final double max final double initial [VARIABLES] UnivariateRealFunction f String NON_BRACKETING_MESSAGE boolean long serialVersionUID double initial max min yInitial yMax yMin ", "output": "[PATCH] if (yMin * yMax > 0) { throw MathRuntimeException.createIllegalArgumentException( NON_BRACKETING_MESSAGE, min, max, yMin, yMax); } ", "bugid": "47"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError polynomial . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:     assertTrue(integ.getEvaluations() > 140);   } else {    assertTrue(integ.getEvaluations() < 90);   }  }", "input": "[BUG] [BUGGY] final double[] scale; scale = new double[y0.length]; java.util.Arrays.fill(scale, scalAbsoluteTolerance); scale = vecAbsoluteTolerance; [FE] AssertionFailedError polynomial [CONTEXT] double error = 0; for (boolean loop = true; loop;) { if (firstTime || !fsal) { computeDerivatives(stepStart, y, yDotK[0]); } if (firstTime) { [BUGGY] final double[] scale; if (vecAbsoluteTolerance == null) { scale = new double[y0.length]; java.util.Arrays.fill(scale, scalAbsoluteTolerance); [BUGGY] } else { scale = vecAbsoluteTolerance; } hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]); firstTime = false; } [CLASS] EmbeddedRungeKuttaIntegrator [METHOD] integrate [RETURN_TYPE] double FirstOrderDifferentialEquations equations final double t0 final double[] y0 final double t final double[] y [VARIABLES] boolean firstTime forward fsal lastStep loop nextIsLast CombinedEventsManager manager double[] b c scale vecAbsoluteTolerance vecRelativeTolerance y y0 yTmp double dt error exp factor hNew maxGrowth maxStep minReduction minStep nextStep nextT safety scalAbsoluteTolerance scalRelativeTolerance scaledH stopTime sum t t0 double[][] a yDotK AbstractStepInterpolator interpolator StepHandler handler RungeKuttaStepInterpolator prototype rki int j k l stages FirstOrderDifferentialEquations equations ", "output": "[PATCH] final double[] scale = new double[y0.length]; for (int i = 0; i < scale.length; ++i) { scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]); } for (int i = 0; i < scale.length; ++i) { scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]); } ", "bugid": "48"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: three (Object) pct expected:<05> but was:<10> testPcts . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertEquals(\"three pct\",0.5,f.getPct(threeL),tolerance);  // MATH-329  assertEquals(\"three (Object) pct\",0.5,f.getPct((Object) (Integer.valueOf(3))),tolerance);  assertEquals(\"five pct\",0,f.getPct(5),tolerance);  assertEquals(\"foo pct\",0,f.getPct(\"foo\"),tolerance);", "input": "[BUG] [BUGGY] return getCumPct((Comparable<?>) v); [FE] AssertionFailedError: three (Object) pct expected:<05> but was:<10> testPcts [CONTEXT] public double getPct(Object v) { [BUGGY] return getCumPct((Comparable<?>) v); [BUGGY] } [CLASS] Frequency NaturalComparator [METHOD] getPct [RETURN_TYPE] double Object v [VARIABLES] Object v boolean TreeMap freqTable long result serialVersionUID v ", "output": "[PATCH] return getPct((Comparable<?>) v); ", "bugid": "49"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<16828208208485466> but was:<2065474511575945> testMathpbx02 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   double[] eigenValues = decomposition.getRealEigenvalues();  for (int i = 0; i < refEigenValues.length; ++i) {   assertEquals(refEigenValues[i], eigenValues[i], 1.0e-3);   if (refEigenVectors[i].dotProduct(decomposition.getEigenvector(i)) < 0) {    assertEquals(0, refEigenVectors[i].add(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);", "input": "[BUG] [BUGGY] int j = 4 * n - 1; [FE] AssertionFailedError: expected:<16828208208485466> but was:<2065474511575945> testMathpbx02 [CONTEXT] private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { [BUGGY] int j = 4 * n - 1; [BUGGY] for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } [CLASS] EigenDecompositionImpl Solver [METHOD] flipIfWarranted [RETURN_TYPE] boolean final int n final int step [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start step tType threeFourthCount upperStart TriDiagonalTransformer transformer ", "output": "[PATCH] int j = 4 * (n - 1); ", "bugid": "51"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<100> but was:<115> testMath288 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   SimplexSolver solver = new SimplexSolver();  RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);  assertEquals(10.0, solution.getValue(), .0000001); }", "input": "[BUG] [BUGGY] if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { [FE] AssertionFailedError: expected:<100> but was:<115> testMath288 [CONTEXT] private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); [BUGGY] if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { [BUGGY] final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; } [CLASS] SimplexSolver [METHOD] getPivotRow [RETURN_TYPE] Integer final int col SimplexTableau tableau [VARIABLES] Integer minRatioPos boolean SimplexTableau tableau double DEFAULT_EPSILON entry epsilon minRatio minValue ratio rhs int col i ", "output": "[PATCH] if (MathUtils.compareTo(entry, 0, epsilon) > 0) { ", "bugid": "52"}, {"instruction": "The following code contains a buggy line with the following test error: commonsmathMathException testMath280 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void testMath280() throws MathException {  NormalDistribution normal = new NormalDistributionImpl(0,1);  double result = normal.inverseCumulativeProbability(0.9772498680518209);  assertEquals(2.0, result, 1.0e-12); }", "input": "[BUG] [BUGGY] if (fa * fb >= 0.0 ) { [FE] commonsmathMathException testMath280 [CONTEXT] do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); [BUGGY] if (fa * fb >= 0.0 ) { [BUGGY] throw new ConvergenceException(\"number of iterations={0}, maximum iterations={1},\" +\"initial={2}, lower bound={3}, upper bound={4}, final a value={5},\" +\"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; } [CLASS] UnivariateRealSolverUtils LazyHolder [METHOD] bracket [RETURN_TYPE] double[] UnivariateRealFunction function double initial double lowerBound double upperBound int maximumIterations [VARIABLES] UnivariateRealSolverFactory FACTORY UnivariateRealFunction function boolean double a b fa fb initial lowerBound upperBound int maximumIterations numIterations ", "output": "[PATCH] if (fa * fb > 0.0 ) { ", "bugid": "53"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<100> but was:<00> testSingleVariableAndConstraint . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   SimplexSolver solver = new SimplexSolver();  RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);  assertEquals(10.0, solution.getPoint()[0], 0.0);  assertEquals(30.0, solution.getValue(), 0.0); }", "input": "[BUG] [BUGGY] if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) { if (row == null) { } else { } [FE] AssertionFailedError: expected:<100> but was:<00> testSingleVariableAndConstraint [CONTEXT] private Integer getBasicRow(final int col) { Integer row = null; for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) { [BUGGY] if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) { if (row == null) { row = i; } else { [BUGGY] return null; } } } return row; } [CLASS] SimplexTableau [METHOD] getBasicRow [RETURN_TYPE] Integer final int col [VARIABLES] Integer row boolean maximize restrictToNonNegative RealMatrix tableau double coefficient epsilon sum LinearObjectiveFunction f Collection constraints long serialVersionUID int artificialVar col count height i numArtificialVariables numDecisionVariables numSlackVariables row slackVar width zIndex ", "output": "[PATCH] if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) { } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) { ", "bugid": "54"}, {"instruction": "The following code contains a buggy line with the following test error: ClassCastException: javalangObject cannot be cast to javalangComparable testAddNonComparable . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void testAddNonComparable(){  try {   f.addValue(new Object()); // This was previously OK   fail(\"Expected IllegalArgumentException\");  } catch (IllegalArgumentException expected) {", "input": "[BUG] [BUGGY] addValue((Comparable<?>) v); [FE] ClassCastException: javalangObject cannot be cast to javalangComparable testAddNonComparable [CONTEXT] public void addValue(Object v) { [BUGGY] addValue((Comparable<?>) v); [BUGGY] } [CLASS] Frequency NaturalComparator [METHOD] addValue [RETURN_TYPE] void Object v [VARIABLES] Object v boolean TreeMap freqTable long serialVersionUID ", "output": "[PATCH] if (v instanceof Comparable<?>){ addValue((Comparable<?>) v); } else { throw new IllegalArgumentException(\"Object must implement Comparable\"); } ", "bugid": "55"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<-1> but was:<0> testCompareTo . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   Fraction pi1 = new Fraction(1068966896, 340262731);  Fraction pi2 = new Fraction( 411557987, 131002976);  assertEquals(-1, pi1.compareTo(pi2));  assertEquals( 1, pi2.compareTo(pi1));  assertEquals(0.0, pi1.doubleValue() - pi2.doubleValue(), 1.0e-20);", "input": "[BUG] [BUGGY] double nOd = doubleValue(); double dOn = object.doubleValue(); [FE] AssertionFailedError: expected:<-1> but was:<0> testCompareTo [CONTEXT] public int compareTo(Fraction object) { [BUGGY] double nOd = doubleValue(); double dOn = object.doubleValue(); [BUGGY] return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0); } [CLASS] Fraction [METHOD] compareTo [RETURN_TYPE] int Fraction object [VARIABLES] Fraction MINUS_ONE ONE TWO ZERO object ret boolean long a0 a1 overflow p0 p1 p2 q0 q1 q2 serialVersionUID int d den denominator maxDenominator maxIterations n num numerator double dOn nOd ", "output": "[PATCH] long nOd = ((long) numerator) * object.denominator; long dOn = ((long) denominator) * object.numerator; ", "bugid": "56"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<98304> but was:<3440640> testGcd . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   int a = 30;  int b = 50;  int c = 77;  assertEquals(0, MathUtils.gcd(0, 0));", "input": "[BUG] [BUGGY] if (u * v == 0) { [FE] AssertionFailedError: expected:<98304> but was:<3440640> testGcd [CONTEXT] public static int gcd(int u, int v) { [BUGGY] if (u * v == 0) { [BUGGY] return (Math.abs(u) + Math.abs(v)); } if (u > 0) { u = -u; } [CLASS] MathUtils [METHOD] gcd [RETURN_TYPE] int int u int v [VARIABLES] short NS PS ZS boolean double EPSILON SAFE_MIN TWO_PI logSum x y byte NB PB ZB int k t u v ", "output": "[PATCH] if ((u == 0) || (v == 0)) { ", "bugid": "57"}, {"instruction": "The following code contains a buggy line with the following test error: IllegalArgumentException: Invalid endpoint parameters: lowerBound=00 initial=-10 upperBound=17976931348623157E308 testSmallDegreesOfFreedom . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:     1.0, 1.0);  double p = fd.cumulativeProbability(0.975);  double x = fd.inverseCumulativeProbability(p);  assertEquals(0.975, x, 1.0e-5);", "input": "[BUG] [BUGGY] ret = d / (d - 2.0); [FE] IllegalArgumentException: Invalid endpoint parameters: lowerBound=00 initial=-10 upperBound=17976931348623157E308 testSmallDegreesOfFreedom [CONTEXT] protected double getInitialDomain(double p) { double ret; double d = getDenominatorDegreesOfFreedom(); [BUGGY] ret = d / (d - 2.0); [BUGGY] return ret; } [CLASS] FDistributionImpl [METHOD] getInitialDomain [RETURN_TYPE] double double p [VARIABLES] double d denominatorDegreesOfFreedom m n numeratorDegreesOfFreedom p ret x long serialVersionUID boolean ", "output": "[PATCH] if (d > 2.0) { ret = d / (d - 2.0); } ", "bugid": "58"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<orgapachecommonsmathcomplexComplex@98b00000> but was:<orgapachecommonsmathcomplexComplex@18b00000> testMath221 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  }", "input": "[BUG] [BUGGY] ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); [FE] AssertionFailedError: expected:<orgapachecommonsmathcomplexComplex@98b00000> but was:<orgapachecommonsmathcomplexComplex@18b00000> testMath221 [CONTEXT] if (this == other) { ret = true; } else if (other == null) { ret = false; } else{ try { Complex rhs = (Complex)other; if (rhs.isNaN()) { ret = this.isNaN(); } else { [BUGGY] ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); [BUGGY] } } catch (ClassCastException ex) { ret = false; } } return ret; } [CLASS] Complex [METHOD] equals [RETURN_TYPE] boolean Object other [VARIABLES] Object other boolean ret double c d denominator imaginary q real long serialVersionUID Complex I INF NaN ONE ZERO rhs ClassCastException ex ", "output": "[PATCH] ret = (real == rhs.real) && (imaginary == rhs.imaginary); ", "bugid": "59"}, {"instruction": "The following code contains a buggy line with the following test error: StringIndexOutOfBoundsException: String index out of range: 6 testForgottenImaginaryCharacter . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: None", "input": "[BUG] [BUGGY] [FE] StringIndexOutOfBoundsException: String index out of range: 6 testForgottenImaginaryCharacter [CONTEXT]  pos.setIndex(initialIndex); return null; } int n = getImaginaryCharacter().length(); startIndex = pos.getIndex(); int endIndex = startIndex + n; [BUGGY] [BUGGY] if ( source.substring(startIndex, endIndex).compareTo( getImaginaryCharacter()) != 0) {  pos.setIndex(initialIndex); pos.setErrorIndex(startIndex); return null; } pos.setIndex(endIndex); [CLASS] ComplexFormat [METHOD] parse [RETURN_TYPE] Complex String source ParsePosition pos [VARIABLES] boolean Number im re char c String DEFAULT_IMAGINARY_CHARACTER imaginaryCharacter source long serialVersionUID int endIndex initialIndex n sign startIndex NumberFormat f format imaginaryFormat nf realFormat ParsePosition pos ", "output": "[PATCH] if ((startIndex >= source.length()) || (endIndex > source.length()) || ", "bugid": "60"}, {"instruction": "The following code contains a buggy line with the following test error: commonsmathMaxIterationsExceededException: Maximal number of iterations (10,000) exceeded testExtremeValues . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   distribution.setStandardDeviation(1);  for (int i = 0; i < 100; i+=5) { // make sure no convergence exception   double lowerTail = distribution.cumulativeProbability((double)-i);   double upperTail = distribution.cumulativeProbability((double) i);   if (i < 10) { // make sure not top-coded", "input": "[BUG] [BUGGY] return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(2.0)))); [FE] commonsmathMaxIterationsExceededException: Maximal number of iterations (10,000) exceeded testExtremeValues [CONTEXT] public double cumulativeProbability(double x) throws MathException { [BUGGY] return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(2.0)))); [BUGGY] } [CLASS] NormalDistributionImpl [METHOD] cumulativeProbability [RETURN_TYPE] double double x [VARIABLES] double mean sd standardDeviation x long serialVersionUID boolean ", "output": "[PATCH] try { return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(2.0)))); } catch (MaxIterationsExceededException ex) { if (x < (mean - 20 * standardDeviation)) { return 0.0d; } else if (x > (mean + 20 * standardDeviation)) { return 1.0d; } else { throw ex; } } ", "bugid": "61"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<0632120558828558> but was:<06321205587649603> testRegularizedGammaPositivePositive . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  }", "input": "[BUG] [BUGGY] private static final double DEFAULT_EPSILON = 10e-9; [FE] AssertionFailedError: expected:<0632120558828558> but was:<06321205587649603> testRegularizedGammaPositivePositive [CONTEXT] [BUGGY] private static final double DEFAULT_EPSILON = 10e-9; [CLASS] Gamma 1 [VARIABLES] ", "output": "[PATCH] private static final double DEFAULT_EPSILON = 10e-15; ", "bugid": "62"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testSSENonNegative . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void testSSENonNegative() {  double[] y = { 8915.102, 8919.302, 8923.502 };  double[] x = { 1.107178495E2, 1.107264895E2, 1.107351295E2 };  SimpleRegression reg = new SimpleRegression();  for (int i = 0; i < x.length; i++) {   reg.addData(x[i], y[i]);  }  assertTrue(reg.getSumSquaredErrors() >= 0.0); }", "input": "[BUG] [BUGGY] return sumYY - sumXY * sumXY / sumXX; [FE] AssertionFailedError testSSENonNegative [CONTEXT] public double getSumSquaredErrors() { [BUGGY] return sumYY - sumXY * sumXY / sumXX; [BUGGY] } [CLASS] SimpleRegression [METHOD] getSumSquaredErrors [RETURN_TYPE] double [VARIABLES] double b1 dx dy sumX sumXX sumXY sumY sumYY x xbar y ybar long n serialVersionUID boolean ", "output": "[PATCH] return Math.max(0d, sumYY - sumXY * sumXY / sumXX); ", "bugid": "63"}, {"instruction": "The following code contains a buggy line with the following test error: StringIndexOutOfBoundsException: String index out of range: 2 testEscapeSurrogatePairs . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] pos += Character.charCount(Character.codePointAt(input, pos)); [FE] StringIndexOutOfBoundsException: String index out of range: 2 testEscapeSurrogatePairs [CONTEXT] int consumed = translate(input, pos, out); if (consumed == 0) { char[] c = Character.toChars(Character.codePointAt(input, pos)); out.write(c); pos+= c.length; continue; }  for (int pt = 0; pt < consumed; pt++) { [BUGGY] pos += Character.charCount(Character.codePointAt(input, pos)); [BUGGY] } } } [CLASS] CharSequenceTranslator [METHOD] translate [RETURN_TYPE] void CharSequence input Writer out [VARIABLES] boolean CharSequence input Writer out int consumed len pos pt char[] c ", "output": "[PATCH] pos += Character.charCount(Character.codePointAt(input, pt)); ", "bugid": "64"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Parsed dates should be equal expected:<null> but was:<Fri Jan 02 21:00:00 PST 1970> testLANG_832 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: None", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: Parsed dates should be equal expected:<null> but was:<Fri Jan 02 21:00:00 PST 1970> testLANG_832 [CONTEXT] break; } String nextFormatField= patternMatcher.group(); nextStrategy = getStrategy(nextFormatField); if(currentStrategy.addRegex(this, regex)) { collector.add(currentStrategy); } currentFormatField= nextFormatField; currentStrategy= nextStrategy; } [BUGGY] [BUGGY] if(currentStrategy.addRegex(this, regex)) { collector.add(currentStrategy); } currentFormatField= null; strategies= collector.toArray(new Strategy[collector.size()]); parsePattern= Pattern.compile(regex.toString()); } [CLASS] FastDateParser KeyValue 1 CopyQuotedStrategy TextStrategy NumberStrategy 2 TimeZoneStrategy 3 4 5 [METHOD] init [RETURN_TYPE] void [VARIABLES] Locale JAPANESE_IMPERIAL locale Pattern formatPattern parsePattern StringBuilder regex Matcher patternMatcher ConcurrentMap nameValues tzsCache String currentFormatField formatField id key nextFormatField pattern validTimeZoneChars long serialVersionUID int $anonymous0 field thisYear value Comparator IGNORE_CASE_COMPARATOR TimeZone timeZone tz Strategy[] strategies boolean SortedMap tzNames Strategy ABBREVIATED_YEAR_STRATEGY AM_PM_STRATEGY DAY_OF_MONTH_STRATEGY DAY_OF_WEEK_IN_MONTH_STRATEGY DAY_OF_WEEK_STRATEGY DAY_OF_YEAR_STRATEGY ERA_STRATEGY HOUR_OF_DAY_STRATEGY HOUR_STRATEGY LITERAL_YEAR_STRATEGY MILLISECOND_STRATEGY MINUTE_STRATEGY MODULO_HOUR_OF_DAY_STRATEGY MODULO_HOUR_STRATEGY NUMBER_MONTH_STRATEGY SECOND_STRATEGY TEXT_MONTH_STRATEGY WEEK_OF_MONTH_STRATEGY WEEK_OF_YEAR_STRATEGY currentStrategy nextStrategy List collector ", "output": "[PATCH] if (patternMatcher.regionStart() != patternMatcher.regionEnd()) { throw new IllegalArgumentException(\"Failed to parse \\\\\"\"+pattern+\"\\\\\" ; gave up at index\"+patternMatcher.regionStart()); } ", "bugid": "65"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Parsed dates should be equal expected:<null> but was:<Mon Mar 02 21:00:00 PST 1970> testLANG_831 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: None", "input": "[BUG] [BUGGY] boolean wasWhite= false; if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\\\\\s*+\"); } continue; } wasWhite= false; [FE] AssertionFailedError: Parsed dates should be equal expected:<null> but was:<Mon Mar 02 21:00:00 PST 1970> testLANG_831 [CONTEXT] private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { [BUGGY] boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\s*+\"); } continue; [BUGGY] } wasWhite= false; [CLASS] FastDateParser KeyValue 1 CopyQuotedStrategy TextStrategy NumberStrategy 2 TimeZoneStrategy 3 4 5 [METHOD] escapeRegex [RETURN_TYPE] StringBuilder StringBuilder regex String value boolean unquote [VARIABLES] Locale JAPANESE_IMPERIAL locale Pattern formatPattern parsePattern StringBuilder regex ConcurrentMap nameValues tzsCache String currentFormatField formatField id key nextFormatField pattern source validTimeZoneChars value long serialVersionUID int $anonymous0 field i offset thisYear value Comparator IGNORE_CASE_COMPARATOR TimeZone timeZone tz Strategy[] strategies boolean unquote wasWhite SortedMap tzNames char c Strategy ABBREVIATED_YEAR_STRATEGY AM_PM_STRATEGY DAY_OF_MONTH_STRATEGY DAY_OF_WEEK_IN_MONTH_STRATEGY DAY_OF_WEEK_STRATEGY DAY_OF_YEAR_STRATEGY ERA_STRATEGY HOUR_OF_DAY_STRATEGY HOUR_STRATEGY LITERAL_YEAR_STRATEGY MILLISECOND_STRATEGY MINUTE_STRATEGY MODULO_HOUR_OF_DAY_STRATEGY MODULO_HOUR_STRATEGY NUMBER_MONTH_STRATEGY SECOND_STRATEGY TEXT_MONTH_STRATEGY WEEK_OF_MONTH_STRATEGY WEEK_OF_YEAR_STRATEGY currentStrategy nextStrategy strategy ", "output": "[PATCH] ", "bugid": "66"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Message (bound must be positive) must contain 'start' testLANG807 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   } catch (IllegalArgumentException ex) { // distinguish from Random#nextInt message   final String msg = ex.getMessage();   assertTrue(\"Message (\" + msg + \") must contain 'start'\", msg.contains(\"start\"));   assertTrue(\"Message (\" + msg + \") must contain 'end'\", msg.contains(\"end\"));  }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: Message (bound must be positive) must contain 'start' testLANG807 [CONTEXT] if (chars != null) { end = chars.length; } else { if (!letters && !numbers) { end = Integer.MAX_VALUE; } else { end = 'z' + 1; start = ' '; } } [BUGGY] [BUGGY] } char[] buffer = new char[count]; int gap = end - start; while (count-- != 0) { char ch; if (chars == null) { ch = (char) (random.nextInt(gap) + start); } else { ch = chars[random.nextInt(gap) + start]; [CLASS] RandomStringUtils [METHOD] random [RETURN_TYPE] String int count int start int end boolean letters boolean numbers char[] chars Random random [VARIABLES] char ch boolean letters numbers Random RANDOM random int count end gap start char[] buffer chars ", "output": "[PATCH] } else { if (end <= start) { throw new IllegalArgumentException(\"Parameter end (\" + end +\") must be greater than start (\" + start +\")\"); } ", "bugid": "67"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testEquals . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertTrue(StringUtils.equals(null, null));  assertTrue(StringUtils.equals(fooCs, fooCs));  assertTrue(StringUtils.equals(fooCs, (CharSequence) new StringBuilder(FOO)));  assertTrue(StringUtils.equals(fooCs, (CharSequence) new String(new char[] { 'f', 'o', 'o' })));  assertTrue(StringUtils.equals(fooCs, (CharSequence) new CustomCharSequence(FOO)));", "input": "[BUG] [BUGGY] return cs1.equals(cs2); [FE] AssertionFailedError testEquals [CONTEXT] public static boolean equals(CharSequence cs1, CharSequence cs2) { if (cs1 == cs2) { return true; } if (cs1 == null || cs2 == null) { return false; } [BUGGY] return cs1.equals(cs2); [BUGGY] } [CLASS] StringUtils InitStripAccents [METHOD] equals [RETURN_TYPE] boolean CharSequence cs1 CharSequence cs2 [VARIABLES] Pattern WHITESPACE_BLOCK java6Pattern sunPattern boolean CharSequence cs1 cs2 Throwable java6Exception sunException Object java6NormalizerFormNFD String EMPTY input result str stripChars ts Method java6NormalizeMethod sunDecomposeMethod int INDEX_NOT_FOUND PAD_LIMIT end i start strLen strsLen ", "output": "[PATCH] if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); ", "bugid": "68"}, {"instruction": "The following code contains a buggy line with the following test error: NumberFormatException: 0Xfade is not a valid number testCreateNumber . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertEquals(\"createNumber(String) 8 failed\", Integer.valueOf(\"-12345\"), NumberUtils.createNumber(\"-12345\"));  assertTrue(\"createNumber(String) 9a failed\", 0xFADE == NumberUtils.createNumber(\"0xFADE\").intValue());  assertTrue(\"createNumber(String) 9b failed\", 0xFADE == NumberUtils.createNumber(\"0Xfade\").intValue());  assertTrue(\"createNumber(String) 10a failed\", -0xFADE == NumberUtils.createNumber(\"-0xFADE\").intValue());  assertTrue(\"createNumber(String) 10b failed\", -0xFADE == NumberUtils.createNumber(\"-0Xfade\").intValue());", "input": "[BUG] [BUGGY] if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { [FE] NumberFormatException: 0Xfade is not a valid number testCreateNumber [CONTEXT] if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { return null; } [BUGGY] if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { [BUGGY] return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { [CLASS] NumberUtils [METHOD] createNumber [RETURN_TYPE] Number String str [VARIABLES] Integer INTEGER_MINUS_ONE INTEGER_ONE INTEGER_ZERO Float FLOAT_MINUS_ONE FLOAT_ONE FLOAT_ZERO f boolean allZeros Byte BYTE_MINUS_ONE BYTE_ONE BYTE_ZERO Long LONG_MINUS_ONE LONG_ONE LONG_ZERO char lastChar NumberFormatException e nfe String dec exp mant numeric str Double DOUBLE_MINUS_ONE DOUBLE_ONE DOUBLE_ZERO d Short SHORT_MINUS_ONE SHORT_ONE SHORT_ZERO int decPos expPos ", "output": "[PATCH] if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) { ", "bugid": "69"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<AD AD AD AD 2003 [2003 03 20]03 January Jan 01 1 > but was:<AD AD AD AD 2003 [03 03 ]03 January Jan 01 1 > testFormat . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    sdf = new SimpleDateFormat(pattern);   // SDF bug fix starting with Java 7   assertEquals(sdf.format(date1).replaceAll(\"2003 03 03 03\", \"2003 2003 03 2003\"), fdf.format(date1));   assertEquals(sdf.format(date2).replaceAll(\"2003 03 03 03\", \"2003 2003 03 2003\"), fdf.format(date2));  } finally {", "input": "[BUG] [BUGGY] rule = selectNumberRule(Calendar.YEAR, tokenLen); } else { [FE] ComparisonFailure: expected:<AD AD AD AD 2003 [2003 03 20]03 January Jan 01 1 > but was:<AD AD AD AD 2003 [03 03 ]03 January Jan 01 1 > testFormat [CONTEXT] } Rule rule; char c = token.charAt(0); switch (c) { case 'G': rule = new TextField(Calendar.ERA, ERAs); break; case 'y': [BUGGY] if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); [BUGGY] } else { rule = TwoDigitYearField.INSTANCE; } break; case 'M': if (tokenLen >= 4) { rule = new TextField(Calendar.MONTH, months); } else if (tokenLen == 3) { rule = new TextField(Calendar.MONTH, shortMonths); [CLASS] FastDateFormat 1 CharacterLiteral StringLiteral TextField UnpaddedNumberField UnpaddedMonthField PaddedNumberField TwoDigitNumberField TwoDigitYearField TwoDigitMonthField TwelveHourField TwentyFourHourField TimeZoneNameRule TimeZoneNumberRule TimeZoneDisplayKey [METHOD] parsePattern [RETURN_TYPE] List [VARIABLES] Locale locale mLocale TimeZoneNumberRule INSTANCE_COLON INSTANCE_NO_COLON ConcurrentMap cTimeZoneDisplayCache TwoDigitYearField INSTANCE int[] indexRef String mDaylight mPattern mStandard mValue pattern prior sub token value String[] AmPmStrings ERAs mValues months shortMonths shortWeekdays values weekdays FormatCache cache long serialVersionUID int FULL LONG MEDIUM SHORT dateStyle field i len length mField mMaxLengthEstimate mSize mStyle size style timeStyle tokenLen Rule[] mRules TimeZone mTimeZone timeZone tz boolean colon daylight mColon NumberRule mRule rule char c mValue value TwoDigitMonthField INSTANCE UnpaddedMonthField INSTANCE DateFormatSymbols symbols List rules Rule rule ", "output": "[PATCH] if (tokenLen == 2) { } else { rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen); ", "bugid": "70"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: LANG-677 testIsSameLocalTime_Cal . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   cal3.set(Calendar.MILLISECOND, 0);  cal4.set(Calendar.MILLISECOND, 0);  assertFalse(\"LANG-677\", DateUtils.isSameLocalTime(cal3, cal4));    cal2.set(2004, 6, 9, 11, 45, 0);", "input": "[BUG] [BUGGY] cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && [FE] AssertionFailedError: LANG-677 testIsSameLocalTime_Cal [CONTEXT]  [BUGGY] cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && [BUGGY] cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass()); } [CLASS] DateUtils DateIterator [METHOD] isSameLocalTime [RETURN_TYPE] boolean Calendar cal1 Calendar cal2 [VARIABLES] TimeZone UTC_TIME_ZONE int[][] fields boolean long MILLIS_PER_DAY MILLIS_PER_HOUR MILLIS_PER_MINUTE MILLIS_PER_SECOND int MODIFY_CEILING MODIFY_ROUND MODIFY_TRUNCATE RANGE_MONTH_MONDAY RANGE_MONTH_SUNDAY RANGE_WEEK_CENTER RANGE_WEEK_MONDAY RANGE_WEEK_RELATIVE RANGE_WEEK_SUNDAY SEMI_MONTH Calendar cal1 cal2 endFinal spot startFinal ", "output": "[PATCH] cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) && ", "bugid": "71"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<-1073741824> but was:<-2147483648> testReducedFactory_int_int . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   // zero  f = Fraction.getReducedFraction(0, 1);  assertEquals(0, f.getNumerator());  assertEquals(1, f.getDenominator());  ", "input": "[BUG] [BUGGY] if (Math.abs(u) <= 1 || Math.abs(v) <= 1) { [FE] AssertionFailedError: expected:<-1073741824> but was:<-2147483648> testReducedFactory_int_int [CONTEXT] private static int greatestCommonDivisor(int u, int v) { [BUGGY] [BUGGY] if (Math.abs(u) <= 1 || Math.abs(v) <= 1) { return 1; } if (u>0) { u=-u; } if (v>0) { v=-v; }  [CLASS] Fraction [METHOD] greatestCommonDivisor [RETURN_TYPE] int int u int v [VARIABLES] Fraction FOUR_FIFTHS ONE ONE_FIFTH ONE_HALF ONE_QUARTER ONE_THIRD THREE_FIFTHS THREE_QUARTERS TWO_FIFTHS TWO_QUARTERS TWO_THIRDS ZERO f String str toProperString toString boolean long numeratorValue serialVersionUID int a1 a2 denom denom0 denom1 denom2 denominator gcd hashCode i k numer numer0 numer1 numer2 numerator pos power sign t u v whole wholeNumber ", "output": "[PATCH] if ((u == 0) || (v == 0)) { if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) { throw new ArithmeticException(\"overflow: gcd is 2^31\"); } return Math.abs(u) + Math.abs(v); } if (Math.abs(u) == 1 || Math.abs(v) == 1) { ", "bugid": "72"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: isNumber(String) LANG-664 failed testIsNumber . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   // LANG-664  val = \"1.1L\";  assertFalse(\"isNumber(String) LANG-664 failed\", NumberUtils.isNumber(val)); }", "input": "[BUG] [BUGGY] return foundDigit && !hasExp; [FE] AssertionFailedError: isNumber(String) LANG-664 failed testIsNumber [CONTEXT] if (chars[i] == 'l' || chars[i] == 'L') { [BUGGY] return foundDigit && !hasExp; [BUGGY] } [CLASS] NumberUtils [METHOD] isNumber [RETURN_TYPE] boolean String str [VARIABLES] Integer INTEGER_MINUS_ONE INTEGER_ONE INTEGER_ZERO Float FLOAT_MINUS_ONE FLOAT_ONE FLOAT_ZERO f boolean allowSigns foundDigit hasDecPoint hasExp Byte BYTE_MINUS_ONE BYTE_ONE BYTE_ZERO Long LONG_MINUS_ONE LONG_ONE LONG_ZERO String str Double DOUBLE_MINUS_ONE DOUBLE_ONE DOUBLE_ZERO d Short SHORT_MINUS_ONE SHORT_ONE SHORT_ZERO int i start sz char[] chars ", "output": "[PATCH] return foundDigit && !hasExp && !hasDecPoint; ", "bugid": "73"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<fredag, week [53]> but was:<fredag, week [01]> testLang645 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   FastDateFormat fdf = FastDateFormat.getInstance(\"EEEE', week 'ww\", locale);  assertEquals(\"fredag, week 53\", fdf.format(d)); }", "input": "[BUG] [BUGGY] Calendar c = new GregorianCalendar(mTimeZone); [FE] ComparisonFailure: expected:<fredag, week [53]> but was:<fredag, week [01]> testLang645 [CONTEXT] public String format(Date date) { [BUGGY] Calendar c = new GregorianCalendar(mTimeZone); [BUGGY] c.setTime(date); return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString(); } [CLASS] FastDateFormat CharacterLiteral StringLiteral TextField UnpaddedNumberField UnpaddedMonthField PaddedNumberField TwoDigitNumberField TwoDigitYearField TwoDigitMonthField TwelveHourField TwentyFourHourField TimeZoneNameRule TimeZoneNumberRule TimeZoneDisplayKey Pair [METHOD] format [RETURN_TYPE] String Date date [VARIABLES] Locale locale mLocale TimeZoneNumberRule INSTANCE_COLON INSTANCE_NO_COLON Calendar c TwoDigitYearField INSTANCE String cDefaultPattern mDaylight mPattern mStandard mValue pattern sub token value String[] AmPmStrings ERAs mValues months shortMonths shortWeekdays values weekdays long millis serialVersionUID int FULL LONG MEDIUM SHORT dateStyle field i len length mField mMaxLengthEstimate mSize mStyle padding size style timeStyle tokenLen Rule[] mRules Date date TimeZone mTimeZone timeZone tz boolean colon daylight inLiteral mColon mLocaleForced mTimeZoneForced timeZoneForced NumberRule mRule rule char c mValue peek value TwoDigitMonthField INSTANCE UnpaddedMonthField INSTANCE Object key mObj1 mObj2 obj obj1 obj2 Map cDateInstanceCache cDateTimeInstanceCache cInstanceCache cTimeInstanceCache cTimeZoneDisplayCache ", "output": "[PATCH] Calendar c = new GregorianCalendar(mTimeZone, mLocale); ", "bugid": "75"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: Failed to unescape numeric entities supplementary characters expected:<[ testSupplementaryUnescaping . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   String result = neu.translate(input);  assertEquals(\"Failed to unescape numeric entities supplementary characters\", expected, result); }", "input": "[BUG] [BUGGY] [FE] ComparisonFailure: Failed to unescape numeric entities supplementary characters expected:<[ testSupplementaryUnescaping [CONTEXT] try { if(isHex) { entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); } else { entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); } } catch(NumberFormatException nfe) { return 0; } [BUGGY] [BUGGY] out.write(entityValue); return 2 + (end - start) + (isHex ? 1 : 0) + 1; } return 0; } [CLASS] NumericEntityUnescaper [METHOD] translate [RETURN_TYPE] int CharSequence input int index Writer out [VARIABLES] boolean isHex CharSequence input char firstChar NumberFormatException nfe int end entityValue index start Writer out ", "output": "[PATCH] if(entityValue > 0xFFFF) { char[] chrs = Character.toChars(entityValue); out.write(chrs[0]); out.write(chrs[1]); } else { } ", "bugid": "76"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<0> but was:<00> testJavaVersionAsInt . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] static float toJavaVersionInt(String version) { [FE] AssertionFailedError: expected:<0> but was:<00> testJavaVersionAsInt [CONTEXT] [BUGGY] static float toJavaVersionInt(String version) { [BUGGY] return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE)); } [CLASS] SystemUtils [METHOD] toJavaVersionInt [RETURN_TYPE] float String version [VARIABLES] boolean IS_JAVA_1_1 IS_JAVA_1_2 IS_JAVA_1_3 IS_JAVA_1_4 IS_JAVA_1_5 IS_JAVA_1_6 IS_JAVA_1_7 IS_OS_AIX IS_OS_HP_UX IS_OS_IRIX IS_OS_LINUX IS_OS_MAC IS_OS_MAC_OSX IS_OS_OS2 IS_OS_SOLARIS IS_OS_SUN_OS IS_OS_UNIX IS_OS_WINDOWS IS_OS_WINDOWS_2000 IS_OS_WINDOWS_7 IS_OS_WINDOWS_95 IS_OS_WINDOWS_98 IS_OS_WINDOWS_ME IS_OS_WINDOWS_NT IS_OS_WINDOWS_VISTA IS_OS_WINDOWS_XP String AWT_TOOLKIT FILE_ENCODING FILE_SEPARATOR JAVA_AWT_FONTS JAVA_AWT_GRAPHICSENV JAVA_AWT_HEADLESS JAVA_AWT_PRINTERJOB JAVA_CLASS_PATH JAVA_CLASS_VERSION JAVA_COMPILER JAVA_ENDORSED_DIRS JAVA_EXT_DIRS JAVA_HOME JAVA_HOME_KEY JAVA_IO_TMPDIR JAVA_IO_TMPDIR_KEY JAVA_LIBRARY_PATH JAVA_RUNTIME_NAME JAVA_RUNTIME_VERSION JAVA_SPECIFICATION_NAME JAVA_SPECIFICATION_VENDOR JAVA_SPECIFICATION_VERSION JAVA_UTIL_PREFS_PREFERENCES_FACTORY JAVA_VENDOR JAVA_VENDOR_URL JAVA_VERSION JAVA_VERSION_TRIMMED JAVA_VM_INFO JAVA_VM_NAME JAVA_VM_SPECIFICATION_NAME JAVA_VM_SPECIFICATION_VENDOR JAVA_VM_SPECIFICATION_VERSION JAVA_VM_VENDOR JAVA_VM_VERSION LINE_SEPARATOR OS_ARCH OS_NAME OS_NAME_WINDOWS_PREFIX OS_VERSION PATH_SEPARATOR USER_COUNTRY USER_DIR USER_DIR_KEY USER_HOME USER_HOME_KEY USER_LANGUAGE USER_NAME USER_TIMEZONE osName osNamePrefix osVersion osVersionPrefix property version versionPrefix float JAVA_VERSION_FLOAT requiredVersion int JAVA_VERSION_INT JAVA_VERSION_TRIM_SIZE i requiredVersion ", "output": "[PATCH] static int toJavaVersionInt(String version) { ", "bugid": "77"}, {"instruction": "The following code contains a buggy line with the following test error: null  testToClass_object . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:     ClassUtils.toClass(new Object[] { \"Test\", 1, 99d })));  assertTrue(Arrays.equals(new Class[] { String.class, null, Double.class },    ClassUtils.toClass(new Object[] { \"Test\", null, 99d }))); }", "input": "[BUG] [BUGGY] classes[i] = array[i].getClass(); [FE] null  testToClass_object [CONTEXT] public static Class<?>[] toClass(Object[] array) { if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { [BUGGY] classes[i] = array[i].getClass(); [BUGGY] } return classes; } [CLASS] ClassUtils [METHOD] toClass [RETURN_TYPE] Class[] Object[] array [VARIABLES] Class[] classes boolean char INNER_CLASS_SEPARATOR_CHAR PACKAGE_SEPARATOR_CHAR String INNER_CLASS_SEPARATOR PACKAGE_SEPARATOR abbreviation className clsName methodName out primitive valueIfNull Map abbreviationMap primitiveWrapperMap reverseAbbreviationMap wrapperPrimitiveMap Object[] array int i ", "output": "[PATCH] classes[i] = array[i] == null ? null : array[i].getClass(); ", "bugid": "78"}, {"instruction": "The following code contains a buggy line with the following test error: ArrayStoreException testJira567 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   try {   // Invalid - can't store Long in Integer array  n = ArrayUtils.addAll(new Integer[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)});  fail(\"Should have generated IllegalArgumentException\");  } catch (IllegalArgumentException expected) {", "input": "[BUG] [BUGGY] [FE] ArrayStoreException testJira567 [CONTEXT] public static <T> T[] addAll(T[] array1, T... array2) { if (array1 == null) { return clone(array2); } else if (array2 == null) { return clone(array1); } final Class<?> type1 = array1.getClass().getComponentType(); T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length); System.arraycopy(array1, 0, joinedArray, 0, array1.length); [BUGGY] [BUGGY] System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); return joinedArray; } [CLASS] ArrayUtils [METHOD] addAll [RETURN_TYPE] <T> T[] array1 array2 [VARIABLES] Class[] EMPTY_CLASS_ARRAY long[] EMPTY_LONG_ARRAY array array1 array2 result subarray short[] EMPTY_SHORT_ARRAY array array1 array2 result subarray Character[] EMPTY_CHARACTER_OBJECT_ARRAY array result Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY array result int[] EMPTY_INT_ARRAY array array1 array2 result subarray String[] EMPTY_STRING_ARRAY Integer[] EMPTY_INTEGER_OBJECT_ARRAY array result int INDEX_NOT_FOUND endIndexExclusive i j newSize startIndex startIndexInclusive tmp valueForNull valueToFind float[] EMPTY_FLOAT_ARRAY array array1 array2 result subarray char[] EMPTY_CHAR_ARRAY array array1 array2 result subarray Short[] EMPTY_SHORT_OBJECT_ARRAY array result byte[] EMPTY_BYTE_ARRAY array array1 array2 result subarray Double[] EMPTY_DOUBLE_OBJECT_ARRAY array result boolean double[] EMPTY_DOUBLE_ARRAY array array1 array2 result subarray Byte[] EMPTY_BYTE_OBJECT_ARRAY array result Float[] EMPTY_FLOAT_OBJECT_ARRAY array result T[] array1 array2 joinedArray Class type1 boolean[] EMPTY_BOOLEAN_ARRAY array array1 array2 result subarray Object[] EMPTY_OBJECT_ARRAY array array1 array2 entry Long[] EMPTY_LONG_OBJECT_ARRAY array result ", "output": "[PATCH] try { } catch (ArrayStoreException ase) { final Class<?> type2 = array2.getClass().getComponentType(); if (!type1.isAssignableFrom(type2)){ throw new IllegalArgumentException(\"Cannot store\"+type2.getName()+\" in an array of\"+type1.getName()); } throw ase; } ", "bugid": "79"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: dateTime expected:<2009-10-16T[16]:42:16000Z> but was:<2009-10-16T[08]:42:16000Z> testLang538 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   FastDateFormat format = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\", TimeZone.getTimeZone(\"GMT\"));  assertEquals(\"dateTime\", dateTime, format.format(cal)); }", "input": "[BUG] [BUGGY] [FE] ComparisonFailure: dateTime expected:<2009-10-16T[16]:42:16000Z> but was:<2009-10-16T[08]:42:16000Z> testLang538 [CONTEXT] public StringBuffer format(Calendar calendar, StringBuffer buf) { if (mTimeZoneForced) { [BUGGY] [BUGGY] calendar = (Calendar) calendar.clone(); calendar.setTimeZone(mTimeZone); } return applyRules(calendar, buf); } [CLASS] FastDateFormat CharacterLiteral StringLiteral TextField UnpaddedNumberField UnpaddedMonthField PaddedNumberField TwoDigitNumberField TwoDigitYearField TwoDigitMonthField TwelveHourField TwentyFourHourField TimeZoneNameRule TimeZoneNumberRule TimeZoneDisplayKey Pair [METHOD] format [RETURN_TYPE] StringBuffer Calendar calendar StringBuffer buf [VARIABLES] Locale locale mLocale TimeZoneNumberRule INSTANCE_COLON INSTANCE_NO_COLON Calendar calendar TwoDigitYearField INSTANCE String cDefaultPattern mDaylight mPattern mStandard mValue pattern sub token value String[] AmPmStrings ERAs mValues months shortMonths shortWeekdays values weekdays long millis serialVersionUID int FULL LONG MEDIUM SHORT dateStyle field i len length mField mMaxLengthEstimate mSize mStyle padding size style timeStyle tokenLen Rule[] mRules TimeZone mTimeZone timeZone tz StringBuffer buf boolean colon daylight inLiteral mColon mLocaleForced mTimeZoneForced timeZoneForced NumberRule mRule rule char c mValue peek value TwoDigitMonthField INSTANCE UnpaddedMonthField INSTANCE Object key mObj1 mObj2 obj obj1 obj2 Map cDateInstanceCache cDateTimeInstanceCache cInstanceCache cTimeInstanceCache cTimeZoneDisplayCache ", "output": "[PATCH] calendar.getTime(); ", "bugid": "80"}, {"instruction": "The following code contains a buggy line with the following test error: null  testReplace_StringStringArrayStringArray . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   // Test null safety inside arrays - LANG-552  assertEquals(StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{null}),\"aba\");  assertEquals(StringUtils.replaceEach(\"aba\", new String[]{\"a\", \"b\"}, new String[]{\"c\", null}),\"cbc\"); }", "input": "[BUG] [BUGGY] [FE] null  testReplace_StringStringArrayStringArray [CONTEXT] return text; } int start = 0; int increase = 0; for (int i = 0; i < searchList.length; i++) { [BUGGY] [BUGGY] int greater = replacementList[i].length() - searchList[i].length(); if (greater > 0) { increase += 3 * greater; } } increase = Math.min(increase, text.length() / 5); StringBuilder buf = new StringBuilder(text.length() + increase); while (textIndex != -1) { [CLASS] StringUtils [METHOD] replaceEach [RETURN_TYPE] String String text String[] searchList String[] replacementList boolean repeat int timeToLive [VARIABLES] String EMPTY close decomposed input invalidChars open remove replacement result search searchChars searchStr searchString separator separatorChars str str1 str2 stripChars tag text ts validChars String[] replacementList searchList boolean repeat boolean[] noMoreMatchesForReplIndex StringBuilder buf int INDEX_NOT_FOUND PAD_LIMIT beg bufSize closeLen count currentType end endIndex found greater i increase index j len max newTokenStart numberOfSubstrings openLen ordinal pos replLength replaceIndex replacementLength ret searchLength separatorLength sizePlus1 start startIndex startPos strLen strSize strsLen sz tempIndex textIndex textLength timeToLive tmp tokenStart type validSize ", "output": "[PATCH] if (searchList[i] == null || replacementList[i] == null) { continue; } ", "bugid": "81"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: en: 0 testContainsIgnoreCase_LocaleIndependence . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:     }    for (int j = 0; j < fdata.length; j++) { assertFalse(Locale.getDefault() + \": \" + j + \" \" + fdata[j][0] + \" \" + fdata[j][1], StringUtils   .containsIgnoreCase(fdata[j][0], fdata[j][1]));    }", "input": "[BUG] [BUGGY] return contains(str.toUpperCase(), searchStr.toUpperCase()); [FE] AssertionFailedError: en: 0 testContainsIgnoreCase_LocaleIndependence [CONTEXT] public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return false; } [BUGGY] return contains(str.toUpperCase(), searchStr.toUpperCase()); [BUGGY] } [CLASS] StringUtils [METHOD] containsIgnoreCase [RETURN_TYPE] boolean String str String searchStr [VARIABLES] int INDEX_NOT_FOUND PAD_LIMIT end found i index ordinal start startPos strLen strsLen String EMPTY searchStr str str1 str2 stripChars ts boolean ", "output": "[PATCH] int len = searchStr.length(); int max = str.length() - len; for (int i = 0; i <= max; i++) { if (str.regionMatches(true, i, searchStr, 0, len)) { return true; } } return false; ", "bugid": "82"}, {"instruction": "The following code contains a buggy line with the following test error: OutOfMemoryError: Java heap space testEscapedQuote_LANG_477 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void testEscapedQuote_LANG_477() {  String pattern = \"it''s a {0,lower} 'test'!\";  ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry);  assertEquals(\"it's a dummy test!\", emf.format(new Object[] {\"DUMMY\"})); }", "input": "[BUG] [BUGGY] [FE] OutOfMemoryError: Java heap space testEscapedQuote_LANG_477 [CONTEXT] StringBuffer appendTo, boolean escapingOn) { int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { [BUGGY] [BUGGY] return appendTo == null ? null : appendTo.append(QUOTE); } int lastHold = start; for (int i = pos.getIndex(); i < pattern.length(); i++) { if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { appendTo.append(c, lastHold, pos.getIndex() - lastHold).append( QUOTE); pos.setIndex(i + ESCAPED_QUOTE.length()); lastHold = pos.getIndex(); continue; } [CLASS] ExtendedMessageFormat [METHOD] appendQuotedString [RETURN_TYPE] StringBuffer String pattern ParsePosition pos StringBuffer appendTo boolean escapingOn [VARIABLES] StringBuffer appendTo boolean escapingOn char END_FE QUOTE START_FE START_FMT c String DUMMY_PATTERN ESCAPED_QUOTE args customPattern desc formatDescription name pattern toPattern Map registry long serialVersionUID int i lastHold start ParsePosition pos char[] c ", "output": "[PATCH] next(pos); ", "bugid": "84"}, {"instruction": "The following code contains a buggy line with the following test error: StringIndexOutOfBoundsException: String index out of range: 0 testLang457 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   for(int i=0; i<badInputs.length; i++) {   try {    NumberUtils.createNumber(badInputs[i]);    fail(\"NumberFormatException was expected for \" + badInputs[i]);   } catch (NumberFormatException e) {", "input": "[BUG] [BUGGY] [FE] StringIndexOutOfBoundsException: String index out of range: 0 testLang457 [CONTEXT] public static Number createNumber(String val) throws NumberFormatException { if (val == null) { return null; } if (val.length() == 0) { throw new NumberFormatException(\"\\\"\\\" is not a valid number.\"); } [BUGGY] [BUGGY] if (val.startsWith(\"--\")) { return null; } if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) { return createInteger(val); } char lastChar = val.charAt(val.length() - 1); [CLASS] NumberUtils [METHOD] createNumber [RETURN_TYPE] Number String val [VARIABLES] Float f boolean allZeros char lastChar NumberFormatException e nfe String dec exp mant numeric val Double d int decPos expPos ", "output": "[PATCH] if (val.length() == 1 && !Character.isDigit(val.charAt(0))) { throw new NumberFormatException(val +\" is not a valid number.\"); } ", "bugid": "85"}, {"instruction": "The following code contains a buggy line with the following test error: StringIndexOutOfBoundsException: String index out of range testAbbreviate . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   // check null and empty are returned respectively  assertNull(WordUtils.abbreviate(null, 1,-1,\"\"));  assertEquals(StringUtils.EMPTY, WordUtils.abbreviate(\"\", 1,-1,\"\"));  // test upper limit", "input": "[BUG] [BUGGY] [FE] StringIndexOutOfBoundsException: String index out of range testAbbreviate [CONTEXT]   if (upper == -1 || upper > str.length()) {  upper = str.length(); }   [BUGGY] if (upper < lower) { upper = lower; }  [BUGGY] StringBuffer result = new StringBuffer(); [CLASS] WordUtils [METHOD] abbreviate [RETURN_TYPE] String String str int lower int upper String appendToEnd [VARIABLES] int index lower upper ", "output": "[PATCH] if (lower > str.length()) { lower = str.length(); } ", "bugid": "86"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testBigDecimal . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   BigDecimal o2 = new BigDecimal(\"2.00\");  assertTrue(new EqualsBuilder().append(o1, o1).isEquals());  assertTrue(new EqualsBuilder().append(o1, o2).isEquals()); }", "input": "[BUG] [BUGGY] isEquals = lhs.equals(rhs);[FE] AssertionFailedError testBigDecimal [CONTEXT] } if (lhs == rhs) { return this; } if (lhs == null || rhs == null) { this.setEquals(false); return this; } Class lhsClass = lhs.getClass(); if (!lhsClass.isArray()) { [BUGGY]  isEquals = lhs.equals(rhs); [BUGGY] } else if (lhs.getClass() != rhs.getClass()) { this.setEquals(false); }  else if (lhs instanceof long[]) { append((long[]) lhs, (long[]) rhs); } else if (lhs instanceof int[]) { [CLASS] EqualsBuilder [METHOD] append [RETURN_TYPE] EqualsBuilder Object lhs Object rhs [VARIABLES] Object lhs rhs Class lhsClass boolean isEquals superEquals testTransients useTransients ", "output": "[PATCH] if (lhs instanceof java.math.BigDecimal) { isEquals = (((java.math.BigDecimal)lhs).compareTo(rhs) == 0); } else { isEquals = lhs.equals(rhs); } ", "bugid": "87"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<1> but was:<100> testReduce . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   result = f.reduce();  assertEquals(0, result.getNumerator());  assertEquals(1, result.getDenominator());  assertSame(result, Fraction.ZERO); }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: expected:<1> but was:<100> testReduce [CONTEXT] public Fraction reduce() { [BUGGY] [BUGGY] int gcd = greatestCommonDivisor(Math.abs(numerator), denominator); if (gcd == 1) { return this; } return Fraction.getFraction(numerator / gcd, denominator / gcd); } [CLASS] Fraction [METHOD] reduce [RETURN_TYPE] Fraction [VARIABLES] Fraction FOUR_FIFTHS ONE ONE_FIFTH ONE_HALF ONE_QUARTER ONE_THIRD THREE_FIFTHS THREE_QUARTERS TWO_FIFTHS TWO_QUARTERS TWO_THIRDS ZERO String str toProperString toString boolean long numeratorValue serialVersionUID int a1 a2 denom denom0 denom1 denom2 denominator gcd hashCode i numer numer0 numer1 numer2 numerator pos sign whole wholeNumber ", "output": "[PATCH] if (numerator == 0) { return equals(ZERO) ? this : ZERO; } ", "bugid": "88"}, {"instruction": "The following code contains a buggy line with the following test error: StringIndexOutOfBoundsException: String index out of range: 3 test_toBoolean_String . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertEquals(true, BooleanUtils.toBoolean(\"YES\"));  assertEquals(false, BooleanUtils.toBoolean(\"yes?\"));  assertEquals(false, BooleanUtils.toBoolean(\"tru\")); }", "input": "[BUG] [BUGGY] [FE] StringIndexOutOfBoundsException: String index out of range: 3 test_toBoolean_String [CONTEXT] if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } [BUGGY] [BUGGY] } case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return [CLASS] BooleanUtils [METHOD] toBoolean [RETURN_TYPE] boolean String str [VARIABLES] boolean char ch ch0 ch1 String str ", "output": "[PATCH] return false; ", "bugid": "89"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<ipt>alert( testEscapeJavaScript . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:     assertEquals(\"He didn\\\\'t say, \\\\\\\"stop!\\\\\\\"\", StringEscapeUtils.escapeJavaScript(\"He didn't say, \\\"stop!\\\"\"));  assertEquals(\"document.getElementById(\\\\\\\"test\\\\\\\").value = \\\\'<script>alert(\\\\'aaa\\\\');<\\\\/script>\\\\';\", StringEscapeUtils.escapeJavaScript(\"document.getElementById(\\\"test\\\").value = '<script>alert('aaa');</script>';\")); }", "input": "[BUG] [BUGGY] [FE] ComparisonFailure: expected:<ipt>alert( testEscapeJavaScript [CONTEXT] out.write('\\''); break; case '\"': out.write('\\\\'); out.write('\"'); break; case '\\\\': out.write('\\\\'); out.write('\\\\'); break; [BUGGY] [BUGGY] default : out.write(ch); break; } } [CLASS] StringEscapeUtils [METHOD] escapeJavaStyleString [RETURN_TYPE] void Writer out String str boolean escapeSingleQuote [VARIABLES] boolean escapeSingleQuote char ch String str Writer out int i sz ", "output": "[PATCH] case '/': out.write('\\\\'); out.write('/'); break; ", "bugid": "90"}, {"instruction": "The following code contains a buggy line with the following test error: IllegalArgumentException: Invalid locale format: fr__POSIX testLang328 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  }", "input": "[BUG] [BUGGY] [FE] IllegalArgumentException: Invalid locale format: fr__POSIX testLang328 [CONTEXT] if (len == 2) { return new Locale(str,\"\"); } else { if (str.charAt(2) != '_') { throw new IllegalArgumentException(\"Invalid locale format:\" + str); } char ch3 = str.charAt(3); [BUGGY] [BUGGY] char ch4 = str.charAt(4); if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') { throw new IllegalArgumentException(\"Invalid locale format:\" + str); } if (len == 5) { return new Locale(str.substring(0, 2), str.substring(3, 5)); } else { if (str.charAt(5) != '_') { throw new IllegalArgumentException(\"Invalid locale format:\" + str); } return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [CLASS] LocaleUtils [METHOD] toLocale [RETURN_TYPE] Locale String str [VARIABLES] Set cAvailableLocaleSet boolean char ch0 ch1 ch3 ch4 List cAvailableLocaleList String str Map cCountriesByLanguage cLanguagesByCountry int len ", "output": "[PATCH] if (ch3 == '_') { return new Locale(str.substring(0, 2),\"\", str.substring(4));", "bugid": "91"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testLang315 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   watch.stop();  long totalTime = watch.getTime();  assertTrue( suspendTime == totalTime ); }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError testLang315 [CONTEXT] if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(\"\"); } [BUGGY]  stopTime = System.currentTimeMillis(); [BUGGY]  this.runningState = STATE_STOPPED; } [CLASS] StopWatch [METHOD] stop [RETURN_TYPE] void [VARIABLES] int STATE_RUNNING STATE_SPLIT STATE_STOPPED STATE_SUSPENDED STATE_UNSPLIT STATE_UNSTARTED runningState splitState long startTime stopTime  ", "output": "[PATCH] if(this.runningState == STATE_RUNNING) { stopTime = System.currentTimeMillis(); } ", "bugid": "92"}, {"instruction": "The following code contains a buggy line with the following test error: null  testAvailableLocaleSet . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: None", "input": "[BUG] [BUGGY] return cAvailableLocaleSet.contains(locale); [FE] null  testAvailableLocaleSet [CONTEXT] public static boolean isAvailableLocale(Locale locale) { [BUGGY] return cAvailableLocaleSet.contains(locale); [BUGGY] } [CLASS] LocaleUtils [METHOD] isAvailableLocale [RETURN_TYPE] boolean Locale locale [VARIABLES] Locale locale List cAvailableLocaleList list Set cAvailableLocaleSet set boolean Map cCountriesByLanguage cLanguagesByCountry ", "output": "[PATCH] return availableLocaleList().contains(locale); ", "bugid": "93"}, {"instruction": "The following code contains a buggy line with the following test error: NumberFormatException: 1l is not a valid number testLang300 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   NumberUtils.createNumber(\"-1l\");  NumberUtils.createNumber(\"01l\");  NumberUtils.createNumber(\"1l\"); }", "input": "[BUG] [BUGGY] && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { [FE] NumberFormatException: 1l is not a valid number testLang300 [CONTEXT] exp = null; } String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null [BUGGY] && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { [BUGGY] try { return createLong(numeric); } catch (NumberFormatException nfe) { } return createBigInteger(numeric); } throw new NumberFormatException(str +\" is not a valid number.\"); [CLASS] NumberUtils [METHOD] createNumber [RETURN_TYPE] Number String str [VARIABLES] Integer INTEGER_MINUS_ONE INTEGER_ONE INTEGER_ZERO Float FLOAT_MINUS_ONE FLOAT_ONE FLOAT_ZERO f boolean allZeros Byte BYTE_MINUS_ONE BYTE_ONE BYTE_ZERO Long LONG_MINUS_ONE LONG_ONE LONG_ZERO char lastChar NumberFormatException e nfe String dec exp mant numeric str Double DOUBLE_MINUS_ONE DOUBLE_ONE DOUBLE_ZERO d Short SHORT_MINUS_ONE SHORT_ONE SHORT_ZERO int decPos expPos ", "output": "[PATCH] && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { ", "bugid": "94"}, {"instruction": "The following code contains a buggy line with the following test error:  testLang299 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void testLang299() {  StrBuilder sb = new StrBuilder(1);  sb.appendFixedWidthPadRight(\"foo\", 1, '-');  assertEquals(\"f\", sb.toString()); }", "input": "[BUG] [BUGGY] str.getChars(0, strLen, buffer, size); [FE]  testLang299 [CONTEXT] int strLen = str.length(); if (strLen >= width) { [BUGGY] str.getChars(0, strLen, buffer, size);   [CLASS] StrBuilder  [METHOD] appendFixedWidthPadRight [VARIABLES]", "output": "[PATCH] str.getChars(0, width, buffer, size); ", "bugid": "95"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<-1> but was:<6> testIndexOfLang294 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   StrBuilder sb = new StrBuilder(\"onetwothree\");  sb.deleteFirst(\"three\");  assertEquals(-1, sb.indexOf(\"three\")); }", "input": "[BUG] [BUGGY] int len = thisBuf.length - strLen; [FE] AssertionFailedError: expected:<-1> but was:<6> testIndexOfLang294 [CONTEXT] if (strLen == 1) { return indexOf(str.charAt(0), startIndex); } if (strLen == 0) { return startIndex; } if (strLen > size) { return -1; } char[] thisBuf = buffer; [BUGGY] int len = thisBuf.length - strLen; [BUGGY] outer: for (int i = startIndex; i < len; i++) { for (int j = 0; j < strLen; j++) { if (str.charAt(j) != thisBuf[i + j]) { continue outer; } } return i; } return -1; [CLASS] StrBuilder StrBuilderTokenizer StrBuilderReader StrBuilderWriter [METHOD] indexOf [RETURN_TYPE] int String str int startIndex [VARIABLES] String insertStr newLine nullText replaceStr searchStr separator str boolean int CAPACITY capacity destinationIndex endIndex from half i index initialCapacity insertLen j leftIdx len length mark newEnd newSize offset oldEnd padLen pos removeLen replaceCount replaceLen rightIdx searchLen size start startIndex strLen to value width long serialVersionUID value char[] buf buffer chars destination old thisBuf ", "output": "[PATCH] int len = size - strLen + 1; ", "bugid": "96"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<[Missing required options: ]fx> but was:<[]fx> testMissingOptionsException . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    fail(\"Expected MissingOptionException to be thrown\");  } catch (MissingOptionException e) {   assertEquals(\"Missing required options: fx\", e.getMessage());  } }", "input": "[BUG] [BUGGY] StringBuffer buff = new StringBuffer(); [FE] ComparisonFailure: expected:<[Missing required options: ]fx> but was:<[]fx> testMissingOptionsException [CONTEXT] private void checkRequiredOptions() throws MissingOptionException {  if (requiredOptions.size() > 0) { Iterator iter = requiredOptions.iterator(); [BUGGY] StringBuffer buff = new StringBuffer(); [BUGGY]  while (iter.hasNext()) { buff.append(iter.next()); } throw new MissingOptionException(buff.toString()); } [CLASS] Parser [METHOD] checkRequiredOptions [RETURN_TYPE] void [VARIABLES] Iterator iter Options options opts CommandLine cmd List requiredOptions tokenList StringBuffer buff boolean ", "output": "[PATCH] StringBuffer buff = new StringBuffer(\"Missing required option\"); buff.append(requiredOptions.size() == 1 ?\"\" :\"s\"); buff.append(\":\"); ", "bugid": "97"}, {"instruction": "The following code contains a buggy line with the following test error: null  testStripLeadingHyphens . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertEquals(\"f\", Util.stripLeadingHyphens(\"-f\"));  assertEquals(\"foo\", Util.stripLeadingHyphens(\"--foo\"));  assertNull(Util.stripLeadingHyphens(null)); }", "input": "[BUG] [BUGGY] [FE] null  testStripLeadingHyphens [CONTEXT] static String stripLeadingHyphens(String str) { [BUGGY] [BUGGY] if (str.startsWith(\"--\")) { return str.substring(2, str.length()); } else if (str.startsWith(\"-\")) { return str.substring(1, str.length()); } return str; } [CLASS] Util [METHOD] stripLeadingHyphens [RETURN_TYPE] String String str [VARIABLES] boolean String str ", "output": "[PATCH] if (str == null) { return null; } ", "bugid": "98"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: single line padded text 2 expected:<TE[-DATE] where DATE[ testPrintWrapped . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    {   StringBuffer sb = new StringBuffer();   HelpFormatter hf = new HelpFormatter();   String text = \"This is a test.\";", "input": "[BUG] [BUGGY] pos = findWrapPos(text, width, nextLineTabStop); [FE] ComparisonFailure: single line padded text 2 expected:<TE[-DATE] where DATE[ testPrintWrapped [CONTEXT] while (true) { text = padding + text.substring(pos).trim(); [BUGGY] pos = findWrapPos(text, width, nextLineTabStop); [BUGGY] if (pos == -1) { sb.append(text); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } [CLASS] HelpFormatter OptionComparator [METHOD] renderWrappedText [RETURN_TYPE] StringBuffer StringBuffer sb int width int nextLineTabStop String text [VARIABLES] StringBuffer sb String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text boolean int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos width x ", "output": "[PATCH] pos = findWrapPos(text, width, 0); ", "bugid": "99"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:< required options: f[, ]x> but was:< required options: f[]x> testMissingOptionsException . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    fail(\"Expected MissingOptionException to be thrown\");  } catch (MissingOptionException e) {   assertEquals(\"Missing required options: f, x\", e.getMessage());  } }", "input": "[BUG] [BUGGY] throw new MissingOptionException(buff.toString()); [FE] ComparisonFailure: expected:< required options: f[, ]x> but was:< required options: f[]x> testMissingOptionsException [CONTEXT] Iterator iter = getRequiredOptions().iterator(); StringBuffer buff = new StringBuffer(\"Missing required option\"); buff.append(getRequiredOptions().size() == 1 ?\"\" :\"s\"); buff.append(\":\");  while (iter.hasNext()) { buff.append(iter.next()); } [BUGGY] throw new MissingOptionException(buff.toString()); [BUGGY] } } [CLASS] Parser [METHOD] checkRequiredOptions [RETURN_TYPE] void [VARIABLES] Iterator iter Options options opts CommandLine cmd List requiredOptions tokenList StringBuffer buff boolean ", "output": "[PATCH] buff.append(\",\"); throw new MissingOptionException(buff.substring(0, buff.length() - 2)); ", "bugid": "100"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<usage: app -f[] testPrintOptionWithEmptyArgNameUsage . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   formatter.printUsage(new PrintWriter(out), 80, \"app\", options);  assertEquals(\"usage: app -f\" + EOL, out.toString()); }", "input": "[BUG] [BUGGY] if (option.hasArg() && (option.getArgName() != null)) { [FE] ComparisonFailure: expected:<usage: app -f[] testPrintOptionWithEmptyArgNameUsage [CONTEXT] if (option.getOpt() != null) { buff.append(\"-\").append(option.getOpt()); } else { buff.append(\"--\").append(option.getLongOpt()); }  [BUGGY] if (option.hasArg() && (option.getArgName() != null)) { [BUGGY] buff.append(\" <\").append(option.getArgName()).append(\">\"); } if (!required) { buff.append(\"]\"); } } [CLASS] HelpFormatter OptionComparator [METHOD] appendOption [RETURN_TYPE] void StringBuffer buff Option option final boolean required [VARIABLES] StringBuffer buff Option option String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix boolean required int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width Comparator comparator optionComparator ", "output": "[PATCH] if (option.hasArg() && option.hasArgName()) { ", "bugid": "101"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<[]bar> but was:<[=]bar> testShortWithEqual . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   CommandLine cl = parser.parse(options, args);  assertEquals(\"bar\", cl.getOptionValue(\"foo\")); }", "input": "[BUG] [BUGGY] if (options.hasOption(arg.substring(0, 2))) { [FE] ComparisonFailure: expected:<[]bar> but was:<[=]bar> testShortWithEqual [CONTEXT] if (options.hasOption(opt)) { tokens.add(arg); } else { [BUGGY] if (options.hasOption(arg.substring(0, 2))) { [BUGGY] tokens.add(arg.substring(0, 2)); tokens.add(arg.substring(2)); } else { eatTheRest = stopAtNonOption; tokens.add(arg); [CLASS] GnuParser [METHOD] flatten [RETURN_TYPE] String[] Options options String[] arguments boolean stopAtNonOption [VARIABLES] Options options boolean eatTheRest stopAtNonOption List tokens String[] arguments String arg opt int i ", "output": "[PATCH] else if (options.hasOption(arg.substring(0, 2))) { ", "bugid": "102"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testStopBursting . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertFalse( \"Confirm -c is not set\", cl.hasOption(\"c\") );  assertTrue( \"Confirm  1 extra arg: \" + cl.getArgList().size(), cl.getArgList().size() == 1);  assertTrue(cl.getArgList().contains(\"zc\")); }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError testStopBursting [CONTEXT] else if (stopAtNonOption) {  process(token.substring(i)); [BUGGY]  [BUGGY] } else { tokens.add(token); break; } [CLASS] PosixParser [METHOD] burstToken [RETURN_TYPE] void String token boolean stopAtNonOption [VARIABLES] Options options List tokens Option currentOption boolean eatTheRest stopAtNonOption String ch token int i ", "output": "[PATCH] break; ", "bugid": "103"}, {"instruction": "The following code contains a buggy line with the following test error: IllegalStateException: Total width is less than the width of the argument and indent - no room for the description testLongLineChunkingIndentIgnored . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   HelpFormatter formatter = new HelpFormatter();  StringWriter sw = new StringWriter();  formatter.printHelp(new PrintWriter(sw), 22, this.getClass().getName(), \"Header\", options, 0, 5, \"Footer\");  String expected = \"usage:\\n\" +    \"    org.apache.comm\\n\" +", "input": "[BUG] [BUGGY] throw new IllegalStateException(\"Total width is less than the width of the argument and indent\" +\"- no room for the description\"); [FE] IllegalStateException: Total width is less than the width of the argument and indent - no room for the description testLongLineChunkingIndentIgnored [CONTEXT] if (nextLineTabStop >= width) { [BUGGY] throw new IllegalStateException(\"Total width is less than the width of the argument and indent\" +\"- no room for the description\"); [BUGGY] } [CLASS] HelpFormatter OptionComparator [METHOD] renderWrappedText [RETURN_TYPE] StringBuffer StringBuffer sb int width int nextLineTabStop String text [VARIABLES] StringBuffer sb String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text boolean int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos width x Comparator comparator optionComparator ", "output": "[PATCH] nextLineTabStop = width - 1; ", "bugid": "104"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: Long arguments did not split as expected expected:< testLongLineChunkingIndentIgnored . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:     \" Long.\\n\" +    \"Footer\\n\";  assertEquals( \"Long arguments did not split as expected\", expected, sw.toString() ); }", "input": "[BUG] [BUGGY] nextLineTabStop = width - 1; [FE] ComparisonFailure: Long arguments did not split as expected expected:< testLongLineChunkingIndentIgnored [CONTEXT] if (nextLineTabStop >= width) { [BUGGY] nextLineTabStop = width - 1; [BUGGY] } [CLASS] HelpFormatter OptionComparator [METHOD] renderWrappedText [RETURN_TYPE] StringBuffer StringBuffer sb int width int nextLineTabStop String text [VARIABLES] StringBuffer sb String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text boolean int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos width x Comparator comparator optionComparator ", "output": "[PATCH] nextLineTabStop = 1; ", "bugid": "105"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testPropertyOptionFlags . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   properties.setProperty( \"a\", \"true\" );  properties.setProperty( \"c\", \"yes\" );  properties.setProperty( \"e\", \"1\" );  Parser parser = new PosixParser();", "input": "[BUG] [BUGGY] break; [FE] AssertionFailedError testPropertyOptionFlags [CONTEXT] } } } else if (!(\"yes\".equalsIgnoreCase(value) ||\"true\".equalsIgnoreCase(value) ||\"1\".equalsIgnoreCase(value))) {  [BUGGY] break; [BUGGY] } cmd.addOption(opt); } } } [CLASS] ", "output": "[PATCH] continue; ", "bugid": "107"}, {"instruction": "The following code contains a buggy line with the following test error: StringIndexOutOfBoundsException: String index out of range: 12 testRenderWrappedTextWordCut . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:     StringBuffer sb = new StringBuffer();  new HelpFormatter().renderWrappedText(sb, width, padding, text);  assertEquals(\"cut and wrap\", expected, sb.toString()); }", "input": "[BUG] [BUGGY] while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ') && (c != '\\n') && (c != '\\r')) { ++pos; } [FE] StringIndexOutOfBoundsException: String index out of range: 12 testRenderWrappedTextWordCut [CONTEXT] } if (pos > startPos) { return pos; } pos = startPos + width; [BUGGY] while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ') && (c != '\\n') && (c != '\\r')) { ++pos; } [BUGGY] return pos == text.length() ? -1 : pos; } [CLASS] HelpFormatter OptionComparator [METHOD] findWrapPos [RETURN_TYPE] int String text int width int startPos [VARIABLES] char c String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_LONG_OPT_SEPARATOR DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app argName cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header longOptSeparator lpad name newline padding prefix text boolean int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos startPos width x Comparator comparator optionComparator ", "output": "[PATCH] [Delete] ", "bugid": "109"}, {"instruction": "The following code contains a buggy line with the following test error: commonscliAmbiguousOptionException: Ambiguous option: '--prefix' (could be: 'prefix', 'prefixplusplus') testExactOptionNameMatch . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  }", "input": "[BUG] [BUGGY] [FE] commonscliAmbiguousOptionException: Ambiguous option: '--prefix' (could be: 'prefix', 'prefixplusplus') testExactOptionNameMatch [CONTEXT] public List<String> getMatchingOptions(String opt) { opt = Util.stripLeadingHyphens(opt); List<String> matchingOpts = new ArrayList<String>();  [BUGGY] [BUGGY] for (String longOpt : longOpts.keySet()) { if (longOpt.startsWith(opt)) { matchingOpts.add(longOpt); } } return matchingOpts; } [CLASS] Options [METHOD] getMatchingOptions [RETURN_TYPE] List String opt [VARIABLES] List matchingOpts requiredOpts String longOpt opt boolean Map longOpts optionGroups shortOpts long serialVersionUID ", "output": "[PATCH] if(longOpts.keySet().contains(opt)) { return Collections.singletonList(opt); } ", "bugid": "110"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Second option has been used as value for first option Actual: -last shouldParseShortOptionWithoutValue . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertTrue(commandLine.hasOption(\"t1\"));  assertNotEquals(\"Second option has been used as value for first option\", \"-last\", commandLine.getOptionValue(\"t1\"));  assertTrue(\"Second option has not been detected\", commandLine.hasOption(\"last\")); }", "input": "[BUG] [BUGGY] return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2)); [FE] AssertionFailedError: Second option has been used as value for first option Actual: -last shouldParseShortOptionWithoutValue [CONTEXT] private boolean isShortOption(String token) { [BUGGY] return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2)); [BUGGY] } [CLASS] DefaultParser [METHOD] isShortOption [RETURN_TYPE] boolean String token [VARIABLES] Options options CommandLine cmd boolean selected skipParsing stopAtNonOption Option currentOption opt List expectedOpts String argument currentToken option token value ", "output": "[PATCH] if (!token.startsWith(\"-\") || token.length() == 1) { return false; } int pos = token.indexOf(\"=\"); String optName = pos == -1 ? token.substring(1) : token.substring(1, pos); return options.hasShortOption(optName); ", "bugid": "111"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected null, but was:<-ab> shouldParseConcatenatedShortOptions . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertTrue(commandLine.hasOption(\"t1\"));  assertNull(commandLine.getOptionValue(\"t1\"));  assertTrue(commandLine.hasOption(\"a\"));  assertTrue(commandLine.hasOption(\"b\"));", "input": "[BUG] [BUGGY] return options.hasShortOption(optName); [FE] AssertionFailedError: expected null, but was:<-ab> shouldParseConcatenatedShortOptions [CONTEXT] { if (!token.startsWith(\"-\") || token.length() == 1) { return false; } int pos = token.indexOf(\"=\"); String optName = pos == -1 ? token.substring(1) : token.substring(1, pos); [BUGGY] return options.hasShortOption(optName); [BUGGY] } [CLASS] DefaultParser [METHOD] isShortOption [RETURN_TYPE] boolean String token [VARIABLES] Options options CommandLine cmd boolean selected skipParsing stopAtNonOption Option currentOption opt List expectedOpts String argument currentToken optName option token value int pos ", "output": "[PATCH] if (options.hasShortOption(optName)) { return true; } return optName.length() > 0 && options.hasShortOption(String.valueOf(optName.charAt(0))); ", "bugid": "112"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testSimpleModeLeavesUnusedParams . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   public void testSimpleModeLeavesUnusedParams() { args.add(\"--compilation_level=SIMPLE_OPTIMIZATIONS\"); testSame(\"window.f = function(a) {};\");  }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: testSimpleModeLeavesUnusedParams [CONTEXT] private void removeUnreferencedFunctionArgs(Scope fnScope) {   [BUGGY] [BUGGY] Node function = fnScope.getRootNode(); Preconditions.checkState(function.isFunction()); if (NodeUtil.isGetOrSetKey(function.getParent())) { return; } Node argList = getFunctionArgList(function); boolean modifyCallers = modifyCallSites [CLASS] RemoveUnusedVars CallSiteOptimizer Continuation Assign [METHOD] removeUnreferencedFunctionArgs [RETURN_TYPE] void Scope fnScope [VARIABLES] Multimap assignsByVar classDefiningCalls continuations CallSiteOptimizer callSiteOptimizer AbstractCompiler compiler boolean isPropertyAssign mayHaveSecondarySideEffects maybeAliased modifyCallSites modifyCallers preserveFunctionExpressionNames removeGlobals Set referenced Scope fnScope parentScope scope Var var CodingConvention codingConvention Node a argList assignNode body c externs function lastArg lp n nameNode node parent root value List allFunctionScopes maybeUnreferenced toRemove toReplaceWithZero SimpleDefinitionFinder defFinder Map assignsByNode ", "output": "[PATCH] if (!removeGlobals) { return; } ", "bugid": "113"}, {"instruction": "The following code contains a buggy line with the following test error: null  testBadInterfaceExtendsNonExistentInterfaces . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    \"Bad type annotation. Unknown type nonExistent2\" }; testTypes(js, expectedWarnings);  }", "input": "[BUG] [BUGGY] currentPropertyNames = implicitProto.getOwnPropertyNames(); [FE] null  testBadInterfaceExtendsNonExistentInterfaces [CONTEXT] ObjectType interfaceType) { ObjectType implicitProto = interfaceType.getImplicitPrototype(); Set<String> currentPropertyNames; [BUGGY]  currentPropertyNames = implicitProto.getOwnPropertyNames(); [BUGGY] for (String name : currentPropertyNames) { ObjectType oType = properties.get(name); if (oType != null) { if (!interfaceType.getPropertyType(name).isEquivalentTo( oType.getPropertyType(name))) { compiler.report( t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE, functionName, name, oType.toString(), [CLASS] TypeCheck [METHOD] checkInterfaceConflictProperties [RETURN_TYPE] void NodeTraversal t Node n String functionName ObjectType> properties ObjectType> currentProperties ObjectType interfaceType [VARIABLES] ReverseAbstractInterpreter reverseInterpreter Set currentPropertyNames NodeTraversal t HashMap currentProperties properties DiagnosticGroup ALL_DIAGNOSTICS CheckLevel reportMissingOverride reportUnknownTypes Node n String OVERRIDING_PROTOTYPE_WITH_NON_OBJECT abstractMethodMessage abstractMethodName funName functionName functionPrivateName message name pname prop propName property property2 propertyName s MemoizedScopeCreator scopeCreator int noTypeCheckSection nullCount parentNodeType typedCount unknownCount TypeValidator validator ObjectType iType implicitProto interfaceType oType AbstractCompiler compiler JSTypeRegistry typeRegistry boolean declaredLocally declaredOverride enterSection externs foundInterfaceProperty inExterns interfaceHasProperty report reportMissingProperties superClassHasDeclaredProperty superClassHasProperty superInterfaceHasDeclaredProperty superInterfaceHasProperty typeable valid Scope outerScope topScope DiagnosticType BAD_DELETE BAD_IMPLEMENTED_TYPE BIT_OPERATION CONFLICTING_EXTENDED_TYPE CONFLICTING_IMPLEMENTED_TYPE CONSTRUCTOR_NOT_CALLABLE DETERMINISTIC_TEST DETERMINISTIC_TEST_NO_RESULT ENUM_DUP ENUM_NOT_CONSTANT EXPECTED_THIS_TYPE FUNCTION_MASKS_VARIABLE HIDDEN_INTERFACE_PROPERTY HIDDEN_SUPERCLASS_PROPERTY HIDDEN_SUPERCLASS_PROPERTY_MISMATCH ILLEGAL_IMPLICIT_CAST ILLEGAL_OBJLIT_KEY ILLEGAL_PROPERTY_CREATION INCOMPATIBLE_EXTENDED_PROPERTY_TYPE INEXISTENT_ENUM_ELEMENT INEXISTENT_PROPERTY INTERFACE_FUNCTION_NOT_EMPTY INTERFACE_METHOD_OVERRIDE INVALID_INTERFACE_MEMBER_DECLARATION IN_USED_WITH_STRUCT MULTIPLE_VAR_DEF NOT_A_CONSTRUCTOR NOT_CALLABLE UNEXPECTED_TOKEN UNKNOWN_EXPR_TYPE UNKNOWN_OVERRIDE UNRESOLVED_TYPE WRONG_ARGUMENT_COUNT diagnosticType InferJSDocInfo inferJSDocInfo ", "output": "[PATCH] if (implicitProto == null) { currentPropertyNames = ImmutableSet.of(); } else { currentPropertyNames = implicitProto.getOwnPropertyNames(); } ", "bugid": "114"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testNoInlineDeletedProperties . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: testNoInlineDeletedProperties [CONTEXT] if (parent.isGetProp()) { Preconditions.checkState(parent.getFirstChild() == name); if (gramps.isCall() && gramps.getFirstChild() == parent) { return false; }  [BUGGY] [BUGGY]   String propName = parent.getLastChild().getString(); if (!validProperties.contains(propName)) { [CLASS] ", "output": "[PATCH] if (gramps.isDelProp()) { return false; } ", "bugid": "115"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Expected: (Object|boolean|number|string) testGoogIsFunction2 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null; [FE] AssertionFailedError: Expected: (Object|boolean|number|string) testGoogIsFunction2 [CONTEXT] public JSType caseObjectType(ObjectType type) { if (value.equals(\"function\")) { JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE); [BUGGY] return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null; [BUGGY]  } return matchesExpectation(\"object\") ? type : null; } [CLASS] ChainableReverseAbstractInterpreter 1 2 RestrictByTypeOfResultVisitor RestrictByTrueTypeOfResultVisitor RestrictByFalseTypeOfResultVisitor RestrictByOneTypeOfResultVisitor [METHOD] caseObjectType [RETURN_TYPE] JSType ObjectType type [VARIABLES] ObjectType type JSTypeRegistry typeRegistry boolean outcome resultEqualsValue JSType ctorType Visitor restrictNullVisitor restrictUndefinedVisitor ChainableReverseAbstractInterpreter firstLink lastLink nextLink CodingConvention convention String qualifiedName result value ", "output": "[PATCH] if (resultEqualsValue) { return ctorType.getGreatestSubtype(type); } else { return type.isSubtype(ctorType) ? null : type; } ", "bugid": "116"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testIssue821 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] return allResultsMatch(n, MAY_BE_STRING_PREDICATE); [FE] AssertionFailedError: testIssue821 [CONTEXT] static boolean mayBeString(Node n, boolean recurse) { if (recurse) { [BUGGY] return allResultsMatch(n, MAY_BE_STRING_PREDICATE); [BUGGY] } else { return mayBeStringHelper(n); } } [CLASS] NodeUtil NumbericResultPredicate BooleanResultPredicate MayBeStringResultPredicate VarCollector MatchNameNode MatchNodeType MatchDeclaration MatchNotFunction MatchShallowStatement [METHOD] mayBeString [RETURN_TYPE] boolean Node n boolean recurse [VARIABLES] BooleanResultPredicate BOOLEAN_RESULT_PREDICATE Set BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS CONSTRUCTORS_WITHOUT_SIDE_EFFECTS OBJECT_METHODS_WITHOUT_SIDEEFFECTS REGEXP_METHODS STRING_REGEXP_METHODS defines emptySet knownConstants NumbericResultPredicate NUMBERIC_RESULT_PREDICATE boolean recurse MayBeStringResultPredicate MAY_BE_STRING_PREDICATE Node n char LARGEST_BASIC_LATIN String JSC_PROPERTY_NAME_FN childValue name rawJsString s value Map vars long MAX_POSITIVE_INTEGER_NUMBER longValue int c end nextSkipSlot nextSlot start type Predicate MATCH_NOT_FUNCTION p ", "output": "[PATCH] return anyResultsMatch(n, MAY_BE_STRING_PREDICATE); ", "bugid": "117"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected a warning testGetprop4 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] } else if (n.getJSType() != null && parent.isAssign()) { [FE] AssertionFailedError: expected a warning testGetprop4 [CONTEXT] Node property = n.getLastChild(); Node objNode = n.getFirstChild(); JSType childType = getJSType(objNode); if (childType.isDict()) { report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS,\"'.'\",\"dict\"); [BUGGY] } else if (n.getJSType() != null && parent.isAssign()) { [BUGGY] return; } else if (validator.expectNotNullOrUndefined(t, n, childType,\"No properties on this expression\", getNativeType(OBJECT_TYPE))) { checkPropertyAccess(childType, property.getString(), t, n); } ensureTyped(t, n); } [CLASS] TypeCheck [METHOD] visitGetProp [RETURN_TYPE] void NodeTraversal t Node n Node parent [VARIABLES] ReverseAbstractInterpreter reverseInterpreter JSType childType NodeTraversal t DiagnosticGroup ALL_DIAGNOSTICS CheckLevel reportMissingOverride reportUnknownTypes Node n objNode parent property ScopeCreator scopeCreator String OVERRIDING_PROTOTYPE_WITH_NON_OBJECT abstractMethodMessage abstractMethodName functionPrivateName message prop property property2 propertyName s int noTypeCheckSection nullCount parentNodeType typedCount unknownCount TypeValidator validator AbstractCompiler compiler JSTypeRegistry typeRegistry boolean declaredLocally declaredOverride enterSection externs foundInterfaceProperty inExterns interfaceHasProperty report reportMissingProperties superClassHasDeclaredProperty superClassHasProperty superInterfaceHasDeclaredProperty superInterfaceHasProperty typeable valid Scope outerScope topScope DiagnosticType BAD_DELETE BAD_IMPLEMENTED_TYPE BIT_OPERATION CONFLICTING_EXTENDED_TYPE CONFLICTING_IMPLEMENTED_TYPE CONSTRUCTOR_NOT_CALLABLE DETERMINISTIC_TEST DETERMINISTIC_TEST_NO_RESULT ENUM_DUP ENUM_NOT_CONSTANT EXPECTED_THIS_TYPE FUNCTION_MASKS_VARIABLE HIDDEN_INTERFACE_PROPERTY HIDDEN_SUPERCLASS_PROPERTY HIDDEN_SUPERCLASS_PROPERTY_MISMATCH ILLEGAL_IMPLICIT_CAST INCOMPATIBLE_EXTENDED_PROPERTY_TYPE INEXISTENT_ENUM_ELEMENT INEXISTENT_PROPERTY INTERFACE_FUNCTION_NOT_EMPTY INTERFACE_METHOD_OVERRIDE INVALID_INTERFACE_MEMBER_DECLARATION MULTIPLE_VAR_DEF NOT_A_CONSTRUCTOR NOT_CALLABLE UNEXPECTED_TOKEN UNKNOWN_EXPR_TYPE UNKNOWN_OVERRIDE UNRESOLVED_TYPE WRONG_ARGUMENT_COUNT diagnosticType InferJSDocInfo inferJSDocInfo ", "output": "[PATCH] ", "bugid": "118"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testIssue794b . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: testIssue794b [CONTEXT] private boolean hasExceptionHandler(Node cfgNode) { [BUGGY] [BUGGY] return false; } [CLASS] MaybeReachingVariableUse ReachingUses ReachingUsesJoinOp [METHOD] hasExceptionHandler [RETURN_TYPE] boolean Node cfgNode [VARIABLES] Multimap mayUseMap Set escaped boolean Scope jsScope Node cfgNode ", "output": "[PATCH] List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode); for (DiGraphEdge<Node, Branch> edge : branchEdges) { if (edge.getValue() == Branch.ON_EX) { return true; } } ", "bugid": "119"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testIssue787 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   \"\"; test(options, code, result);  }", "input": "[BUG] [BUGGY] traverse(c); Node next = c.getNext(); [FE] AssertionFailedError: testIssue787 [CONTEXT]  if (!shouldVisit(node)) { return; } int visits = 0; do { Node c = node.getFirstChild(); while(c != null) { [BUGGY] traverse(c); Node next = c.getNext(); [BUGGY] c = next; } visit(node); visits++; Preconditions.checkState(visits < 10000,\"too many interations\"); } while (shouldRetraverse(node)); [CLASS] PeepholeOptimizationsPass ScopeState StateStack PeepholeChangeHandler [METHOD] traverse [RETURN_TYPE] void Node node [VARIABLES] AbstractCompiler compiler boolean changed traverseChildScopes AbstractPeepholeOptimization[] optimizations peepholeOptimizations Node c next node ArrayList states int currentDepth visits StateStack traversalState ", "output": "[PATCH] Node next = c.getNext(); traverse(c); ", "bugid": "120"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Unexpected error(s): JSC_MISSING_RETURN_STATEMENT Missing return statement Function expected to return number at testcode line 1 : 24 expected:<0> but was:<1> testIssue779 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] cfa.createEdge(fromNode, Branch.UNCOND, finallyNode); [FE] AssertionFailedError: Unexpected error(s): JSC_MISSING_RETURN_STATEMENT Missing return statement Function expected to return number at testcode line 1 : 24 expected:<0> but was:<1> testIssue779 [CONTEXT] } else if (NodeUtil.getCatchBlock(parent) == node){ if (NodeUtil.hasFinally(parent)) { return computeFallThrough(node.getNext()); } else { return computeFollowNode(fromNode, parent, cfa); } } else if (parent.getLastChild() == node){ if (cfa != null) { for (Node finallyNode : cfa.finallyMap.get(parent)) { [BUGGY] cfa.createEdge(fromNode, Branch.UNCOND, finallyNode); [BUGGY] } } return computeFollowNode(fromNode, parent, cfa); } }  Node nextSibling = node.getNext(); [CLASS] ControlFlowAnalysis 1 AstControlFlowGraph 1 2 [METHOD] computeFollowNode [RETURN_TYPE] Node Node fromNode Node node ControlFlowAnalysis cfa [VARIABLES] Multimap finallyMap AbstractCompiler compiler ControlFlowAnalysis cfa boolean edgeAnnotations shouldTraverseFunctions ControlFlowGraph cfg Node body child collection cond cur curHandler deflt elseBlock entry externs finallyNode forNode fromNode init item iter lastJump n next nextSibling node parent previous root thenBlock value Map astPosition nodePriorities priorities Deque exceptionHandler int astPositionCounter priorityCounter Comparator priorityComparator ", "output": "[PATCH] cfa.createEdge(fromNode, Branch.ON_EX, finallyNode); ", "bugid": "121"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testSimpleForIn . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  \"var a,b,x; a in b\"); noInline(\"var a, b; var x = a in b; print(1); x\"); noInline(\"var a,b,x = a in b; delete a[b]; x\");  }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: testSimpleForIn [CONTEXT]  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) { return true; } if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) { return true; } [BUGGY] [BUGGY] for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) { return true; } } return false; } [CLASS] FlowSensitiveInlineVariables 1 GatherCandiates 1 Candidate 1 2 3 4 [METHOD] apply [RETURN_TYPE] boolean Node n [VARIABLES] AbstractCompiler compiler boolean ControlFlowGraph cfg Node c def defCfgNode n use useCfgNode MaybeReachingVariableUse reachingUses List candidates MustBeReachingVariableDef reachingDef String varName int numUseWithinUseCfgNode Predicate SIDE_EFFECT_PREDICATE ", "output": "[PATCH] if (n.isDelProp()) { return true; } ", "bugid": "122"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<in[consistent return type testIssue688 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) { [FE] ComparisonFailure: expected:<in[consistent return type testIssue688 [CONTEXT] } else if (info.isConstructor() || info.isInterface()) { return createFunctionTypeFromNodes( rValue, lValue.getQualifiedName(), info, lValue); } else { if (info.isConstant()) { JSType knownType = null; if (rValue != null) { [BUGGY] if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) { [BUGGY]  return rValue.getJSType(); } else if (rValue.isOr()) { Node firstClause = rValue.getFirstChild(); [CLASS] TypedScopeCreator DeferredSetType DiscoverEnumsAndTypedefs AbstractScopeBuilder CollectProperties StubDeclaration GlobalScopeBuilder LocalScopeBuilder FirstOrderFunctionAnalyzer [METHOD] getDeclaredType [RETURN_TYPE] JSType String sourceName JSDocInfo info Node lValue Node rValue [VARIABLES] JSType elementsType injectedThisType jsType keyType knownType propType t type valueType Node catchName child errorRoot firstChild firstClause fnBlock fnRoot functionNode initialValue key keyNode lValue lValueNode lvalueNode n name nameNode node objLit objNode objectLit ownerNode parametersNode parent rValue root scriptRoot secondClause value valueNode var String DELEGATE_PROXY_SUFFIX fnName functionName keyName lValueName lendsName memberName name ownerName propName prototypeName qualifiedName scriptName sourceName variableName JSDocInfo info TypeValidator validator ObjectType fnThisType globalThis iface objLitType ownerType thisType AbstractCompiler compiler ErrorReporter typeParsingErrorReporter JSTypeRegistry registry typeRegistry boolean createdEnumType declareOnOwner descend inferred isExtern isFnLiteral isGlobalVar isValidValue namesMatch searchedForThisType shouldDeclareOnGlobalThis Scope globalScope newScope parent s scope scopeToDeclareIn DiagnosticType CONSTRUCTOR_EXPECTED CTOR_INITIALIZER ENUM_INITIALIZER IFACE_INITIALIZER LENDS_ON_NON_OBJECT MALFORMED_TYPEDEF UNKNOWN_LENDS CodingConvention codingConvention InputId inputId List deferredSetTypes delegateProxyPrototypes lentObjectLiterals nonExternFunctions stubDeclarations varsToRemove Map data delegateCallingConventions functionAnalysisResults outParam ", "output": "[PATCH] JSDocInfo rValueInfo = rValue.getJSDocInfo(); if (rValueInfo != null && rValueInfo.hasType()) { return rValueInfo.getType().evaluate(scope, typeRegistry); } else if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {   ", "bugid": "123"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testDependencySorting . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   new DependencyOptions()  .setDependencySorting(true)); test(  options,  new String[] {", "input": "[BUG] [BUGGY] if (options.dependencyOptions.needsManagement() && options.closurePass) { [FE] AssertionFailedError testDependencySorting [CONTEXT]  [BUGGY] if (options.dependencyOptions.needsManagement() && options.closurePass) { [BUGGY]  [METHOD] parseInputs [RETURN_TYPE] Node [VARIABLES] FunctionInformationMap functionInformationMap ", "output": "[PATCH] if (options.dependencyOptions.needsManagement()) { ", "bugid": "124"}, {"instruction": "The following code contains a buggy line with the following test error: IllegalArgumentException: Node cannot be refined testNoThisInference . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  JSType thisType = createNullableType(OBJECT_TYPE); assumingThisType(thisType); inFunction(\"var out = 3; if (goog.isNull(this)) out = this;\"); verify(\"out\", createUnionType(OBJECT_TYPE, NUMBER_TYPE));  }", "input": "[BUG] [BUGGY] [FE] IllegalArgumentException: Node cannot be refined testNoThisInference [CONTEXT] case Token.GETPROP: String qualifiedName = node.getQualifiedName(); Preconditions.checkNotNull(qualifiedName); JSType origType = node.getJSType(); origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType; scope.inferQualifiedSlot(node, qualifiedName, origType, type); break; [BUGGY] [BUGGY] default: throw new IllegalArgumentException(\"Node cannot be refined. \\n\" + node.toStringTree()); } } [CLASS] ", "output": "[PATCH] case Token.THIS: break; ", "bugid": "125"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testSimpleFunctionCall . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  test(\"var a = String(23)\", \"var a = '' + 23\"); test(\"var a = String('hello')\", \"var a = '' + 'hello'\"); testSame(\"var a = String('hello', bar());\"); testSame(\"var a = String({valueOf: function() { return 1; }});\");  }", "input": "[BUG] [BUGGY] if (value != null) { [FE] AssertionFailedError: testSimpleFunctionCall [CONTEXT] Node callTarget = n.getFirstChild(); if (callTarget != null && callTarget.isName() && callTarget.getString().equals(\"String\")) { Node value = callTarget.getNext(); [BUGGY] if (value != null) { [BUGGY] Node addition = IR.add( IR.string(\"\").srcref(callTarget), value.detachFromParent()); n.getParent().replaceChild(n, addition); reportCodeChange(); return addition; } } return n; } [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryFoldSimpleFunctionCall [RETURN_TYPE] Node Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean late ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node addition callTarget n value int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE ", "output": "[PATCH] if (value != null && value.getNext() == null && NodeUtil.isImmutableValue(value)) { ", "bugid": "126"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<1> but was:<4> testCost . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   public void testCost() { checkCost(\"1\", \"1\"); checkCost(\"true\", \"1\"); checkCost(\"false\", \"1\"); checkCost(\"a\", \"xx\");", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: expected:<1> but was:<4> testCost [CONTEXT] @Override void addIdentifier(String identifier) { add(ESTIMATED_IDENTIFIER); } [BUGGY] [BUGGY] } } [CLASS] ", "output": "[PATCH] @Override void addConstant(String newcode) { add(\"0\"); } ", "bugid": "128"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testDependencySortingWhitespaceMode . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  args.add(\"--manage_closure_dependencies\"); args.add(\"--compilation_level=WHITESPACE_ONLY\"); test(new String[] {    \"goog.require('beer');\",    \"goog.provide('beer');\\ngoog.require('hops');\",", "input": "[BUG] [BUGGY] if (options.dependencyOptions.needsManagement() && !options.skipAllPasses && options.closurePass) { [FE] AssertionFailedError: testDependencySortingWhitespaceMode [CONTEXT] if (options.transformAMDToCJSModules || options.processCommonJSModules) { processAMDAndCommonJSModules(); } boolean staleInputs = false; [BUGGY] if (options.dependencyOptions.needsManagement() && !options.skipAllPasses && options.closurePass) { [BUGGY] for (CompilerInput input : inputs) {  for (String provide : input.getProvides()) { getTypeRegistry().forwardDeclareType(provide); } } try { [CLASS] Compiler 2 3 1 4 5 6 7 8 9 CodeBuilder IntermediateState [METHOD] parseInputs [RETURN_TYPE] Node [VARIABLES] FunctionInformationMap functionInformationMap ErrorManager errorManager StringBuilder debugLog sb Config parserConfig Node externAndJsRoot externsRoot jsRoot n n1 n2 newRoot oldRoot root PerformanceTracker tracker PassConfig passes String SINGLETON_MODULE_NAME SYNTHETIC_EXTERNS comment currentPassName externExports inputName moduleName name passName passToCheck provide LifeCycleStage lifeCycleStage Logger logger JSDocInfo info PassFactory sanityCheck long COMPILER_STACK_SIZE result serialVersionUID TypeValidator typeValidator JSTypeRegistry typeRegistry ErrorReporter defaultErrorReporter oldErrorReporter RecentChange recentChange GlobalVarReferenceMap globalRefMap DiagnosticType DUPLICATE_EXTERN_INPUT DUPLICATE_INPUT EMPTY_MODULE_LIST_ERROR EMPTY_ROOT_MODULE_ERROR MISSING_ENTRY_ERROR MODULE_DEPENDENCY_ERROR MOTION_ITERATIONS_ERROR OPTIMIZE_LOOP_ERROR SourceMap sourceMap List codeChangeHandlers externs files guards inputs modules CircularDependencyException e WarningsGuard warningsGuard ReverseAbstractInterpreter abstractInterpreter PrintStream outStream stream SourceInformationAnnotator sia double progress Tracer currentTracer t tracer JSModuleGraph e moduleGraph int colCount lineCount syntheticCodeId uniqueNameId CompilerInput input newInput oldInput previous synthesizedExternsInput boolean colorize devMode dumpTraceReport hasRegExpGlobalReferences isExtern staleInputs trace useLargeStackThread useThreads MissingProvideException e State passConfigState state CodingConvention defaultCodingConvention CompilerOptions options Map injectedLibraries inputMap inputsById ", "output": "[PATCH] if (options.dependencyOptions.needsManagement() && options.closurePass) { ", "bugid": "129"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: unexpected warnings(s): testIssue700 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: unexpected warnings(s): testIssue700 [CONTEXT] for (Property prop : properties.values()) { prop.setType(safeResolve(prop.getType(), t, scope)); } return this; } @Override public void matchConstraint(ObjectType constraintObj) { [BUGGY] [BUGGY] if (constraintObj.isRecordType()) { [CLASS] ", "output": "[PATCH] if (hasReferenceName()) { return; } ", "bugid": "130"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: unexpected warnings(s): testIssue669 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] if (constraintObj != null && constraintObj.isRecordType()) { ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); if (objType != null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType); } objType.defineInferredProperty(prop, typeToInfer, null); } } } [FE] AssertionFailedError: unexpected warnings(s): testIssue669 [CONTEXT] private void inferPropertyTypesToMatchConstraint( JSType type, JSType constraint) { if (type == null || constraint == null) { return; } ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined()); [BUGGY] if (constraintObj != null && constraintObj.isRecordType()) { ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); if (objType != null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType); } [CLASS] TypeInference BooleanOutcomePair [METHOD] inferPropertyTypesToMatchConstraint [RETURN_TYPE] void JSType type JSType constraint [VARIABLES] ReverseAbstractInterpreter reverseInterpreter ObjectType constraintObj objType AbstractCompiler compiler JSTypeRegistry registry JSType constraint propType type typeToInfer boolean Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS TEMPLATE_TYPE_NOT_OBJECT_TYPE TEMPLATE_TYPE_OF_THIS_EXPECTED BooleanLiteralSet booleanValues toBooleanOutcomes String prop Map assertionFunctionsMap FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope ", "output": "[PATCH] if (constraintObj != null) { type.matchConstraint(constraintObj); ", "bugid": "131"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testSingletonGetter1 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   .setOptionsForCompilationLevel(options); options.setCodingConvention(new ClosureCodingConvention()); test(options,  \"/** @const */\\n\" +  \"var goog = goog || {};\\n\" +", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: testSingletonGetter1 [CONTEXT]  SubclassRelationship relationship = convention.getClassesDefinedByCall(callNode); if (relationship != null) { return false; }  [BUGGY] [BUGGY] } } return canMoveAggressively(value) || canMoveModerately(initialization, reference); }  private boolean canMoveAggressively(Node value) { [CLASS] ", "output": "[PATCH] if (convention.getSingletonGetterClassName(callNode) != null) { return false; } ", "bugid": "132"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<x-[ ]-00> but was:<x-[]-00> testMinusNegativeZero . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  // Negative zero is weird, because we have to be able to distinguish // it from positive zero (there are some subtle differences in behavior). assertPrint(\"x- -0\", \"x- -0.0\");  }", "input": "[BUG] [BUGGY] if (x < 0 && prev == '-') { [FE] ComparisonFailure: expected:<x-[ ]-00> but was:<x-[]-00> testMinusNegativeZero [CONTEXT] void addNumber(double x) { char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); [BUGGY] if (x < 0 && prev == '-') { [BUGGY] add(\"\"); } if ((long) x == x && !negativeZero) { long value = (long) x; long mantissa = value; int exp = 0; if (Math.abs(x) >= 100) { while (mantissa / 10 * Math.pow(10, exp + 1) == value) { mantissa /= 10; [CLASS] CodeConsumer [METHOD] addNumber [RETURN_TYPE] void double x [VARIABLES] char prev boolean binOp needSemiColon negativeZero sawFunction shouldEndLine statementContext statementNeedsEnded statementStarted double x long mantissa value int exp ", "output": "[PATCH] if (x <= 0 && prev == '-') {", "bugid": "133"}, {"instruction": "The following code contains a buggy line with the following test error: RuntimeException: javalangRuntimeException: INTERNAL COMPILER ERROR testIssue284 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  CompilerOptions options = createCompilerOptions(); options.smartNameRemoval = true; test(options,  \"var goog = {};\" +  \"goog.inherits = function(x, y) {};\" +", "input": "[BUG] [BUGGY] JsName name = getName(ns.name, false); if (name != null) { refNodes.add(new ClassDefiningFunctionNode( name, n, parent, parent.getParent())); } [FE] RuntimeException: javalangRuntimeException: INTERNAL COMPILER ERROR testIssue284 [CONTEXT] if (ns.isPrototype) { recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n); } else { recordSet(ns.name, nameNode); } } } else if (n.isCall()) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns != null && ns.onlyAffectsClassDef) { [BUGGY] JsName name = getName(ns.name, false); if (name != null) { refNodes.add(new ClassDefiningFunctionNode( name, n, parent, parent.getParent())); } [BUGGY] } } } [CLASS] NameAnalyzer AliasSet RefType ReferencePropagationCallback NameInformation JsName JsNameRefNode PrototypeSetNode SpecialReferenceNode ClassDefiningFunctionNode InstanceOfCheckNode ProcessExternals FindDependencyScopes HoistVariableAndFunctionDeclarations FindDeclarationsAndSetters 1 FindReferences NodeAccumulator RemoveListener TriState [METHOD] visit [RETURN_TYPE] void NodeTraversal t Node n Node parent [VARIABLES] NameInformation ns Set DEFAULT_GLOBAL_NAMES externalNames globalNames names nodesToKeep NodeTraversal t Node callNode containingNode gramps n nameNode node parent String FUNCTION PROTOTYPE_SUBSTRING WINDOW name name1 name2 prototypeClass prototypeProperty superclass int PROTOTYPE_SUBSTRING_LEN PROTOTYPE_SUFFIX_LEN Predicate NON_LOCAL_RESULT_PREDICATE RefType INHERITANCE REGULAR callSite AbstractCompiler compiler boolean externallyDefined hasInstanceOfReference hasWrittenDescendants isExternallyReferenceable isPrototype onlyAffectsClassDef referenced removeUnreferenced JsName from jsName name nameInfo rhs to List prototypeNames refNodes DiGraph referenceGraph TriState BOTH FALSE TRUE Map aliases allNames scopes AstChangeProxy changeProxy ", "output": "[PATCH] JsName name = getName(ns.name, true); ", "bugid": "134"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testForEach . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] [FE] AssertionFailedError testForEach [CONTEXT] Node processForInLoop(ForInLoop loopNode) { [BUGGY] [BUGGY] return newNode( Token.FOR, transform(loopNode.getIterator()), transform(loopNode.getIteratedObject()), transformBlock(loopNode.getBody())); } [CLASS] IRFactory TransformDispatcher [METHOD] processForInLoop [RETURN_TYPE] Node ForInLoop loopNode [VARIABLES] ForInLoop loopNode ErrorReporter errorReporter Set ALLOWED_DIRECTIVES ES5_RESERVED_KEYWORDS ES5_STRICT_RESERVED_KEYWORDS directives parsedComments reservedKeywords boolean Config config Node assign c child irNode labelName n newBlock node ret rootNodeJsDocHolder target templateNode FileLevelJsDocBuilder fileLevelJsDocBuilder String SUSPICIOUS_COMMENT_WARNING comment directive sourceName sourceString value StaticSourceFile sourceFile TransformDispatcher transformDispatcher JSDocInfo fileOverviewInfo jsDocInfo rootNodeJsDoc ", "output": "[PATCH] if (loopNode.isForEach()) { errorReporter.error(\"unsupported language extension: for each\", sourceName, loopNode.getLineno(),\"\", 0); return newNode(Token.EXPR_RESULT, Node.newNumber(0)); } ", "bugid": "135"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Expected: ({a: number, b: string}|{b: string, c: string, e: number}) testRecordTypeLeastSuperType2 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  JSType otherRecordType = builder.build(); assertTypeEquals(  registry.createUnionType(recordType, otherRecordType),  recordType.getLeastSupertype(otherRecordType));", "input": "[BUG] [BUGGY]  if (!that.isRecordType()) { return super.getLeastSupertype(that); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); for (String property : properties.keySet()) { if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))) { builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } } return builder.build(); } [FE] AssertionFailedError: Expected: ({a: number, b: string}|{b: string, c: string, e: number}) testRecordTypeLeastSuperType2 [CONTEXT] public JSType getLeastSupertype(JSType that) { if (!that.isRecordType()) { return super.getLeastSupertype(that); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); for (String property : properties.keySet()) { if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))) { builder.addProperty(property, getPropertyType(property), [CLASS] RecordType [METHOD] getLeastSupertype [RETURN_TYPE] JSType JSType that [VARIABLES] boolean inferred isFrozen JSType that String property RecordTypeBuilder builder long serialVersionUID SortedMap properties ", "output": "[PATCH] [Delete]", "bugid": "136"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected a warning testIssue586 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] if (inferred) { inferred = !(rhsValue != null && rhsValue.isFunction() && (info != null || !scope.isDeclared(qName, false))); [FE] AssertionFailedError: expected a warning testIssue586 [CONTEXT] boolean inferred = true; if (info != null) { inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info)); } [BUGGY] if (inferred) { inferred = !(rhsValue != null && rhsValue.isFunction() && [BUGGY] (info != null || !scope.isDeclared(qName, false))); } if (!inferred) { ObjectType ownerType = getObjectSlot(ownerName); if (ownerType != null) { [CLASS] TypedScopeCreator DeferredSetType DiscoverEnumsAndTypedefs AbstractScopeBuilder CollectProperties StubDeclaration GlobalScopeBuilder LocalScopeBuilder FirstOrderFunctionAnalyzer [METHOD] maybeDeclareQualifiedName [RETURN_TYPE] void NodeTraversal t JSDocInfo info Node n Node parent Node rhsValue [VARIABLES] JSType delegateType elementsType jsType keyType knownType ownerTypeOfThis propType t type valueType NodeTraversal t Var qVar Node catchName child errorRoot firstChild firstClause fnBlock fnRoot functionNode initialValue key keyNode lValue lValueNode lvalueNode n name nameNode node objLit objNode objectLit ownerNode parametersNode parent rValue rhsValue root scriptRoot secondClause value valueNode var FunctionType ownerType String DELEGATE_PROXY_SUFFIX delegateName fnName functionName keyName lValueName lendsName memberName name ownerName propName prototypeName qName qualifiedName scriptName singletonGetterClassName sourceName variableName JSDocInfo info TypeValidator validator ObjectType delegateBaseObject delegateSuperObject delegatorObject fnThisType globalThis iface o objLitType objectType ownerType qVarType subClass superClass thisType type AbstractCompiler compiler ErrorReporter typeParsingErrorReporter JSTypeRegistry registry typeRegistry boolean createdEnumType declareOnOwner descend inferred isExtern isFnLiteral isGlobalVar isValidValue namesMatch searchedForThisType shouldDeclareOnGlobalThis Scope globalScope newScope parent s scope scopeToDeclareIn DiagnosticType CONSTRUCTOR_EXPECTED CTOR_INITIALIZER ENUM_INITIALIZER IFACE_INITIALIZER LENDS_ON_NON_OBJECT MALFORMED_TYPEDEF UNKNOWN_LENDS CodingConvention codingConvention InputId inputId List deferredSetTypes delegateProxyPrototypes nonExternFunctions stubDeclarations varsToRemove Map data delegateCallingConventions functionAnalysisResults outParam ", "output": "[PATCH] if (inferred && rhsValue != null && rhsValue.isFunction()) { if (info != null) { inferred = false; } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) { inferred = false; } ", "bugid": "137"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<var x={[\"010\"]:1}> but was:<var x={[10]:1}> testNumericKeys . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   public void testNumericKeys() { assertPrint(\"var x = {010: 1};\", \"var x={8:1}\"); assertPrint(\"var x = {'010': 1};\", \"var x={\\\"010\\\":1}\"); assertPrint(\"var x = {0x10: 1};\", \"var x={16:1}\");", "input": "[BUG] [BUGGY] return len > 0; [FE] ComparisonFailure: expected:<var x={[\"010\"]:1}> but was:<var x={[10]:1}> testNumericKeys [CONTEXT] static boolean isSimpleNumber(String s) { int len = s.length(); for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c < '0' || c > '9') { return false; } } [BUGGY] return len > 0; [BUGGY] } [CLASS] CodeGenerator Context [METHOD] isSimpleNumber [RETURN_TYPE] boolean String s [VARIABLES] Context BEFORE_DANGLING_ELSE IN_FOR_INIT_CLAUSE OTHER PRESERVE_BLOCK START_OF_EXPR STATEMENT context rhsContext boolean char c CodeConsumer cc consumer String s Map ESCAPED_JS_STRINGS CharsetEncoder outputCharsetEncoder int index len char[] HEX_CHARS ", "output": "[PATCH] return len > 0 && s.charAt(0) != '0';  ", "bugid": "138"}, {"instruction": "The following code contains a buggy line with the following test error: IllegalStateException: Expected function but was call Reference node CALL 4 [free_call: 1] [source_file: testcode] testIssue538 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] return NodeUtil.isFunctionExpression(n); [FE] IllegalStateException: Expected function but was call Reference node CALL 4 [free_call: 1] [source_file: testcode] testIssue538 [CONTEXT] private static boolean isReduceableFunctionExpression(Node n) { [BUGGY] return NodeUtil.isFunctionExpression(n); [BUGGY] } [CLASS] FunctionRewriter Reduction ReductionGatherer Reducer EmptyFunctionReducer SingleReturnStatementReducer IdentityReducer ReturnConstantReducer GetterReducer SetterReducer [METHOD] isReduceableFunctionExpression [RETURN_TYPE] boolean Node n [VARIABLES] Multimap reductionMap reductions AbstractCompiler compiler boolean Node addingRoot externs helperCode n newChild oldChild parent root List reducers String FACTORY_METHOD_NAME HELPER_SOURCE int SAVINGS_THRESHOLD helperCodeCost savings ", "output": "[PATCH] return NodeUtil.isFunctionExpression(n) && !NodeUtil.isGetOrSetKey(n.getParent()); ", "bugid": "139"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<foo2:third line> but was:<null> testExceptNoNewLine . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  assertEquals(\"foo2:first line\", provider.getSourceLine(\"foo2\", 1)); assertEquals(\"foo2:second line\", provider.getSourceLine(\"foo2\", 2)); assertEquals(\"foo2:third line\", provider.getSourceLine(\"foo2\", 3)); assertEquals(null, provider.getSourceLine(\"foo2\", 4));  }", "input": "[BUG] [BUGGY] return null; [FE] ComparisonFailure: expected:<foo2:third line> but was:<null> testExceptNoNewLine [CONTEXT] if (js.indexOf('\\n', pos) == -1) {  [BUGGY] return null; [BUGGY] } else { return js.substring(pos, js.indexOf('\\n', pos)); } [CLASS] SourceFile Preloaded Generated OnDisk [METHOD] getLine [RETURN_TYPE] String int lineNumber [VARIABLES] boolean isExternFile newVal int[] lineOffsets String code fileName inputCharset js originalPath sourceCode IOException e File file long serialVersionUID int SOURCE_EXCERPT_REGION_LENGTH ii lastLine lastOffset lineNumber lineno n nextpos pos startLine Generator generator ", "output": "[PATCH] if (pos >= js.length()) { return null; } else { return js.substring(pos, js.length()); } ", "bugid": "140"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Expected: <null> but was: foo testRequire . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   public void testRequire() { assertRequire(\"goog.require('foo')\"); assertNotRequire(\"goog.require(foo)\"); assertNotRequire(\"goog.require()\"); assertNotRequire(\"foo()\");", "input": "[BUG] [BUGGY] if (target != null) { [FE] AssertionFailedError: Expected: <null> but was: foo testRequire [CONTEXT] private static String extractClassNameIfGoog(Node node, Node parent, String functionName){ String className = null; if (NodeUtil.isExprCall(parent)) { Node callee = node.getFirstChild(); if (callee != null && callee.getType() == Token.GETPROP) { String qualifiedName = callee.getQualifiedName(); if (functionName.equals(qualifiedName)) { Node target = callee.getNext(); [BUGGY] if (target != null) { [BUGGY] className = target.getString(); } } } } return className; } [CLASS] ClosureCodingConvention [METHOD] extractClassNameIfGoog [RETURN_TYPE] String Node node Node parent String functionName [VARIABLES] Set propertyTestFunctions String className functionName qualifiedName boolean DiagnosticType OBJECTLIT_EXPECTED long serialVersionUID Node callee node parent target ", "output": "[PATCH] if (target != null && target.getType() == Token.STRING) { ", "bugid": "141"}, {"instruction": "The following code contains a buggy line with the following test error: IllegalStateException testExpressionInForIn . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   }", "input": "[BUG] [BUGGY] addToSetIfLocal(lhs, kill); addToSetIfLocal(lhs, gen); [FE] IllegalStateException testExpressionInForIn [CONTEXT] computeGenKill(NodeUtil.getConditionExpression(n), gen, kill, conditional); } else { Node lhs = n.getFirstChild(); Node rhs = lhs.getNext(); if (NodeUtil.isVar(lhs)) { lhs = lhs.getLastChild(); } [BUGGY] addToSetIfLocal(lhs, kill); addToSetIfLocal(lhs, gen); [BUGGY] computeGenKill(rhs, gen, kill, conditional); } [CLASS] LiveVariablesAnalysis LiveVariableJoinOp LiveVariableLattice [METHOD] computeGenKill [RETURN_TYPE] void Node n BitSet gen BitSet kill boolean conditional [VARIABLES] BitSet gen kill liveSet Set escaped String ARGUMENT_ARRAY_ALIAS var boolean conditional Scope jsScope Node c lhs n rhs ", "output": "[PATCH] if (NodeUtil.isName(lhs)) { addToSetIfLocal(lhs, kill); addToSetIfLocal(lhs, gen); } else { computeGenKill(lhs, gen, kill, conditional); } ", "bugid": "142"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Expected no warnings or errors testCheckGlobalThisOff . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  args.add(\"--warning_level=VERBOSE\"); args.add(\"--jscomp_off=globalThis\"); testSame(\"function f() { this.a = 3; }\");  }", "input": "[BUG] [BUGGY] if (options.checkGlobalThisLevel.isOn()) { [FE] AssertionFailedError: Expected no warnings or errors testCheckGlobalThisOff [CONTEXT] } else if (!options.checkTypes) {  options.setWarningLevel( DiagnosticGroup.forType( RhinoErrorReporter.TYPE_PARSE_ERROR), CheckLevel.OFF); } [BUGGY] if (options.checkGlobalThisLevel.isOn()) { [BUGGY] options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel); } if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) { options.setWarningLevel( DiagnosticGroups.ES5_STRICT, CheckLevel.ERROR); } [CLASS] Compiler 2 3 1 4 5 6 7 8 9 CodeBuilder IntermediateState [METHOD] initOptions [RETURN_TYPE] void CompilerOptions options [VARIABLES] FunctionInformationMap functionInformationMap ErrorManager errorManager StringBuilder debugLog sb Config parserConfig Node externAndJsRoot externsRoot jsRoot PerformanceTracker tracker PassConfig passes String currentPassName externExports LifeCycleStage lifeCycleStage Logger logger PassFactory sanityCheck long COMPILER_STACK_SIZE serialVersionUID TypeValidator typeValidator JSTypeRegistry typeRegistry ErrorReporter defaultErrorReporter oldErrorReporter RecentChange recentChange GlobalVarReferenceMap globalRefMap PrintStreamErrorManager printer DiagnosticType DUPLICATE_EXTERN_INPUT DUPLICATE_INPUT EMPTY_MODULE_LIST_ERROR EMPTY_ROOT_MODULE_ERROR MISSING_ENTRY_ERROR MODULE_DEPENDENCY_ERROR MOTION_ITERATIONS_ERROR OPTIMIZE_LOOP_ERROR SourceMap sourceMap List codeChangeHandlers externs guards inputs modules WarningsGuard warningsGuard ReverseAbstractInterpreter abstractInterpreter PrintStream outStream stream Tracer currentTracer JSModuleGraph moduleGraph int colCount lineCount uniqueNameId boolean colorize hasRegExpGlobalReferences useThreads ComposeWarningsGuard composedGuards State passConfigState CodingConvention defaultCodingConvention CompilerOptions options Map inputsByName ", "output": "[PATCH] if (options.checkGlobalThisLevel.isOn() && !options.disables(DiagnosticGroups.GLOBAL_THIS)) { ", "bugid": "143"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testCall1 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: testCall1 [CONTEXT] nameNode.getLastChild().getString())) { return false; } if (callNode.isOnlyModifiesThisCall() && evaluatesToLocalValue(nameNode.getFirstChild())) { return false; }  [BUGGY] [BUGGY] if (compiler != null && !compiler.hasRegExpGlobalReferences()) { if (nameNode.getFirstChild().getType() == Token.REGEXP && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) { return false; } else if (nameNode.getFirstChild().getType() == Token.STRING && STRING_REGEXP_METHODS.contains( nameNode.getLastChild().getString())) { Node param = nameNode.getNext(); if (param != null && (param.getType() == Token.STRING [CLASS] NodeUtil NumbericResultPredicate BooleanResultPredicate MayBeStringResultPredicate VarCollector MatchNameNode MatchNodeType MatchDeclaration MatchNotFunction MatchShallowStatement [METHOD] functionCallHasSideEffects [RETURN_TYPE] boolean Node callNode AbstractCompiler compiler [VARIABLES] BooleanResultPredicate BOOLEAN_RESULT_PREDICATE AbstractCompiler compiler Set BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS CONSTRUCTORS_WITHOUT_SIDE_EFFECTS OBJECT_METHODS_WITHOUT_SIDEEFFECTS REGEXP_METHODS STRING_REGEXP_METHODS defines NumbericResultPredicate NUMBERIC_RESULT_PREDICATE boolean MayBeStringResultPredicate MAY_BE_STRING_PREDICATE Node callNode nameNode param String JSC_PROPERTY_NAME_FN childValue name rawJsString s value Map vars long MAX_POSITIVE_INTEGER_NUMBER longValue int c end nextSkipSlot nextSlot start type Predicate MATCH_NOT_FUNCTION ", "output": "[PATCH] if (nameNode.getFirstChild().getType() == Token.NAME) { String namespaceName = nameNode.getFirstChild().getString(); if (namespaceName.equals(\"Math\")) { return false; } } ", "bugid": "144"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure  testFormatErrorSpaceEndOfLine1 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   1, 10, FOO_TYPE); LightweightMessageFormatter formatter = formatter(\"assert (1;\"); assertEquals(\"javascript/complex.js:1: ERROR - error description here\\n\" +  \"assert (1;\\n\" +  \"    ^\\n\", formatter.formatError(error));", "input": "[BUG] [BUGGY] && 0 <= charno && charno < sourceExcerpt.length()) { [FE] ComparisonFailure  testFormatErrorSpaceEndOfLine1 [CONTEXT] if (excerpt.equals(LINE) [BUGGY]  && 0 <= charno && charno < sourceExcerpt.length()) { [BUGGY]  [CLASS] LightweightMessageFormatter LineNumberingFormatter [METHOD] format [RETURN_TYPE] String  ", "output": "[PATCH]  && 0 <= charno && charno <= sourceExcerpt.length()) { ", "bugid": "145"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<var x=\" testZero . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] case '\\0': sb.append(\"\\\\0\"); break; [FE] ComparisonFailure: expected:<var x=\" testZero [CONTEXT] CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { [BUGGY] case '\\0': sb.append(\"\\\\0\"); break; [BUGGY] case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { [CLASS] CodeGenerator Context [METHOD] strEscape [RETURN_TYPE] String String s char quote String doublequoteEscape String singlequoteEscape String backslashEscape CharsetEncoder outputCharsetEncoder [VARIABLES] Context BEFORE_DANGLING_ELSE IN_FOR_INIT_CLAUSE OTHER PRESERVE_BLOCK START_OF_EXPR STATEMENT context lhsContext rhsContext boolean StringBuilder sb char c quote CodeConsumer cc consumer String END_SCRIPT START_COMMENT backslashEscape doublequoteEscape s singlequoteEscape Map ESCAPED_JS_STRINGS CharsetEncoder outputCharsetEncoder int i char[] HEX_CHARS ", "output": "[PATCH] case '\\0': sb.append(\"\\\\000\"); break; ", "bugid": "146"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<1000> but was:<625> testGetTypedPercent5 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   public void testGetTypedPercent5() throws Exception { String js = \"/** @enum {number} */ keys = {A: 1,B: 2,C: 3};\"; assertEquals(100.0, getTypedPercent(js), 0.1);  }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: expected:<1000> but was:<625> testGetTypedPercent5 [CONTEXT] break; case Token.NUMBER: ensureTyped(t, n, NUMBER_TYPE); break; case Token.STRING: if (!NodeUtil.isObjectLitKey(n, n.getParent())) { ensureTyped(t, n, STRING_TYPE); } [BUGGY] [BUGGY] break; case Token.GET: case Token.SET: break; case Token.ARRAYLIT: ensureTyped(t, n, ARRAY_TYPE); [CLASS] TypeCheck [METHOD] visit [RETURN_TYPE] void NodeTraversal t Node n Node parent [VARIABLES] ReverseAbstractInterpreter reverseInterpreter JSType caseType childType leftType leftTypeRestricted rightType rightTypeRestricted switchType NodeTraversal t DiagnosticGroup ALL_DIAGNOSTICS CheckLevel reportMissingOverride reportUnknownTypes Node child key left n parent right ScopeCreator scopeCreator String OVERRIDING_PROTOTYPE_WITH_NON_OBJECT functionPrivateName message TernaryValue result int noTypeCheckSection nullCount typedCount unknownCount TypeValidator validator AbstractCompiler compiler JSTypeRegistry typeRegistry boolean enterSection externs inExterns report reportMissingProperties typeable Scope outerScope topScope DiagnosticType BAD_DELETE BAD_IMPLEMENTED_TYPE BIT_OPERATION CONFLICTING_EXTENDED_TYPE CONFLICTING_IMPLEMENTED_TYPE CONSTRUCTOR_NOT_CALLABLE DETERMINISTIC_TEST DETERMINISTIC_TEST_NO_RESULT ENUM_DUP ENUM_NOT_CONSTANT EXPECTED_THIS_TYPE FUNCTION_MASKS_VARIABLE HIDDEN_INTERFACE_PROPERTY HIDDEN_SUPERCLASS_PROPERTY HIDDEN_SUPERCLASS_PROPERTY_MISMATCH ILLEGAL_IMPLICIT_CAST INCOMPATIBLE_EXTENDED_PROPERTY_TYPE INEXISTENT_ENUM_ELEMENT INEXISTENT_PROPERTY INTERFACE_FUNCTION_NOT_EMPTY INTERFACE_METHOD_OVERRIDE INVALID_INTERFACE_MEMBER_DECLARATION MULTIPLE_VAR_DEF NOT_A_CONSTRUCTOR NOT_CALLABLE UNEXPECTED_TOKEN UNKNOWN_EXPR_TYPE UNKNOWN_OVERRIDE UNRESOLVED_TYPE WRONG_ARGUMENT_COUNT diagnosticType InferJSDocInfo inferJSDocInfo ", "output": "[PATCH] } else { typeable = false; ", "bugid": "147"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testAliasing7 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  // An exported alias must preserved any referenced values in the // referenced function. testSame(\"function e(){}\" + \"e.prototype['alias1'] = e.prototype.method1 = \" +  \"function(){this.method2()};\" +", "input": "[BUG] [BUGGY] if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP) { [FE] AssertionFailedError: testAliasing7 [CONTEXT] private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); [BUGGY] if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP) { [BUGGY] boolean isChainedProperty = n.getFirstChild().getType() == Token.GETPROP; if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.getType() == Token.STRING && child.getString().equals(\"prototype\")) { return true; [CLASS] AnalyzePrototypeProperties ProcessProperties ProcessExternProperties PropagateReferences SymbolType GlobalFunction AssignmentProperty LiteralProperty NameContext NameInfo [METHOD] isPrototypePropertyAssign [RETURN_TYPE] boolean Node assign [VARIABLES] Set IMPLICITLY_USED_PROPERTIES Node assign child exprNode externRoot gramps key map n nameNode node parent propNameNode root value LinkedDirectedGraph symbolGraph String name propName property Deque declarations JSModuleGraph moduleGraph Stack symbolStack AbstractCompiler compiler boolean anchorUnusedVars canModifyExterns isChainedProperty readClosureVariables referenced NameInfo anonymousNode def externNode globalNode info name nameInfo Scope scope JSModule deepestCommonModuleRef firstModule module SymbolType PROPERTY VAR type Map map propertyNameInfo varNameInfo ", "output": "[PATCH] if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP && assign.getParent().getType() == Token.EXPR_RESULT) { ", "bugid": "148"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected a warning testThisTypeOfFunction2 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: expected a warning testThisTypeOfFunction2 [CONTEXT] if (functionType.isConstructor() && !functionType.isNativeObjectType() && (functionType.getReturnType().isUnknownType() || functionType.getReturnType().isVoidType() || !isExtern)) { report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString()); }  [BUGGY] [BUGGY] visitParameterList(t, n, functionType); ensureTyped(t, n, functionType.getReturnType()); } else { ensureTyped(t, n); }  } [CLASS] TypeCheck [METHOD] visitCall [RETURN_TYPE] void NodeTraversal t Node n [VARIABLES] ReverseAbstractInterpreter reverseInterpreter JSType childType NodeTraversal t DiagnosticGroup ALL_DIAGNOSTICS CheckLevel reportMissingOverride reportUnknownTypes Node child n FunctionType functionType ScopeCreator scopeCreator String OVERRIDING_PROTOTYPE_WITH_NON_OBJECT abstractMethodMessage abstractMethodName functionName functionPrivateName message name prop propName property property2 propertyName sourceName JSDocInfo functionJSDocInfo int noTypeCheckSection nullCount parentNodeType typedCount unknownCount TypeValidator validator AbstractCompiler compiler JSTypeRegistry typeRegistry CompilerInput functionSource boolean badImplementedType declaredOverride enterSection externs foundInterfaceProperty inExterns interfaceHasProperty isExtern report reportMissingProperties superClassHasProperty superInterfacesHasProperty typeable valid Scope outerScope topScope DiagnosticType BAD_DELETE BAD_IMPLEMENTED_TYPE BIT_OPERATION CONFLICTING_EXTENDED_TYPE CONFLICTING_IMPLEMENTED_TYPE CONSTRUCTOR_NOT_CALLABLE DETERMINISTIC_TEST DETERMINISTIC_TEST_NO_RESULT ENUM_DUP ENUM_NOT_CONSTANT EXPECTED_THIS_TYPE FUNCTION_MASKS_VARIABLE HIDDEN_INTERFACE_PROPERTY HIDDEN_SUPERCLASS_PROPERTY HIDDEN_SUPERCLASS_PROPERTY_MISMATCH ILLEGAL_IMPLICIT_CAST INCOMPATIBLE_EXTENDED_PROPERTY_TYPE INEXISTENT_ENUM_ELEMENT INEXISTENT_PROPERTY INTERFACE_FUNCTION_NOT_EMPTY INTERFACE_METHOD_OVERRIDE INVALID_INTERFACE_MEMBER_DECLARATION MULTIPLE_VAR_DEF NOT_A_CONSTRUCTOR NOT_CALLABLE UNEXPECTED_TOKEN UNKNOWN_EXPR_TYPE UNKNOWN_OVERRIDE UNRESOLVED_TYPE WRONG_ARGUMENT_COUNT diagnosticType InferJSDocInfo inferJSDocInfo ", "output": "[PATCH] if (functionType.isOrdinaryFunction() && !functionType.getTypeOfThis().isUnknownType() && !functionType.getTypeOfThis().isNativeObjectType() && !(child.getType() == Token.GETELEM || child.getType() == Token.GETPROP)) { report(t, n, EXPECTED_THIS_TYPE, functionType.toString()); } ", "bugid": "149"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<2> but was:<1> testDuplicateLocalVarDecl . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] jsDocParameter.getJSType(), true); [FE] AssertionFailedError: expected:<2> but was:<1> testDuplicateLocalVarDecl [CONTEXT] Node astParameters = functionNode.getFirstChild().getNext(); Node body = astParameters.getNext(); FunctionType functionType = (FunctionType) functionNode.getJSType(); if (functionType != null) { Node jsDocParameters = functionType.getParametersNode(); if (jsDocParameters != null) { Node jsDocParameter = jsDocParameters.getFirstChild(); for (Node astParameter : astParameters.children()) { if (jsDocParameter != null) { defineSlot(astParameter, functionNode, [BUGGY] jsDocParameter.getJSType(), true); [BUGGY] jsDocParameter = jsDocParameter.getNext(); } else { defineSlot(astParameter, functionNode, null, true); } } } } } [CLASS] TypedScopeCreator DeferredSetType DiscoverEnumsAndTypedefs AbstractScopeBuilder CollectProperties StubDeclaration GlobalScopeBuilder LocalScopeBuilder [METHOD] declareArguments [RETURN_TYPE] void Node functionNode [VARIABLES] JSType delegateType elementsType jsType keyType knownType ownerTypeOfThis ownerVarType propType realType t type valueType Node astParameter astParameters body candidate catchName child errorRoot firstChild firstClause fnBlock fnNameNode fnNode fnRoot functionNode initialValue jsDocParameter jsDocParameters key keyNode lValue lValueNode lvalueNode maybeOwner member n name nameNode node nodeWithJsDocInfo objLit objNode objectLit ownerNode parametersNode parent rValue rhsValue root secondClause value valueNode var FunctionType functionType String DELEGATE_PROXY_SUFFIX LEGACY_TYPEDEF delegateName fnName functionName keyName lValueName lendsName memberName name ownerName propName qName qualifiedName singletonGetterClassName slotName sourceName typedef variableName TypeValidator validator ObjectType delegateBaseObject delegateSuperObject delegatorObject fnThisType globalThis iface objLitType objectType ownerType subClass superClass thisType type unknownType AbstractCompiler compiler ErrorReporter typeParsingErrorReporter JSTypeRegistry registry typeRegistry boolean createdEnumType descend inferred isExtern isFnLiteral isGlobalVar isValidValue namesMatch searchedForThisType shouldDeclareOnGlobalThis Scope globalScope newScope parent s scope scopeToDeclareIn DiagnosticType CONSTRUCTOR_EXPECTED CTOR_INITIALIZER ENUM_INITIALIZER IFACE_INITIALIZER LENDS_ON_NON_OBJECT MALFORMED_TYPEDEF UNKNOWN_LENDS CodingConvention codingConvention List deferredSetTypes delegateProxyPrototypes nonExternFunctions stubDeclarations ", "output": "[PATCH] jsDocParameter.getJSType(), false); ", "bugid": "150"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Overriding private property of Fooprototype testNoPrivateAccessForProperties6 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  // Overriding a private property with a non-private property // in a different file causes problems. test(new String[] {   \"/** @constructor */ function Foo() {} \" +   \"/** @private */ Foo.prototype.bar_ = function() {};\",", "input": "[BUG] [BUGGY] boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop; [FE] AssertionFailedError: Overriding private property of Fooprototype testNoPrivateAccessForProperties6 [CONTEXT] Node getprop, Node parent) { ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType())); String propertyName = getprop.getLastChild().getString(); if (objectType != null) {  [BUGGY] boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop; [BUGGY]  if (isOverride) { objectType = objectType.getImplicitPrototype(); } JSDocInfo docInfo = null; for (; objectType != null; [CLASS] CheckAccessControls [METHOD] checkPropertyVisibility [RETURN_TYPE] void NodeTraversal t Node getprop Node parent [VARIABLES] JSType currentClass lValueType ownerType type NodeTraversal t Node getprop parent String propertyName JSDocInfo docInfo overridingInfo int deprecatedDepth methodDepth TypeValidator validator Multimap initializedConstantProperties ObjectType objectType AbstractCompiler compiler boolean isOverride sameInput DiagnosticType BAD_PRIVATE_GLOBAL_ACCESS BAD_PRIVATE_PROPERTY_ACCESS BAD_PROTECTED_PROPERTY_ACCESS CONST_PROPERTY_REASSIGNED_VALUE DEPRECATED_CLASS DEPRECATED_CLASS_REASON DEPRECATED_NAME DEPRECATED_NAME_REASON DEPRECATED_PROP DEPRECATED_PROP_REASON PRIVATE_OVERRIDE VISIBILITY_MISMATCH Visibility overridingVisibility visibility ", "output": "[PATCH] boolean isOverride = parent.getJSDocInfo() != null && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop; ", "bugid": "151"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<var x=\"[ testUnicode . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  assertPrint(\"var x ='\\\\x0f';\", \"var x=\\\"\\\\u000f\\\"\"); assertPrint(\"var x ='\\\\x68';\", \"var x=\\\"h\\\"\"); assertPrint(\"var x ='\\\\x7f';\", \"var x=\\\"\\\\u007f\\\"\");  }", "input": "[BUG] [BUGGY] if (c > 0x1f && c <= 0x7f) { [FE] ComparisonFailure: expected:<var x=\"[ testUnicode [CONTEXT] if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else {  [BUGGY] if (c > 0x1f && c <= 0x7f) { [BUGGY] sb.append(c); } else {  appendHexJavaScriptRepresentation(sb, c); } } [CLASS] CodeGenerator Context [METHOD] strEscape [RETURN_TYPE] String String s char quote String doublequoteEscape String singlequoteEscape String backslashEscape CharsetEncoder outputCharsetEncoder [VARIABLES] Context BEFORE_DANGLING_ELSE IN_FOR_INIT_CLAUSE OTHER PRESERVE_BLOCK START_OF_EXPR STATEMENT context lhsContext rhsContext boolean StringBuilder sb char c quote CodeConsumer cc consumer String END_SCRIPT START_COMMENT backslashEscape doublequoteEscape s singlequoteEscape CharsetEncoder outputCharsetEncoder int i char[] HEX_CHARS ", "output": "[PATCH] if (c > 0x1f && c < 0x7f) { ", "bugid": "152"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<var x=\" testZero . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] [FE] ComparisonFailure: expected:<var x=\" testZero [CONTEXT] CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { [BUGGY] [BUGGY] case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); [CLASS] CodeGenerator Context [METHOD] strEscape [RETURN_TYPE] String String s char quote String doublequoteEscape String singlequoteEscape String backslashEscape CharsetEncoder outputCharsetEncoder [VARIABLES] Context BEFORE_DANGLING_ELSE IN_FOR_INIT_CLAUSE OTHER PRESERVE_BLOCK START_OF_EXPR STATEMENT context lhsContext rhsContext boolean StringBuilder sb char c quote CodeConsumer cc consumer String END_SCRIPT START_COMMENT backslashEscape doublequoteEscape s singlequoteEscape CharsetEncoder outputCharsetEncoder int i char[] HEX_CHARS ", "output": "[PATCH] case '\\0': sb.append(\"\\\\0\"); break; ", "bugid": "153"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testUnnamedFunctionStatement . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   public void testUnnamedFunctionStatement() { // Statements parseError(\"function() {};\", \"unnamed function statement\"); parseError(\"if (true) { function() {}; }\", \"unnamed function statement\"); parse(\"function f() {};\");", "input": "[BUG] [BUGGY] [FE] AssertionFailedError testUnnamedFunctionStatement [CONTEXT] Node processFunctionNode(FunctionNode functionNode) { Name name = functionNode.getFunctionName(); Boolean isUnnamedFunction = false; if (name == null) { [BUGGY] [BUGGY] name = new Name(); name.setIdentifier(\"\"); isUnnamedFunction = true; } Node node = newNode(Token.FUNCTION); Node newName = transform(name); if (isUnnamedFunction) {  newName.setLineno(functionNode.getLineno()); [CLASS] IRFactory TransformDispatcher [METHOD] processFunctionNode [RETURN_TYPE] Node FunctionNode functionNode [VARIABLES] Set ALLOWED_DIRECTIVES directives Config config Node assign bodyNode c child irNode labelName lp n newBlock newName node ret rootNodeJsDocHolder target templateNode FunctionNode functionNode FileLevelJsDocBuilder fileLevelJsDocBuilder String comment directive sourceName sourceString JSDocInfo fileOverviewInfo jsDocInfo int lpColumn lparenCharno Name fnName name ErrorReporter errorReporter boolean TransformDispatcher transformDispatcher Boolean isUnnamedFunction AstNode param ", "output": "[PATCH] int functionType = functionNode.getFunctionType(); if (functionType != FunctionNode.FUNCTION_EXPRESSION) { errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(),\"\", 0); } ", "bugid": "154"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected a warning testIssue301 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] return isNoType() || isNoObjectType() || isNoResolvedType(); [FE] AssertionFailedError: expected a warning testIssue301 [CONTEXT] public final boolean isEmptyType() { [BUGGY] return isNoType() || isNoObjectType() || isNoResolvedType(); [BUGGY] } [CLASS] JSType 1 TypePair [METHOD] isEmptyType [RETURN_TYPE] boolean [VARIABLES] JSTypeRegistry registry boolean resolved JSType resolveResult t1 t2 typeA typeB String EMPTY_TYPE_COMPONENT NOT_A_CLASS NOT_A_TYPE UNKNOWN_NAME displayName long serialVersionUID int ENUMDECL NOT_ENUMDECL Comparator ALPHA ", "output": "[PATCH] return isNoType() || isNoObjectType() || isNoResolvedType() || (registry.getNativeFunctionType( JSTypeNative.LEAST_FUNCTION_TYPE) == this); ", "bugid": "155"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testVersionFlag2 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   public void testVersionFlag2() { lastArg = \"--version\"; testSame(\"\"); assertEquals(  0,", "input": "[BUG] [BUGGY] String param = params.getParameter(0); [FE] AssertionFailedError testVersionFlag2 [CONTEXT] public int parseArguments(Parameters params) throws CmdLineException { [BUGGY] String param = params.getParameter(0); [BUGGY] if (param == null) { setter.addValue(true); return 0; } else { String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); [CLASS] CommandLineRunner Flags BooleanOptionHandler FormattingOption [METHOD] parseArguments [RETURN_TYPE] int Parameters params [VARIABLES] CompilationLevel compilation_level boolean compute_phase_ordering create_name_map_files debug display_help isConfigValid manage_closure_dependencies print_ast print_pass_graph print_tree process_closure_primitives third_party use_only_custom_externs version Set FALSES TRUES Parameters params WarningLevel warning_level FormattingOption PRETTY_PRINT PRINT_INPUT_DELIMITER List DEFAULT_EXTERNS_NAMES closure_entry_point define externs formatting js jscomp_error jscomp_off jscomp_warning module module_wrapper String charset configResource create_source_map js_output_file logging_level lowerParam module_output_path_prefix output_manifest output_wrapper output_wrapper_marker param property_map_input_file property_map_output_file variable_map_input_file variable_map_output_file Flags flags DevMode jscomp_dev_mode int summary_detail_level ", "output": "[PATCH] String param = null; try { param = params.getParameter(0); } catch (CmdLineException e) {} ", "bugid": "156"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testLocalValue1 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  assertFalse(testLocalValue(\"x()\")); assertFalse(testLocalValue(\"this\")); assertFalse(testLocalValue(\"arguments\")); // We can't know if new objects are local unless we know", "input": "[BUG] [BUGGY] return true; [FE] AssertionFailedError testLocalValue1 [CONTEXT] return locals.apply(value); case Token.CALL: return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value); case Token.NEW:  [BUGGY] return true; [BUGGY] case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT: case Token.OBJECTLIT: return true; case Token.IN: return true; default: [CLASS] NodeUtil VarCollector MatchNameNode MatchNodeType MatchDeclaration MatchNotFunction MatchShallowStatement [METHOD] evaluatesToLocalValue [RETURN_TYPE] boolean Node value Node> locals [VARIABLES] Set BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS CONSTRUCTORS_WITHOUT_SIDE_EFFECTS OBJECT_METHODS_WITHOUT_SIDEEFFECTS REGEXP_METHODS STRING_REGEXP_METHODS defines emptySet knownConstants boolean Node value String JSC_PROPERTY_NAME_FN lhsString methodName name namespaceName originalName part propName qNameStr res s sourceName Map vars int charno endPos index len lineno memberIndex operator prototypeIdx startPos total type Predicate locals ", "output": "[PATCH] return false; ", "bugid": "157"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Unexpected error(s): JSC_USED_GLOBAL_THIS dangerous use of the global this object at testcode line 1 : 110 expected:<0> but was:<1> testLendsAnnotation3 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: Unexpected error(s): JSC_USED_GLOBAL_THIS dangerous use of the global this object at testcode line 1 : 110 expected:<0> but was:<1> testLendsAnnotation3 [CONTEXT] pType == Token.NAME || pType == Token.ASSIGN || pType == Token.STRING || pType == Token.NUMBER)) { return false; }  [BUGGY] [BUGGY] } if (parent != null && parent.getType() == Token.ASSIGN) { Node lhs = parent.getFirstChild(); Node rhs = lhs.getNext(); if (n == lhs) {  if (assignLhsChild == null) { [CLASS] CheckGlobalThis [METHOD] shouldTraverse [RETURN_TYPE] boolean NodeTraversal t Node n Node parent [VARIABLES] AbstractCompiler compiler boolean NodeTraversal t DiagnosticType GLOBAL_THIS CheckLevel level Node assignLhsChild lhs llhs n parent rhs JSDocInfo jsDoc int pType ", "output": "[PATCH] if (NodeUtil.isObjectLitKey(parent, gramps)) { JSDocInfo maybeLends = gramps.getJSDocInfo(); if (maybeLends != null && maybeLends.getLendsName() != null && maybeLends.getLendsName().endsWith(\".prototype\")) { return false; } } ", "bugid": "158"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testProvideInIndependentModules4 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  // Regression test for bug 261: // http://code.google.com/p/closure-compiler/issues/detail?id=261 test(  createModuleStar(   \"goog.provide('apps');\",", "input": "[BUG] [BUGGY] int indexOfDot = namespace.indexOf('.'); [FE] AssertionFailedError: testProvideInIndependentModules4 [CONTEXT] if (firstModule == minimumModule) { firstNode.getParent().addChildBefore(replacementNode, firstNode); } else { [BUGGY] int indexOfDot = namespace.indexOf('.'); [BUGGY] if (indexOfDot == -1) { compiler.getNodeForCodeInsertion(minimumModule) .addChildToBack(replacementNode); } else { ProvidedName parentName = providedNames.get(namespace.substring(0, indexOfDot)); Preconditions.checkNotNull(parentName); Preconditions.checkNotNull(parentName.replacementNode); [CLASS] ProcessClosurePrimitives 1 ProvidedName UnrecognizedRequire [METHOD] replace [RETURN_TYPE] void [VARIABLES] Set exportedVariables CheckLevel requiresLevel ProvidedName parentName Node arg assignNode baseClassNode callGoogNow callNode callee candidateDefinition className date enclosingFnNameNode enclosingParent explicitNode expr externs firstNode googNow key left maybeInheritsExpr methodName methodNameNode n name nameNode node parent replacementNode requireNode root scopeRoot thisArg value valueNode varNode String GOOG enclosingQname ending extraMessage googNowQName inputName methodName name namespace ns part prefixNs typeDecl value JSModuleGraph moduleGraph int indexOfDot AbstractCompiler compiler boolean explicit isExpr rewriteNewDateGoogNow DiagnosticType BASE_CLASS_ERROR DUPLICATE_NAMESPACE_ERROR FUNCTION_NAMESPACE_ERROR INVALID_ARGUMENT_ERROR INVALID_PROVIDE_ERROR LATE_PROVIDE_ERROR MISSING_PROVIDE_ERROR NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR NULL_ARGUMENT_ERROR TOO_MANY_ARGUMENTS_ERROR XMODULE_REQUIRE_ERROR diagnostic error JSModule explicitModule firstModule minimumModule module newModule providedModule List typeDecls unrecognizedRequires Map cssNames providedNames ", "output": "[PATCH] int indexOfDot = namespace.lastIndexOf('.'); ", "bugid": "159"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected a warning testFunctionArguments16 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] while (arguments.hasNext() && parameters.hasNext()) { [FE] AssertionFailedError: expected a warning testFunctionArguments16 [CONTEXT] FunctionType functionType) { Iterator<Node> arguments = call.children().iterator(); arguments.next(); Iterator<Node> parameters = functionType.getParameters().iterator(); int ordinal = 0; Node parameter = null; Node argument = null; [BUGGY] while (arguments.hasNext() && parameters.hasNext()) { [BUGGY]  parameter = parameters.next(); argument = arguments.next(); ordinal++; validator.expectArgumentMatchesParameter(t, argument, getJSType(argument), getJSType(parameter), call, ordinal); } [CLASS] TypeCheck [METHOD] visitParameterList [RETURN_TYPE] void NodeTraversal t Node call FunctionType functionType [VARIABLES] ReverseAbstractInterpreter reverseInterpreter NodeTraversal t DiagnosticGroup ALL_DIAGNOSTICS CheckLevel reportMissingOverride reportUnknownTypes Node argument call parameter FunctionType functionType ScopeCreator scopeCreator String OVERRIDING_PROTOTYPE_WITH_NON_OBJECT abstractMethodMessage abstractMethodName functionPrivateName message prop propName property property2 propertyName int maxArgs minArgs noTypeCheckSection nullCount numArgs ordinal parentNodeType typedCount unknownCount TypeValidator validator AbstractCompiler compiler JSTypeRegistry typeRegistry boolean badImplementedType declaredOverride enterSection externs foundInterfaceProperty inExterns interfaceHasProperty report reportMissingProperties superClassHasProperty typeable Scope outerScope topScope DiagnosticType BAD_DELETE BAD_IMPLEMENTED_TYPE BIT_OPERATION CONFLICTING_EXTENDED_TYPE CONSTRUCTOR_NOT_CALLABLE DETERMINISTIC_TEST DETERMINISTIC_TEST_NO_RESULT ENUM_DUP ENUM_NOT_CONSTANT FUNCTION_MASKS_VARIABLE HIDDEN_INTERFACE_PROPERTY HIDDEN_INTERFACE_PROPERTY_MISMATCH HIDDEN_SUPERCLASS_PROPERTY HIDDEN_SUPERCLASS_PROPERTY_MISMATCH ILLEGAL_IMPLICIT_CAST INEXISTENT_ENUM_ELEMENT INEXISTENT_PROPERTY INTERFACE_FUNCTION_NOT_EMPTY INTERFACE_METHOD_OVERRIDE INVALID_INTERFACE_MEMBER_DECLARATION MULTIPLE_VAR_DEF NOT_A_CONSTRUCTOR NOT_CALLABLE UNEXPECTED_TOKEN UNKNOWN_EXPR_TYPE UNKNOWN_OVERRIDE UNRESOLVED_TYPE WRONG_ARGUMENT_COUNT diagnosticType Iterator arguments parameters InferJSDocInfo inferJSDocInfo ", "output": "[PATCH] while (arguments.hasNext() && (parameters.hasNext() || parameter != null && parameter.isVarArgs())) { if (parameters.hasNext()) { } ", "bugid": "160"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testFoldBitShifts . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  fold(\"x = 10 >>> 5\", \"x = 0\"); fold(\"x = -1 >>> 1\", \"x = 2147483647\"); // 0x7fffffff fold(\"x = -1 >>> 0\", \"x = 4294967295\"); // 0xffffffff fold(\"x = -2 >>> 0\", \"x = 4294967294\"); // 0xfffffffe", "input": "[BUG] [BUGGY] result = lvalInt >>> rvalInt; [FE] AssertionFailedError: testFoldBitShifts [CONTEXT] case Token.LSH: result = lvalInt << rvalInt; break; case Token.RSH: result = lvalInt >> rvalInt; break; case Token.URSH:  [BUGGY] result = lvalInt >>> rvalInt; [BUGGY] break; default: throw new AssertionError(\"Unknown shift operator:\" + Node.tokenToName(n.getType())); } Node newNumber = Node.newNumber(result); n.getParent().replaceChild(n, newNumber); reportCodeChange(); [CLASS] PeepholeFoldConstants [METHOD] tryFoldShift [RETURN_TYPE] Node Node n Node left Node right [VARIABLES] boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE DIVIDE_BY_0_ERROR FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum result resultDouble rval val int lvalInt rvalInt Node left n newNumber right ", "output": "[PATCH] long lvalLong = lvalInt & 0xffffffffL; result = lvalLong >>> rvalInt; ", "bugid": "161"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testProcessClosurePrimitives . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    \"var goog = {}; goog.dom = {};\"); args.add(\"--process_closure_primitives=false\"); testSame(\"var goog = {}; goog.provide('goog.dom');\");  }", "input": "[BUG] [BUGGY] if (flags.process_closure_primitives) { options.closurePass = true; } [FE] AssertionFailedError: testProcessClosurePrimitives [CONTEXT] level.setOptionsForCompilationLevel(options); if (flags.debug) { level.setDebugOptionsForCompilationLevel(options); } WarningLevel wLevel = flags.warning_level; wLevel.setOptionsForWarningLevel(options); for (FormattingOption formattingOption : flags.formatting) { formattingOption.applyToOptions(options); } [BUGGY] if (flags.process_closure_primitives) { options.closurePass = true; } [BUGGY] initOptionsFromFlags(options); return options; } [CLASS] CommandLineRunner Flags BooleanOptionHandler FormattingOption [METHOD] createOptions [RETURN_TYPE] CompilerOptions [VARIABLES] CompilationLevel compilation_level level boolean compute_phase_ordering create_name_map_files debug print_ast print_pass_graph print_tree process_closure_primitives third_party use_only_custom_externs Set FALSES TRUES WarningLevel wLevel warning_level FormattingOption PRETTY_PRINT PRINT_INPUT_DELIMITER formattingOption CompilerOptions options List define externs formatting js jscomp_error jscomp_off jscomp_warning module module_wrapper processedArgs String arg charset create_source_map js_output_file logging_level lowerParam module_output_path_prefix output_wrapper output_wrapper_marker param property_map_input_file property_map_output_file value variable_map_input_file variable_map_output_file Flags flags DevMode jscomp_dev_mode int summary_detail_level ", "output": "[PATCH] options.closurePass = flags.process_closure_primitives; ", "bugid": "162"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<NoObject> but was:<None> testGreatestSubtypeUnionTypes5 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   public void testGreatestSubtypeUnionTypes5() throws Exception { JSType errUnion = createUnionType(EVAL_ERROR_TYPE, URI_ERROR_TYPE); assertEquals(NO_OBJECT_TYPE,  errUnion.getGreatestSubtype(STRING_OBJECT_TYPE));  }", "input": "[BUG] [BUGGY] if (result != null) { [FE] AssertionFailedError: expected:<NoObject> but was:<None> testGreatestSubtypeUnionTypes5 [CONTEXT] if (that instanceof UnionType) { for (JSType otherAlternate : ((UnionType) that).alternates) { if (otherAlternate.isSubtype(this)) { builder.addAlternate(otherAlternate); } } } else if (that.isSubtype(this)) { builder.addAlternate(that); } JSType result = builder.build(); [BUGGY] if (result != null) { [BUGGY] return result; } else if (this.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE); } else { return getNativeType(JSTypeNative.NO_TYPE); } } [CLASS] UnionType [METHOD] meet [RETURN_TYPE] JSType JSType that [VARIABLES] Set alternates JSType alternate otherAlternate result that boolean UnionTypeBuilder builder long serialVersionUID ", "output": "[PATCH] if (!result.isNoType()) { ", "bugid": "163"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Expected no warnings or errors testGetMsgWiringNoWarnings . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   public void testGetMsgWiringNoWarnings() throws Exception { args.add(\"--compilation_level=ADVANCED_OPTIMIZATIONS\"); test(\"/** @desc A bad foo. */ var MSG_FOO = 1;\", \"\");  }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: Expected no warnings or errors testGetMsgWiringNoWarnings [CONTEXT] } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {   options.messageBundle = new EmptyMessageBundle(); [BUGGY] [BUGGY] } return options; } [CLASS] CommandLineRunner GuardLevel Flags BooleanOptionHandler WarningGuardErrorOptionHandler WarningGuardWarningOptionHandler WarningGuardOffOptionHandler WarningGuardSetter FormattingOption [METHOD] createOptions [RETURN_TYPE] CompilerOptions [VARIABLES] CompilationLevel compilationLevel level TracerMode tracerMode Set FALSES TRUES WarningLevel wLevel warningLevel CheckLevel level String arg charset commonJsEntryModule commonJsPathPrefix createSourceMap flagFile jsOutputFile languageIn line loggingLevel lowerParam moduleOutputPathPrefix name outputManifest outputModuleDependencies outputWrapper param propertyMapInputFile propertyMapOutputFile translationsFile translationsProject value variableMapInputFile variableMapOutputFile warningsWhitelistFile Flags flags IOException e int summaryDetailLevel boolean acceptConstKeyword angularPass createNameMapFiles debug displayHelp generateExports isConfigValid manageClosureDependencies onlyClosureDependencies printAst printPassGraph printTree processClosurePrimitives processCommonJsModules processJqueryPrimitives thirdParty transformAmdModules useOnlyCustomExterns useTypesForOptimization version Format sourceMapFormat FormattingOption PRETTY_PRINT PRINT_INPUT_DELIMITER SINGLE_QUOTES formattingOption Setter proxy setter CompilerOptions options List DEFAULT_EXTERNS_NAMES allJsInputs argsInFile arguments closureEntryPoint define externs extraAnnotationName formatting guardLevels js jscompError jscompOff jscompWarning lines module moduleWrapper previous processedArgs processedFileArgs tokens DevMode jscompDevMode ", "output": "[PATCH] options.setWarningLevel(JsMessageVisitor.MSG_CONVENTIONS, CheckLevel.OFF); ", "bugid": "164"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: extra warning: Bad type annotation type not recognized due to syntax error testStructuralConstructor2 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] return parseTypeName(token); [FE] AssertionFailedError: extra warning: Bad type annotation type not recognized due to syntax error testStructuralConstructor2 [CONTEXT] private Node parseContextTypeExpression(JsDocToken token) { [BUGGY] return parseTypeName(token); [BUGGY] } [CLASS] JsDocInfoParser ErrorReporterParser State ExtractionInfo ExtendedTypeInfo WhitespaceOption [METHOD] parseContextTypeExpression [RETURN_TYPE] Node JsDocToken token [VARIABLES] Set idGeneratorAnnotationKeywords modifies modifiesAnnotationKeywords suppressionNames suppressions Node associatedNode basicTypeExpr n templateNode typeAst typeExpr typeList typeNode JsDocTokenStream stream FileLevelJsDocBuilder fileLevelJsDocBuilder String annotationName author description fileOverview idgenKind line meaning messageArg messageId multilineText name paramDescription preserve reason reference returnDescription s string typeString version JSDocInfo fileOverviewJSDocInfo int charno endCharno endLineno i lineStartChar lineno numSpaces startCharno startLineno trimCount ErrorReporter errorReporter boolean JsDocToken NO_UNREAD_TOKEN token unreadToken WhitespaceOption PRESERVE SINGLE_LINE TRIM option ErrorReporterParser parser State NEXT_IS_ANNOTATION SEARCHING_ANNOTATION SEARCHING_NEWLINE state JSTypeExpression expr type JSDocInfoBuilder jsdocBuilder StaticSourceFile sourceFile Map annotationNames ", "output": "[PATCH] if (token == JsDocToken.QMARK) { return newNode(Token.QMARK); } else { return parseBasicTypeExpression(token); } ", "bugid": "165"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Expected: Array testGoogIsArray2 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] return topType; [FE] AssertionFailedError: Expected: Array testGoogIsArray2 [CONTEXT] protected JSType caseTopType(JSType topType) { [BUGGY] return topType; [BUGGY] } [CLASS] ClosureReverseAbstractInterpreter 1 2 3 4 13 12 11 10 9 8 7 6 5 TypeRestriction [METHOD] caseTopType [RETURN_TYPE] JSType JSType topType [VARIABLES] JSType topType type boolean outcome Visitor restrictToArrayVisitor restrictToNotArrayVisitor restrictToNotObjectVisitor restrictToObjectVisitor visitor Map restricters ", "output": "[PATCH] return topType.isAllType() ? getNativeType(ARRAY_TYPE) : topType; ", "bugid": "166"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: unexpected warnings(s): testIssue1058 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n); [FE] AssertionFailedError: unexpected warnings(s): testIssue1058 [CONTEXT] Node n, FunctionType fnType) { final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap() .getTemplateKeys(); if (keys.isEmpty()) { return false; }  [BUGGY] Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n); [BUGGY]  TemplateTypeReplacer replacer = new TemplateTypeReplacer( registry, inferred); Node callTarget = n.getFirstChild(); FunctionType replacementFnType = fnType.visit(replacer) [CLASS] TypeInference TemplateTypeReplacer BooleanOutcomePair [METHOD] inferTemplatedTypesForCall [RETURN_TYPE] boolean Node n FunctionType fnType [VARIABLES] ReverseAbstractInterpreter reverseInterpreter TemplateTypeReplacer replacer ImmutableList keys Node callTarget n FunctionType fnType replacementFnType BooleanLiteralSet booleanValues toBooleanOutcomes ObjectType objType objectType ownerType referencedParamType unknownType AbstractCompiler compiler JSTypeRegistry registry boolean isInferred isVarDeclaration leftIsUnknown madeChanges nonLocalInferredSlot propCreationInConstructor rightIsUnknown staticPropCreation unflowable updatedFnType Scope functionScope syntacticScope DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS Map assertionFunctionsMap inferred map replacements resolvedTypes FlowScope bottomScope conditionFlowScope falseScope functionScope informed input joinedScope leftScope newScope output rightScope scope trueScope ", "output": "[PATCH] Map<TemplateType, JSType> inferred = Maps.filterKeys( inferTemplateTypesFromParameters(fnType, n), new Predicate<TemplateType>() { @Override public boolean apply(TemplateType key) { return keys.contains(key); }} ); ", "bugid": "167"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: There should be one error required\"namespaceClass1\" namespace never provided testNoUndeclaredVarWhenUsingClosurePass . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  enableClosurePass(); // We don't want to get goog as an undeclared var here. test(\"goog.require('namespace.Class1');\\n\", null,  ProcessClosurePrimitives.MISSING_PROVIDE_ERROR);  }", "input": "[BUG] [BUGGY] if (provided != null) { [FE] AssertionFailedError: There should be one error required\"namespaceClass1\" namespace never provided testNoUndeclaredVarWhenUsingClosurePass [CONTEXT] } maybeAddToSymbolTable(left); maybeAddStringNodeToSymbolTable(arg);  [BUGGY] if (provided != null) { [BUGGY] parent.detachFromParent(); compiler.reportCodeChange(); } } } [CLASS] ProcessClosurePrimitives 1 ProvidedName UnrecognizedRequire [METHOD] processRequireCall [RETURN_TYPE] void NodeTraversal t Node n Node parent [VARIABLES] Set exportedVariables NodeTraversal t CheckLevel requiresLevel ProvidedName provided Node arg candidateDefinition explicitNode externs firstNode left n name node originalRoot parent replacement replacementNode requireNode root scriptRoot value PreprocessorSymbolTable preprocessorSymbolTable String GOOG inputName methodName name namespace ns typeDecl JSModuleGraph moduleGraph AbstractCompiler compiler boolean DiagnosticType BASE_CLASS_ERROR DUPLICATE_NAMESPACE_ERROR EXPECTED_OBJECTLIT_ERROR EXPECTED_STRING_ERROR FUNCTION_NAMESPACE_ERROR INVALID_ARGUMENT_ERROR INVALID_CSS_RENAMING_MAP INVALID_DEFINE_NAME_ERROR INVALID_PROVIDE_ERROR INVALID_STYLE_ERROR LATE_PROVIDE_ERROR MISSING_DEFINE_ANNOTATION MISSING_PROVIDE_ERROR NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR NULL_ARGUMENT_ERROR TOO_MANY_ARGUMENTS_ERROR XMODULE_REQUIRE_ERROR error JSModule explicitModule firstModule minimumModule module providedModule List defineCalls typeDecls unrecognizedRequires Map providedNames ", "output": "[PATCH] if (provided != null || requiresLevel.isOn()) { ", "bugid": "168"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testAssignWithCall . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   }", "input": "[BUG] [BUGGY] } else { [FE] AssertionFailedError: testAssignWithCall [CONTEXT] if (parent.getFirstChild().getNext() != n) { recordDepScope(recordNode, ns); } else { recordDepScope(nameNode, ns); } [CLASS] NameAnalyzer AliasSet RefType ReferencePropagationCallback NameInformation JsName JsNameRefNode PrototypeSetNode SpecialReferenceNode ClassDefiningFunctionNode InstanceOfCheckNode ProcessExternals FindDependencyScopes HoistVariableAndFunctionDeclarations FindDeclarationsAndSetters 1 FindReferences NodeAccumulator RemoveListener TriState [METHOD] recordAssignment [RETURN_TYPE] void NodeTraversal t Node n Node recordNode [VARIABLES] NameInformation ns Set DEFAULT_GLOBAL_NAMES externalNames globalNames names nodesToKeep NodeTraversal t Node callNode containingNode gramps n nameNode node parent recordNode String FUNCTION PROTOTYPE_SUBSTRING WINDOW name name1 name2 prototypeClass prototypeProperty superclass int PROTOTYPE_SUBSTRING_LEN PROTOTYPE_SUFFIX_LEN Predicate NON_LOCAL_RESULT_PREDICATE RefType INHERITANCE REGULAR callSite AbstractCompiler compiler boolean externallyDefined hasInstanceOfReference hasWrittenDescendants isExternallyReferenceable isPrototype onlyAffectsClassDef referenced removeUnreferenced JsName from jsName name rhs to List prototypeNames refNodes DiGraph referenceGraph TriState BOTH FALSE TRUE ListMultimap scopes Map aliases allNames AstChangeProxy changeProxy ", "output": "[PATCH] } else if (!(parent.isCall() && parent.getFirstChild() == n)) {  ", "bugid": "169"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<{[]}> but was:<{[a=[[Fooprototype]]]}> testOneType4 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   + \"F['a'] = 0;\"; String expected = \"{}\"; testSets(false, js, js, expected); testSets(true, js, js, expected);  }", "input": "[BUG] [BUGGY] [FE] ComparisonFailure: expected:<{[]}> but was:<{[a=[[Fooprototype]]]}> testOneType4 [CONTEXT] private void handleObjectLit(NodeTraversal t, Node n) { for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { [BUGGY] [BUGGY] String name = child.getString(); T type = typeSystem.getType(getScope(), n, name); Property prop = getProperty(name); if (!prop.scheduleRenaming(child, processProperty(t, prop, type, null))) {  if (propertiesToErrorFor.containsKey(name)) { [CLASS] DisambiguateProperties Warnings Property AbstractScopingCallback FindExternProperties FindRenameableProperties JSTypeSystem ConcreteTypeSystem [METHOD] handleObjectLit [RETURN_TYPE] void NodeTraversal t Node n [VARIABLES] TypeSystem typeSystem Set allTypes invalidatingTypes newTypesToSkip renameNodes rootTypesToSkip typesToSkip NodeTraversal t Node child n UnionFind types String field name qName suggestion Logger logger int MAX_INVALDIATION_WARNINGS_PER_PROPERTY count nextUniqueId originalTypesSize TightenTypes tt Stack scopes Multimap invalidationMap AbstractCompiler compiler JSTypeRegistry registry boolean changed skipRenaming T type DiagnosticType INVALIDATION INVALIDATION_ON_TYPE CodingConvention codingConvention convention JSTypeNative[] nativeTypes Map properties propertiesToErrorFor rootTypes Property prop ", "output": "[PATCH] if (child.isQuotedString()) { continue; } ", "bugid": "170"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Unexpected warning(s): JSC_UNDEFINED_NAME e is never defined at testcode line 1 : 48 testGlobalCatch . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: Unexpected warning(s): JSC_UNDEFINED_NAME e is never defined at testcode line 1 : 48 testGlobalCatch [CONTEXT] case Token.GETPROP: return; case Token.FUNCTION: Node gramps = parent.getParent(); if (gramps == null || NodeUtil.isFunctionExpression(parent)) { return; } isSet = true; type = Name.Type.FUNCTION; break; [BUGGY] [BUGGY] case Token.INC: case Token.DEC: isSet = true; type = Name.Type.OTHER; break; default: if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) { isSet = true; type = Name.Type.OTHER; } [CLASS] GlobalNamespace AstChange BuildGlobalNamespace Name Type Ref Type Tracker [METHOD] collect [RETURN_TYPE] void JSModule module Scope scope Node n [VARIABLES] PrintStream stream Set previousSymbolsInTree Node externsRoot gramps n node parent root rvalue String baseName name topVarName JSDocInfo docInfo int aliasingGets callGets currentPreOrderIndex deleteProps firstDotIndex globalSets index localSets preOrderIndex totalGets Name name parent slot Predicate isInterestingSymbol AbstractCompiler compiler Type ALIASING_GET CALL_GET DELETE_PROP DIRECT_GET FUNCTION GET OBJECTLIT OTHER PROTOTYPE_GET SET SET_FROM_GLOBAL SET_FROM_LOCAL type Ref declaration original twin boolean declaredType generated hasDeclaredTypeDescendant inExterns isPropAssign isSet Scope externsScope s scope JSModule module List globalNames newNodes props refs StaticSourceFile source Map nameMap ", "output": "[PATCH] case Token.CATCH: ", "bugid": "171"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testExternalIssue1053 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: testExternalIssue1053 [CONTEXT] boolean isAssignedOnceInLifetime() { Reference ref = getOneAndOnlyAssignment(); if (ref == null) { return false; } for (BasicBlock block = ref.getBasicBlock(); block != null; block = block.getParent()) { if (block.isFunction) { [BUGGY] [BUGGY] break; } else if (block.isLoop) { return false; } } return true; } [CLASS] ReferenceCollectingCallback ReferenceMapWrapper 1 ReferenceCollection Reference BasicBlock [METHOD] isAssignedOnceInLifetime [RETURN_TYPE] boolean [VARIABLES] Set DECLARATION_PARENTS Reference ref Node externs n nameNode originalRoot parent root scriptRoot BasicBlock basicBlock block initBlock parent Deque blockStack Predicate varFilter AbstractCompiler compiler boolean isFunction isHoisted isLoop Scope scope InputId inputId List references Behavior DO_NOTHING_BEHAVIOR behavior StaticSourceFile sourceFile Map referenceMap ", "output": "[PATCH] if (ref.getSymbol().getScope() != ref.scope) { return false; } ", "bugid": "172"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testSuspiciousBlockCommentWarning3 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   }", "input": "[BUG] [BUGGY] if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\\\n * @\") != -1) { [FE] AssertionFailedError testSuspiciousBlockCommentWarning3 [CONTEXT] private void handleBlockComment(Comment comment) { [BUGGY] if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) { [BUGGY] errorReporter.warning( SUSPICIOUS_COMMENT_WARNING, sourceName, comment.getLineno(),\"\", 0); } } [CLASS] IRFactory TransformDispatcher [METHOD] handleBlockComment [RETURN_TYPE] void Comment comment [VARIABLES] Comment comment ErrorReporter errorReporter Set parsedComments reservedKeywords boolean ImmutableSet ALLOWED_DIRECTIVES ES5_RESERVED_KEYWORDS ES5_STRICT_RESERVED_KEYWORDS Config config Node irNode newBlock rootNodeJsDocHolder templateNode FileLevelJsDocBuilder fileLevelJsDocBuilder String GETTER_ERROR_MESSAGE INVALID_ES3_PROP_NAME MISPLACED_TYPE_ANNOTATION SETTER_ERROR_MESSAGE SUSPICIOUS_COMMENT_WARNING sourceName sourceString StaticSourceFile sourceFile TransformDispatcher transformDispatcher JSDocInfo fileOverviewInfo rootNodeJsDoc ", "output": "[PATCH] Pattern p = Pattern.compile(\"(/|(\\\\n[ \\\\t]*))\\\\\\\\*[ \\\\t]*@[a-zA-Z]\"); if (p.matcher(comment.getValue()).find()) { ", "bugid": "173"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<for(a=c?0:[(0 in d)];;)foo()> but was:<for(a=c?0:[0 in d];;)foo()> testPrintInOperatorInForLoop . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  // And in operator inside a hook. assertPrintSame(\"for(a=c?0:(0 in d);;)foo()\");  }", "input": "[BUG] [BUGGY] Context rhsContext = Context.OTHER; [FE] ComparisonFailure: expected:<for(a=c?0:[(0 in d)];;)foo()> but was:<for(a=c?0:[0 in d];;)foo()> testPrintInOperatorInForLoop [CONTEXT] cc.addOp(NodeUtil.opToStrNoFail(type), false); addExpr(first, NodeUtil.precedence(type), Context.OTHER); } break; } case Token.HOOK: { Preconditions.checkState(childCount == 3); int p = NodeUtil.precedence(type); [BUGGY] Context rhsContext = Context.OTHER; [BUGGY] addExpr(first, p + 1, context); cc.addOp(\"?\", true); addExpr(first.getNext(), 1, rhsContext); cc.addOp(\":\", true); addExpr(last, 1, rhsContext); break; } case Token.REGEXP: if (!first.isString() || [CLASS] CodeGenerator Context [METHOD] add [RETURN_TYPE] void Node n Context context [VARIABLES] Context BEFORE_DANGLING_ELSE IN_FOR_INIT_CLAUSE OTHER PRESERVE_BLOCK START_OF_EXPR STATEMENT context rhsContext LanguageMode languageMode boolean ambiguousElseClause funcNeedsParens hasElse needsParens preferLineBreaks preferSingleQuotes preserveBlock trustedStrings double d Node body c catchblock first fn last n next parameters CodeConsumer cc consumer String GT_ESCAPED LT_ESCAPED identifier key name o opstr regexp str Map escapedJsStrings CharsetEncoder outputCharsetEncoder int childCount p postProp precedence type char[] HEX_CHARS ", "output": "[PATCH] Context rhsContext = getContextForNoInOperator(context); ", "bugid": "174"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testIssue1017 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   }", "input": "[BUG] [BUGGY] node = node.getFirstChild(); [FE] AssertionFailedError: testIssue1017 [CONTEXT] private boolean isSafeReplacement(Node node, Node replacement) { if (node.isName()) { return true; } Preconditions.checkArgument(node.isGetProp()); [BUGGY] node = node.getFirstChild(); [BUGGY] if (node.isName() && isNameAssignedTo(node.getString(), replacement)) { return false; } return true; } [CLASS] ExploitAssigns [METHOD] isSafeReplacement [RETURN_TYPE] boolean Node node Node replacement [VARIABLES] boolean Node node replacement ", "output": "[PATCH] while (node.isGetProp()) { node = node.getFirstChild(); } ", "bugid": "175"}, {"instruction": "The following code contains a buggy line with the following test error: IllegalStateException testIssue1002 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] if (fnType != null) { [FE] IllegalStateException testIssue1002 [CONTEXT] private void visitNew(NodeTraversal t, Node n) { Node constructor = n.getFirstChild(); JSType type = getJSType(constructor).restrictByNotNullOrUndefined(); if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) { FunctionType fnType = type.toMaybeFunctionType(); [BUGGY] if (fnType != null) { [BUGGY] visitParameterList(t, n, fnType); ensureTyped(t, n, fnType.getInstanceType()); } else { ensureTyped(t, n); } } else { report(t, n, NOT_A_CONSTRUCTOR); ensureTyped(t, n); } } [CLASS] TypeCheck SuggestionPair [METHOD] visitNew [RETURN_TYPE] void NodeTraversal t Node n [VARIABLES] ReverseAbstractInterpreter reverseInterpreter JSType type NodeTraversal t DiagnosticGroup ALL_DIAGNOSTICS CheckLevel reportMissingOverride Node constructor n FunctionType fnType String OVERRIDING_PROTOTYPE_WITH_NON_OBJECT abstractMethodMessage abstractMethodName alt bestSoFar file funName functionPrivateName message pname prop propName property property2 propertyName s suggestion Method editDistance MemoizedScopeCreator scopeCreator int distance noTypeCheckSection nullCount parentNodeType shortest typedCount unknownCount TypeValidator validator AbstractCompiler compiler JSTypeRegistry typeRegistry boolean declaredLocally declaredOverride enterSection externs foundInterfaceProperty inExterns interfaceHasProperty report reportMissingProperties reportUnknownTypes superClassHasDeclaredProperty superClassHasProperty superInterfaceHasDeclaredProperty superInterfaceHasProperty typeable valid Scope outerScope s topScope DiagnosticType BAD_IMPLEMENTED_TYPE BIT_OPERATION CONFLICTING_EXTENDED_TYPE CONFLICTING_IMPLEMENTED_TYPE CONFLICTING_SHAPE_TYPE CONSTRUCTOR_NOT_CALLABLE DETERMINISTIC_TEST ENUM_DUP ENUM_NOT_CONSTANT EXPECTED_THIS_TYPE FUNCTION_MASKS_VARIABLE HIDDEN_INTERFACE_PROPERTY HIDDEN_SUPERCLASS_PROPERTY HIDDEN_SUPERCLASS_PROPERTY_MISMATCH ILLEGAL_IMPLICIT_CAST ILLEGAL_OBJLIT_KEY ILLEGAL_PROPERTY_CREATION INCOMPATIBLE_EXTENDED_PROPERTY_TYPE INEXISTENT_ENUM_ELEMENT INEXISTENT_PROPERTY INEXISTENT_PROPERTY_WITH_SUGGESTION INTERFACE_FUNCTION_NOT_EMPTY INTERFACE_METHOD_OVERRIDE INVALID_INTERFACE_MEMBER_DECLARATION IN_USED_WITH_STRUCT MULTIPLE_VAR_DEF NOT_A_CONSTRUCTOR NOT_CALLABLE UNEXPECTED_TOKEN UNKNOWN_EXPR_TYPE UNKNOWN_OVERRIDE UNRESOLVED_TYPE WRONG_ARGUMENT_COUNT diagnosticType InferJSDocInfo inferJSDocInfo ", "output": "[PATCH] if (fnType != null && fnType.hasInstanceType()) { ", "bugid": "176"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testDontRemoveBreakInTryFinally . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   }", "input": "[BUG] [BUGGY] if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } [FE] AssertionFailedError: testDontRemoveBreakInTryFinally [CONTEXT] if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } [BUGGY] if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } [BUGGY] } if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } [CLASS] MinimizeExitPoints [METHOD] tryMinimizeExits [RETURN_TYPE] void Node n int exitType String labelName [VARIABLES] AbstractCompiler compiler String labelName boolean int exitType Node allCatchNodes c catchCodeBlock catchNode elseBlock falseBlock finallyBlock ifBlock ifTree labelBlock n trueBlock tryBlock ", "output": "[PATCH] ", "bugid": "177"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testIssue937 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  String result = \"\" +  \"console.log((new x()).abc());\"; test(options, code, result);  }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: testIssue937 [CONTEXT] private void annotateCalls(Node n) { Preconditions.checkState(n.isCall());  Node first = n.getFirstChild();  [BUGGY] [BUGGY] if (!NodeUtil.isGet(first)) { n.putBooleanProp(Node.FREE_CALL, true); }  if (first.isName() &&\"eval\".equals(first.getString())) { first.putBooleanProp(Node.DIRECT_EVAL, true); } [CLASS] PrepareAst PrepareAnnotations [METHOD] annotateCalls [RETURN_TYPE] void Node n [VARIABLES] AbstractCompiler compiler boolean checkOnly Node first n ", "output": "[PATCH] while (first.isCast()) { first = first.getFirstChild(); } ", "bugid": "178"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testIssue931 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   public void testIssue931() { collapsePropertiesOnExternTypes = true; testSame(   \"function f() {\\n\" +   \"  return function () {\\n\" +", "input": "[BUG] [BUGGY] if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) { [FE] AssertionFailedError: testIssue931 [CONTEXT] Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest()); while (!workList.isEmpty()) { Name name = workList.pop(); if (name.type == Name.Type.GET || name.type == Name.Type.SET) { continue; } [BUGGY] if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) { [BUGGY]  List<Ref> refs = Lists.newArrayList(name.getRefs()); for (Ref ref : refs) { if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) { if (inlineAliasIfPossible(ref, namespace)) { name.removeRef(ref); } [CLASS] CollapseProperties 1 [METHOD] inlineAliases [RETURN_TYPE] void GlobalNamespace namespace [VARIABLES] AbstractCompiler compiler Ref ref boolean collapsePropertiesOnExternTypes inlineAliases DiagnosticType NAMESPACE_REDEFINED_WARNING UNSAFE_NAMESPACE_WARNING UNSAFE_THIS List globalNames refs Map nameMap GlobalNamespace namespace Deque workList Name name ", "output": "[PATCH] if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) {", "bugid": "179"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testIssue925 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && !mayEffectMutableState(lhs)) { [FE] AssertionFailedError: testIssue925 [CONTEXT] [BUGGY] if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && !mayEffectMutableState(lhs)) { [BUGGY] n.removeChild(cond); Node assignName = thenOp.removeFirstChild(); Node thenExpr = thenOp.removeFirstChild(); Node elseExpr = elseOp.getLastChild(); elseOp.removeChild(elseExpr); Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); Node assign = new Node(thenOp.getType(), assignName, hookNode) .srcref(thenOp); [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE ", "output": "[PATCH] if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) !mayEffectMutableState(lhs) && (!mayHaveSideEffects(cond) || (thenOp.isAssign() && thenOp.getFirstChild().isName()))) { ", "bugid": "180"}, {"instruction": "The following code contains a buggy line with the following test error: IllegalStateException: Recorded bad position information testTextExtents . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   }", "input": "[BUG] [BUGGY] [FE] IllegalStateException: Recorded bad position information testTextExtents [CONTEXT] private String getRemainingJSDocLine() { String result = stream.getRemainingJSDocLine(); [BUGGY] [BUGGY] return result; } [CLASS] JsDocInfoParser ErrorReporterParser State ExtractionInfo ExtendedTypeInfo WhitespaceOption [METHOD] getRemainingJSDocLine [RETURN_TYPE] String [VARIABLES] Set modifies modifiesAnnotationKeywords suppressionNames suppressions Node alternate arg array associatedNode basicTypeExpr contextType expr fieldName fieldType fieldTypeList functionType memberType n paramType parameters paramsType recordType resultType templateNode typeAst typeExpr typeExpression typeList typeNameNode typeNode union JsDocTokenStream stream FileLevelJsDocBuilder fileLevelJsDocBuilder String annotationName author description fileOverview line meaning messageArg messageId multilineText name paramDescription preserve reason reference result returnDescription s string tokenStr typeName typeString version warning JSDocInfo fileOverviewJSDocInfo int charno endCharno endLineno i lineStartChar lineno numSpaces startCharno startLineno trimCount type ErrorReporter errorReporter boolean JsDocToken NO_UNREAD_TOKEN t token token1 token2 unreadToken WhitespaceOption PRESERVE SINGLE_LINE TRIM option ErrorReporterParser parser State NEXT_IS_ANNOTATION SEARCHING_ANNOTATION SEARCHING_NEWLINE state JSTypeExpression expr type JSDocInfoBuilder jsdocBuilder StaticSourceFile sourceFile Map annotationNames ", "output": "[PATCH] unreadToken = NO_UNREAD_TOKEN; ", "bugid": "181"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<None> but was:<undefined> testEqCondition4 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   public void testEqCondition4() throws Exception { FlowScope blind = newScope(); testBinop(blind,  Token.EQ,  createVar(blind, \"a\", VOID_TYPE),", "input": "[BUG] [BUGGY] return new TypePair(null, null); [FE] AssertionFailedError: expected:<None> but was:<undefined> testEqCondition4 [CONTEXT] public TypePair getTypesUnderInequality(JSType that) { if (that instanceof UnionType) { TypePair p = that.getTypesUnderInequality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case TRUE: [BUGGY] return new TypePair(null, null); [BUGGY] case FALSE: case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException(); } [CLASS] JSType 1 TypePair [METHOD] getTypesUnderInequality [RETURN_TYPE] JSType$TypePair JSType that [VARIABLES] JSTypeRegistry registry boolean outcome resolved JSType autobox jsType resolveResult restricted t t1 t2 that thatType thisType typeA typeB String EMPTY_TYPE_COMPONENT NOT_A_CLASS NOT_A_TYPE UNKNOWN_NAME propertyName TypePair p long serialVersionUID int ENUMDECL NOT_ENUMDECL Comparator ALPHA ", "output": "[PATCH] JSType noType = getNativeType(JSTypeNative.NO_TYPE); return new TypePair(noType, noType); ", "bugid": "182"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testNamespacedFunctionStubLocal . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  ObjectType goog = (ObjectType) findNameType(\"goog\", lastLocalScope); assertTrue(goog.hasProperty(\"foo\")); assertEquals(\"function (number): ?\",  goog.getPropertyType(\"foo\").toString());", "input": "[BUG] [BUGGY] attachLiteralTypes(n); switch (n.getType()) { case Token.FUNCTION: if (parent.getType() == Token.NAME) { return; } defineDeclaredFunction(n, parent); break; case Token.CATCH: defineCatch(n, parent); break; case Token.VAR: defineVar(n, parent); break; } [FE] AssertionFailedError testNamespacedFunctionStubLocal [CONTEXT] @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n == scope.getRootNode()) return; if (n.getType() == Token.LP && parent == scope.getRootNode()) { handleFunctionInputs(parent); return; } [BUGGY] attachLiteralTypes(n); switch (n.getType()) { case Token.FUNCTION: if (parent.getType() == Token.NAME) { return; } defineDeclaredFunction(n, parent); break; case Token.CATCH: defineCatch(n, parent); break; [CLASS] TypedScopeCreator DeferredSetType DiscoverEnums AbstractScopeBuilder CollectProperties StubDeclaration GlobalScopeBuilder LocalScopeBuilder [METHOD] visit [RETURN_TYPE] void NodeTraversal t Node n Node parent [VARIABLES] JSType delegateType elementsType jsType ownerTypeOfThis ownerVarType propType realType t type valueType NodeTraversal t Node candidate catchName errorRoot firstChild fnBlock fnRoot functionNode key lvalue lvalueNode maybeOwner member n name nameNode node nodeWithJsDocInfo objNode owner ownerNode parametersNode parent rValue rhsValue root rvalue value var String DELEGATE_PROXY_SUFFIX delegateName fnName functionName keyName name ownerName propName qName singletonGetterClassName slotName sourceName typedef variableName TypeValidator validator ObjectType delegateBaseObject delegateSuperObject delegatorObject fnThisType globalThis iface objectType ownerType subClass superClass thisType type unknownType AbstractCompiler compiler ErrorReporter typeParsingErrorReporter JSTypeRegistry registry typeRegistry boolean inferred isExtern isFnLiteral searchedForThisType shouldDeclareOnGlobalThis Scope newScope parent s scope DiagnosticType CONSTRUCTOR_EXPECTED ENUM_INITIALIZER MALFORMED_TYPEDEF CodingConvention codingConvention List deferredSetTypes delegateProxyPrototypes nonExternFunctions stubDeclarations ", "output": "[PATCH] super.visit(t, n, parent); ", "bugid": "183"}, {"instruction": "The following code contains a buggy line with the following test error: ClassCastException: comgooglejavascriptrhinojstypeStringType cannot be cast to comgooglejavascriptrhinojstypeObjectType testBackwardsTypedefUse1 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); [FE] ClassCastException: comgooglejavascriptrhinojstypeStringType cannot be cast to comgooglejavascriptrhinojstypeObjectType testBackwardsTypedefUse1 [CONTEXT] JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { setResolvedTypeInternal(this); call = (ArrowType) safeResolve(call, t, scope); prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope); [BUGGY] typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); [BUGGY] boolean changed = false; ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder(); for (ObjectType iface : implementedInterfaces) { ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope); resolvedInterfaces.add(resolvedIface); changed |= (resolvedIface != iface); } if (changed) { [CLASS] FunctionType Kind [METHOD] resolveInternal [RETURN_TYPE] JSType ErrorReporter t JSType> scope [VARIABLES] FunctionPrototypeType prototype Node lastParam n newParamsNode p params source thisTypeNode StaticScope scope Builder resolvedInterfaces ArrowType arrowType call String name property propertyName templateTypeName long serialVersionUID int i ObjectType baseType iface instance instanceType maybeSuperInstanceType newTypeOfThis objType resolvedIface type typeOfThis ErrorReporter t boolean changed Kind CONSTRUCTOR INTERFACE ORDINARY kind List implementedInterfaces subTypes ", "output": "[PATCH] JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope); if (maybeTypeOfThis instanceof ObjectType) { typeOfThis = (ObjectType) maybeTypeOfThis; } ", "bugid": "184"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testIssue423 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString()); [FE] AssertionFailedError: testIssue423 [CONTEXT] private void findCalledFunctions( Node node, Set<String> changed) { Preconditions.checkArgument(changed != null); [BUGGY] if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString()); [BUGGY] } } for (Node c = node.getFirstChild(); c != null; c = c.getNext()) { findCalledFunctions(c, changed); } } [CLASS] InlineFunctions FindCandidateFunctions CallVisitor FindCandidatesReferences Inline FunctionState NamedFunction FunctionVar FunctionExpression Reference [METHOD] findCalledFunctions [RETURN_TYPE] void Node node String> changed [VARIABLES] Set changed fnNames names namesToAlias Node block c callNode child containingFunction externs fn fnIdentifingNode fnNode gramps n name nameNode newCode node parent root safeFnNode target var String fakeName fnName name SpecializationState specializationState int callsSeen index Function fn AbstractCompiler compiler boolean blockFunctionInliningEnabled decompose hasInnerFunctions inline inlineDirectly inlineGlobalFunctions inlineLocalFunctions inlined lowersCost referenceAdded referencesThis remove requiresDecomposition CallVisitorCallback callback JSModule module Map anonFns anonFunctionMap fns functionMap references FunctionInjector injector ", "output": "[PATCH] if (node.getType() == Token.NAME) { if (isCandidateUsage(node)) { changed.add(node.getString()); ", "bugid": "185"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Unexpected error(s): JSC_INDEX_OUT_OF_BOUNDS_ERROR Array index out of bounds: NUMBER 10 1 [source_file: testcode] at testcode line 1 : 3 expected:<0> but was:<1> testIssue522 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: Unexpected error(s): JSC_INDEX_OUT_OF_BOUNDS_ERROR Array index out of bounds: NUMBER 10 1 [source_file: testcode] at testcode line 1 : 3 expected:<0> but was:<1> testIssue522 [CONTEXT] private Node tryFoldArrayAccess(Node n, Node left, Node right) { Node parent = n.getParent();  [BUGGY] [BUGGY] if (right.getType() != Token.NUMBER) {  return n; } double index = right.getDouble(); int intIndex = (int) index; if (intIndex != index) { error(INVALID_GETELEM_INDEX_ERROR, right); [CLASS] PeepholeFoldConstants [METHOD] tryFoldArrayAccess [RETURN_TYPE] Node Node n Node left Node right [VARIABLES] boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER index lv lval negNum numValue result rv rval val value int i intIndex Node elem left n parent right ", "output": "[PATCH] if (isAssignmentTarget(n)) { return n; } ", "bugid": "186"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<{[a: (boolean|undefined), b: (string|undefined)]}> but was:<{[]}> testRecordInference . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   \"var out = {};\" +  \"f(out);\"); assertEquals(\"{a: (boolean|undefined), b: (string|undefined)}\",  getType(\"out\").toString());  }", "input": "[BUG] [BUGGY] [FE] ComparisonFailure: expected:<{[a: (boolean|undefined), b: (string|undefined)]}> but was:<{[]}> testRecordInference [CONTEXT]   if (constraint.isRecordType()) { matchRecordTypeConstraint(constraint.toObjectType()); [BUGGY] [BUGGY] } } [CLASS] PrototypeObjectType [METHOD] matchConstraint [RETURN_TYPE] void JSType constraint [VARIABLES] ObjectType current implicitPrototype implicitPrototypeFallback interfaceType nativeType p thatCtor thatObj thisInterface boolean forAnnotations inferred nativeType prettyPrint JSType constraint FunctionType ownerFunction type String className name prop property propertyName Map properties long serialVersionUID int MAX_PRETTY_PRINTED_PROPERTIES i localCount ", "output": "[PATCH] } else if (constraint.isUnionType()) { for (JSType alt : constraint.toMaybeUnionType().getAlternates()) { if (alt.isRecordType()) { matchRecordTypeConstraint(alt.toObjectType()); } } ", "bugid": "187"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected a warning testIssue726 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] if (t.getScopeDepth() <= 2) { [FE] AssertionFailedError: expected a warning testIssue726 [CONTEXT] @Override public void visit(NodeTraversal t, Node n, Node parent) { if (t.inGlobalScope()) { return; } if (n.isReturn() && n.getFirstChild() != null) { data.get(t.getScopeRoot()).recordNonEmptyReturn(); } [BUGGY] if (t.getScopeDepth() <= 2) { [BUGGY]   return; } [CLASS] TypedScopeCreator DeferredSetType DiscoverEnumsAndTypedefs AbstractScopeBuilder CollectProperties StubDeclaration GlobalScopeBuilder LocalScopeBuilder FirstOrderFunctionAnalyzer [METHOD] visit [RETURN_TYPE] void NodeTraversal t Node n Node parent [VARIABLES] JSType delegateType elementsType injectedThisType jsType keyType knownType ownerTypeOfThis ownerVarType propType realType t type valueType NodeTraversal t Var var Node astParameter astParameters body candidate catchName child current errorRoot externs firstChild firstClause fnBlock fnNameNode fnNode fnRoot functionNode initialValue jsDocParameter jsDocParameters key keyNode lValue lValueNode lvalueNode member n name nameNode node nodeWithJsDocInfo objLit objNode objectLit ownerNode parametersNode parent rValue rhsValue root scriptRoot secondClause value valueNode var String DELEGATE_PROXY_SUFFIX delegateName fnName functionName keyName lValueName lendsName memberName name ownerName propName prototypeName qName qualifiedName scriptName singletonGetterClassName slotName sourceName typedef varName variableName TypeValidator validator ObjectType delegateBaseObject delegateSuperObject delegatorObject fnThisType globalThis iface o objLitType objectType ownerType qVarType subClass superClass thisType type unknownType AbstractCompiler compiler ErrorReporter typeParsingErrorReporter JSTypeRegistry registry typeRegistry boolean createdEnumType declareOnOwner descend inferred isExtern isFnLiteral isFnTypeInferred isGlobalVar isValidValue namesMatch searchedForThisType shouldDeclareOnGlobalThis Scope globalScope newScope ownerScope parent s scope scopeToDeclareIn DiagnosticType CONSTRUCTOR_EXPECTED CTOR_INITIALIZER ENUM_INITIALIZER IFACE_INITIALIZER LENDS_ON_NON_OBJECT MALFORMED_TYPEDEF UNKNOWN_LENDS CodingConvention codingConvention InputId inputId List deferredSetTypes delegateProxyPrototypes lentObjectLiterals nonExternFunctions stubDeclarations varsToRemove Map data delegateCallingConventions functionAnalysisResults outParam ", "output": "[PATCH] if (t.getScopeDepth() <= 1) { ", "bugid": "188"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: unexpected warnings(s): testIssue1024 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: unexpected warnings(s): testIssue1024 [CONTEXT] Node rhsValue, JSType valueType) { if (valueType == null) { return true; } if (qName != null && qName.endsWith(\".prototype\")) { [BUGGY] [BUGGY] return false; } boolean inferred = true; if (info != null) { inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info)); } [CLASS] TypedScopeCreator DeferredSetType DiscoverEnumsAndTypedefs AbstractScopeBuilder CollectProperties StubDeclaration GlobalScopeBuilder LocalScopeBuilder FirstOrderFunctionAnalyzer [METHOD] isQualifiedNameInferred [RETURN_TYPE] boolean String qName Node n JSDocInfo info Node rhsValue JSType valueType [VARIABLES] JSType delegateType elementsType fnThisType globalThis injectedThisType jsType keyType ownerTypeOfThis propType t thisType type valueType Node catchName child current errorRoot firstChild firstClause fnRoot functionNode initialValue key keyNode lValue lValueNode lvalueNode n name nameNode node objLit objectLit ownerNode parametersNode parent rValue rhsValue root scriptRoot secondClause value var AstFunctionContents contents String DELEGATE_PROXY_SUFFIX delegateName fnName functionName keyName lValueName lendsName memberName name ownerName propName prototypeName qName qualifiedName scriptName singletonGetterClassName sourceName variableName JSDocInfo info TypeValidator validator ObjectType delegateBaseObject delegateSuperObject delegatorObject globalThis iface o objLitType objectType ownerType prototypeOwner qVarType subClass superClass type unknownType AbstractCompiler compiler ErrorReporter typeParsingErrorReporter JSTypeRegistry registry typeRegistry boolean createdEnumType declareOnOwner descend inferred isExtern isFnLiteral isGlobalVar isValidValue namesMatch searchedForThisType shouldDeclareOnGlobalThis Scope globalScope newScope parent s scope scopeToDeclareIn DiagnosticType CONSTRUCTOR_EXPECTED CTOR_INITIALIZER ENUM_INITIALIZER IFACE_INITIALIZER LENDS_ON_NON_OBJECT MALFORMED_TYPEDEF UNKNOWN_LENDS CodingConvention codingConvention InputId inputId List deferredSetTypes delegateProxyPrototypes lentObjectLiterals nonExternFunctions stubDeclarations varsToRemove Map data delegateCallingConventions functionAnalysisResults outParam ", "output": "[PATCH] String className = qName.substring(0, qName.lastIndexOf(\".prototype\")); Var slot = scope.getSlot(className); JSType classType = slot == null ? null : slot.getType(); if (classType != null && (classType.isConstructor() || classType.isInterface())) { } ", "bugid": "189"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<-1> but was:<13> testBase64EmptyInputStream . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   byte[] emptyEncoded = new byte[0];  byte[] emptyDecoded = new byte[0];  testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);  testByChunk(emptyEncoded, emptyDecoded, 76, CRLF); }", "input": "[BUG] [BUGGY]  [FE] AssertionFailedError: expected:<-1> but was:<13> testBase64EmptyInputStream [CONTEXT]   if (lineLength > 0) { [BUGGY] [BUGGY] System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length); pos += lineSeparator.length; } [CLASS] Base64 [METHOD] encode [RETURN_TYPE] void [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buf encodeTable in lineSeparator out boolean eof urlSafe byte PAD int CHUNK_SIZE MASK_6BITS MASK_8BITS b bAvail bPos currentLinePos decodeSize encodeSize i inAvail inPos len lineLength pos outPos  readPos x ", "output": "[PATCH] if (lineLength > 0 && pos > 0) { ", "bugid": "190"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: testDoubleMetaphoneAlternate . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   for (int i = 0; i < TEST_DATA.length; i++) {   value = TEST_DATA[i][0];   assertEquals(\"Test [\" + i + \"]=\" + value, TEST_DATA[i][2], doubleMetaphone.doubleMetaphone(value, true));  } }", "input": "[BUG] [BUGGY] } else if (contains(value, index + 1, 4, \"IER\")) { [FE] ComparisonFailure: testDoubleMetaphoneAlternate [CONTEXT] [BUGGY] } else if (contains(value, index + 1, 4, \"IER\")) { [BUGGY]  [CLASS] DoubleMetaphone DoubleMetaphoneResult [METHOD] handleG [RETURN_TYPE] int String value DoubleMetaphoneResult result int index ", "output": "[PATCH] } else if (contains(value, index + 1, 3,\"IER\")) { ", "bugid": "191"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Encoder test-1 testEncoder . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:     byte[] binary = BYTES[i];    boolean b = Arrays.equals(base64, (byte[]) enc.encode(binary));    assertTrue(\"Encoder test-\" + i, b);   }  }", "input": "[BUG] [BUGGY] this(false); [FE] AssertionFailedError: Encoder test-1 testEncoder [CONTEXT] public Base64() { [BUGGY] this(false); [BUGGY] } [CLASS] Base64 [METHOD] <init> [RETURN_TYPE] Base64() [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE buffer encodeTable lineSeparator boolean eof byte PAD int CHUNK_SIZE DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS currentLinePos decodeSize encodeSize lineLength modulus pos readPos x ", "output": "[PATCH] this(0); ", "bugid": "192"}, {"instruction": "The following code contains a buggy line with the following test error: null  testCodec98NPE . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   byte[] codec98 = StringUtils.getBytesUtf8(Base64TestData.CODEC_98_NPE);  ByteArrayInputStream data = new ByteArrayInputStream(codec98);  Base64InputStream stream = new Base64InputStream(data);  // This line causes an NPE in commons-codec-1.4.jar:", "input": "[BUG] [BUGGY] [FE] null  testCodec98NPE [CONTEXT] } } } } }  if (eof && modulus != 0) { [BUGGY] [BUGGY] x = x << 6; switch (modulus) { case 2 : x = x << 6; buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS); break; case 3 : buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS); buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS); break; [CLASS] Base64 [METHOD] decode [RETURN_TYPE] void byte[] in int inPos int inAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable in lineSeparator out boolean eof urlSafe byte PAD b int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE b bAvail bPos currentLinePos decodeSize encodeSize i inAvail inPos len lineLength modulus outAvail outPos pos readPos result x ", "output": "[PATCH] if (buffer == null || buffer.length - pos < decodeSize) { resizeBuffer(); } ", "bugid": "193"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: byteToString static Hello World expected:<SGVsbG8gV29ybGQ=[]> but was:<SGVsbG8gV29ybGQ=[ testByteToStringVariations . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertEquals(\"byteToString Hello World\", \"SGVsbG8gV29ybGQ=\", base64.encodeToString(b1));  assertEquals(\"byteToString static Hello World\", \"SGVsbG8gV29ybGQ=\", Base64.encodeBase64String(b1));  assertEquals(\"byteToString \\\"\\\"\", \"\", base64.encodeToString(b2));  assertEquals(\"byteToString static \\\"\\\"\", \"\", Base64.encodeBase64String(b2));", "input": "[BUG] [BUGGY] return StringUtils.newStringUtf8(encodeBase64(binaryData, true)); [FE] ComparisonFailure: byteToString static Hello World expected:<SGVsbG8gV29ybGQ=[]> but was:<SGVsbG8gV29ybGQ=[ testByteToStringVariations [CONTEXT] public static String encodeBase64String(byte[] binaryData) { [BUGGY] return StringUtils.newStringUtf8(encodeBase64(binaryData, true)); [BUGGY] } [CLASS] Base64 [METHOD] encodeBase64String [RETURN_TYPE] String byte[] binaryData [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE arrayOctet b binaryData buffer encodeTable in lineSeparator out boolean eof urlSafe byte PAD b octet int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE b bAvail bPos currentLinePos decodeSize encodeSize i inAvail inPos len lineLength modulus outAvail outPos pos readPos result x ", "output": "[PATCH] return StringUtils.newStringUtf8(encodeBase64(binaryData, false)); ", "bugid": "194"}, {"instruction": "The following code contains a buggy line with the following test error: IllegalArgumentException: Input array too big, the output array would be bigger (6) than the specified maxium size of 4 testCodec112 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   byte[] in = new byte[] {0};  byte[] out=Base64.encodeBase64(in);  Base64.encodeBase64(in, false, false, out.length); }", "input": "[BUG] [BUGGY] long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR); [FE] IllegalArgumentException: Input array too big, the output array would be bigger (6) than the specified maxium size of 4 testCodec112 [CONTEXT] public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) { if (binaryData == null || binaryData.length == 0) { return binaryData; } [BUGGY] long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR); [BUGGY] if (len > maxResultSize) { throw new IllegalArgumentException(\"\") than the specified maxium size of\" + maxResultSize); } Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe); return b64.encode(binaryData); } [CLASS] Base64 [METHOD] encodeBase64 [RETURN_TYPE] byte[] byte[] binaryData boolean isChunked boolean urlSafe int maxResultSize [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE arrayOctet b binaryData buffer encodeTable in lineSeparator pArray result boolean eof isChunked urlSafe Base64 b64 byte PAD b octet int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE b bAvail bPos currentLinePos decodeSize encodeSize i inAvail inPos len lineLength maxResultSize modulus pos readPos result x long len ", "output": "[PATCH] long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR); ", "bugid": "195"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: Source: mbmb expected:<M[PM]1111111> but was:<M[MP]1111111> testEndMb . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void testEndMb() throws EncoderException {  String[][] data = {{\"mb\", \"M111111111\"}, {\"mbmb\", \"MPM1111111\"}};  this.checkEncodings(data); }", "input": "[BUG] [BUGGY] txt = txt.replaceAll(\"^mb\",\"m2\"); [FE] ComparisonFailure: Source: mbmb expected:<M[PM]1111111> but was:<M[MP]1111111> testEndMb [CONTEXT] txt = txt.replaceAll(\"^cough\",\"cou2f\"); txt = txt.replaceAll(\"^rough\",\"rou2f\"); txt = txt.replaceAll(\"^tough\",\"tou2f\"); txt = txt.replaceAll(\"^enough\",\"enou2f\"); txt = txt.replaceAll(\"^trough\",\"trou2f\"); txt = txt.replaceAll(\"^gn\",\"2n\");  [BUGGY] txt = txt.replaceAll(\"^mb\",\"m2\"); [BUGGY] txt = txt.replaceAll(\"cq\",\"2q\"); txt = txt.replaceAll(\"ci\",\"si\"); txt = txt.replaceAll(\"ce\",\"se\"); txt = txt.replaceAll(\"cy\",\"sy\"); txt = txt.replaceAll(\"tch\",\"2ch\"); txt = txt.replaceAll(\"c\",\"k\"); txt = txt.replaceAll(\"q\",\"k\"); txt = txt.replaceAll(\"x\",\"k\"); [CLASS] Caverphone [METHOD] caverphone [RETURN_TYPE] String String txt [VARIABLES] boolean String txt ", "output": "[PATCH] txt = txt.replaceAll(\"mb$\",\"m2\"); ", "bugid": "196"}, {"instruction": "The following code contains a buggy line with the following test error: IllegalArgumentException: pad must not be in alphabet or whitespace testCodec200 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  }", "input": "[BUG] [BUGGY] 25, 26, 27, 28, 29, 30, 31, 32, [FE] IllegalArgumentException: pad must not be in alphabet or whitespace testCodec200 [CONTEXT]  private static final byte[] [BUGGY] 25, 26, 27, 28, 29, 30, 31, 32, [BUGGY] }; private static final byte[] HEX_ENCODE_TABLE = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', [CLASS] ", "output": "[PATCH] 25, 26, 27, 28, 29, 30, 31,       ", "bugid": "198"}, {"instruction": "The following code contains a buggy line with the following test error: null  testNewStringNullInput_CODEC229 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void testNewStringNullInput_CODEC229() {  Assert.assertNull(StringUtils.newStringUtf8(null));  Assert.assertNull(StringUtils.newStringIso8859_1(null));  Assert.assertNull(StringUtils.newStringUsAscii(null));  Assert.assertNull(StringUtils.newStringUtf16(null));", "input": "[BUG] [BUGGY] return new String(bytes, Charsets.ISO_8859_1); [FE] null  testNewStringNullInput_CODEC229 [CONTEXT] public static String newStringIso8859_1(final byte[] bytes) { [BUGGY] return new String(bytes, Charsets.ISO_8859_1); [BUGGY] } [CLASS] StringUtils [METHOD] newStringIso8859_1 [RETURN_TYPE] String final byte[] bytes [VARIABLES] byte[] bytes boolean ", "output": "[PATCH] return newString(bytes, Charsets.ISO_8859_1); ", "bugid": "199"}, {"instruction": "The following code contains a buggy line with the following test error: StringIndexOutOfBoundsException: String index out of range: 3 testEqualsCS1 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   Assert.assertFalse(StringUtils.equals(null, new StringBuilder(\"abc\")));  Assert.assertTrue(StringUtils.equals(new StringBuilder(\"abc\"), new StringBuilder(\"abc\")));  Assert.assertFalse(StringUtils.equals(new StringBuilder(\"abc\"), new StringBuilder(\"abcd\")));  Assert.assertFalse(StringUtils.equals(new StringBuilder(\"abcd\"), new StringBuilder(\"abc\")));  Assert.assertFalse(StringUtils.equals(new StringBuilder(\"abc\"), new StringBuilder(\"ABC\")));", "input": "[BUG] [BUGGY] return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [FE] StringIndexOutOfBoundsException: String index out of range: 3 testEqualsCS1 [CONTEXT] public static boolean equals(final CharSequence cs1, final CharSequence cs2) { if (cs1 == cs2) { return true; } if (cs1 == null || cs2 == null) { return false; } if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } [BUGGY] return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [BUGGY] } [CLASS] StringUtils [METHOD] equals [RETURN_TYPE] boolean CharSequence cs1 CharSequence cs2 [VARIABLES] boolean CharSequence cs1 cs2 ", "output": "[PATCH] return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length()); ", "bugid": "200"}, {"instruction": "The following code contains a buggy line with the following test error: UnsupportedOperationException should_capture_arguments_when_args_count_does_NOT_match . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   //then  invocationMatcher.captureArgumentsFrom(invocation); }", "input": "[BUG] [BUGGY] throw new UnsupportedOperationException(); [FE] UnsupportedOperationException should_capture_arguments_when_args_count_does_NOT_match [CONTEXT] public void captureArgumentsFrom(Invocation invocation) { if (invocation.getMethod().isVarArgs()) { int indexOfVararg = invocation.getRawArguments().length - 1; [BUGGY] throw new UnsupportedOperationException(); [BUGGY] } else { for (int position = 0; position < matchers.size(); position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class)); } } } [CLASS] InvocationMatcher [METHOD] captureArgumentsFrom [RETURN_TYPE] void Invocation invocation [VARIABLES] List matchers boolean Invocation actual candidate invocation Matcher m long serialVersionUID int indexOfVararg position ", "output": "[PATCH] for (int position = 0; position < indexOfVararg; position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class)); } } for (int position = indexOfVararg; position < matchers.size(); position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]); } } ", "bugid": "201"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: 'orgmockitointernalverificationVerificationOverTimeImpl' has some dependency to JUnit pure_mockito_should_not_depend_JUnit . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   for (String pureMockitoAPIClass : pureMockitoAPIClasses) {   checkDependency(classLoader_without_JUnit, pureMockitoAPIClass);  } }", "input": "[BUG] [BUGGY] catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) { [FE] AssertionFailedError: 'orgmockitointernalverificationVerificationOverTimeImpl' has some dependency to JUnit pure_mockito_should_not_depend_JUnit [CONTEXT] delegate.verify(data); if (returnOnSuccess) { return; } else { error = null; } } catch (MockitoAssertionError e) { error = handleVerifyException(e); } [BUGGY] catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) { [BUGGY] error = handleVerifyException(e); } } if (error != null) { throw error; } } [CLASS] VerificationOverTimeImpl [METHOD] verify [RETURN_TYPE] void VerificationData data [VARIABLES] boolean returnOnSuccess MockitoAssertionError e Timer timer org.mockito.exceptions e AssertionError error long durationMillis pollingPeriodMillis VerificationMode delegate VerificationData data ", "output": "[PATCH] catch (AssertionError e) { ", "bugid": "202"}, {"instruction": "The following code contains a buggy line with the following test error: exceptionsbaseMockitoException: Raw extraction not supported for : 'null' discoverDeepMockingOfGenerics . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   public void discoverDeepMockingOfGenerics() { MyClass1 myMock1 = mock(MyClass1.class, RETURNS_DEEP_STUBS); when(myMock1.getNested().getNested().returnSomething()).thenReturn(\"Hello World.\");  }", "input": "[BUG] [BUGGY] [FE] exceptionsbaseMockitoException: Raw extraction not supported for : 'null' discoverDeepMockingOfGenerics [CONTEXT] private void readTypeVariables() { for (Type type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } [BUGGY] [BUGGY] registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable)); } [CLASS] GenericMetadataSupport FromClassGenericMetadataSupport FromParameterizedTypeGenericMetadataSupport ParameterizedReturnType TypeVariableReturnType NotGenericReturnTypeSupport TypeVarBoundedType WildCardBoundedType [METHOD] readTypeVariables [RETURN_TYPE] void [VARIABLES] ParameterizedType parameterizedType WildcardType wildCard wildcard Type type boolean TypeVariable type typeParameter typeVariable Class clazz currentExploredClass rawType returnType TypeVariable[] typeParameters Map contextualActualTypeParameters ", "output": "[PATCH] registerTypeParametersOn(new TypeVariable[] { typeVariable }); ", "bugid": "203"}, {"instruction": "The following code contains a buggy line with the following test error: StackOverflowError  . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: None", "input": "[BUG] [BUGGY] } else { [FE] StackOverflowError  [CONTEXT] TypeVariable typeParameter = typeParameters[i]; Type actualTypeArgument = actualTypeArguments[i]; if (actualTypeArgument instanceof WildcardType) { contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument)); [BUGGY] } else { [BUGGY] contextualActualTypeParameters.put(typeParameter, actualTypeArgument); } } } [CLASS] GenericMetadataSupport FromClassGenericMetadataSupport FromParameterizedTypeGenericMetadataSupport ParameterizedReturnType TypeVariableReturnType NotGenericReturnTypeSupport TypeVarBoundedType WildCardBoundedType [METHOD] registerTypeVariablesOn [RETURN_TYPE] void Type classType [VARIABLES] TypeVariable typeParameter  Type actualTypeArgument classType  ", "output": "[PATCH] } else if (typeParameter != actualTypeArgument) { ", "bugid": "204"}, {"instruction": "The following code contains a buggy line with the following test error: ClassCastException: sunreflectgenericsreflectiveObjectsParameterizedTypeImpl cannot be cast to javalangClass shouldDealWithNestedGenerics . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  }", "input": "[BUG] [BUGGY] return (Class) actual; [FE] ClassCastException: sunreflectgenericsreflectiveObjectsParameterizedTypeImpl cannot be cast to javalangClass shouldDealWithNestedGenerics [CONTEXT] public Class getGenericType(Field field) { Type generic = field.getGenericType(); if (generic != null && generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; [BUGGY] return (Class) actual; [BUGGY] } return Object.class; } [CLASS] GenericMaster [METHOD] getGenericType [RETURN_TYPE] Class Field field [VARIABLES] Field field Type actual generic boolean ", "output": "[PATCH] if (actual instanceof Class) { return (Class) actual; } else if (actual instanceof ParameterizedType) { return (Class) ((ParameterizedType) actual).getRawType();  } ", "bugid": "205"}, {"instruction": "The following code contains a buggy line with the following test error: null  should_return_empty_iterable . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  }", "input": "[BUG] [BUGGY] [FE] null  should_return_empty_iterable [CONTEXT] Object returnValueFor(Class<?> type) { if (Primitives.isPrimitiveOrWrapper(type)) { return Primitives.defaultValueForPrimitiveOrWrapper(type);  [BUGGY] [BUGGY] } else if (type == Collection.class) { return new LinkedList<Object>(); } else if (type == Set.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == SortedSet.class) { return new TreeSet<Object>(); } else if (type == TreeSet.class) { return new TreeSet<Object>(); } else if (type == LinkedHashSet.class) { [CLASS] ReturnsEmptyValues [METHOD] returnValueFor [RETURN_TYPE] Object Class<?> type [VARIABLES] ObjectMethodsGuru methodsGuru Class type boolean MockUtil mockUtil long serialVersionUID ", "output": "[PATCH] } else if (type == Iterable.class) { return new ArrayList<Object>(0); ", "bugid": "206"}, {"instruction": "The following code contains a buggy line with the following test error: RuntimeException shouldKnowIfObjectsAreEqual . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertTrue(areEqual(new Object[] {\"1\"}, new String[] {\"1\"}));\tObject badequals=new BadEquals();\tassertTrue(areEqual(badequals,badequals));  assertFalse(areEqual(new Object[9], new Object[10]));", "input": "[BUG] [BUGGY] if (o1 == null || o2 == null) { [FE] RuntimeException shouldKnowIfObjectsAreEqual [CONTEXT] public static boolean areEqual(Object o1, Object o2) { [BUGGY] if (o1 == null || o2 == null) { [BUGGY] return o1 == null && o2 == null; } else if (isArray(o1)) { return isArray(o2) && areArraysEqual(o1, o2); } else { return o1.equals(o2); } } [CLASS] Equality [METHOD] areEqual [RETURN_TYPE] boolean Object o1 Object o2 [VARIABLES] boolean Object o1 o2 ", "output": "[PATCH] if (o1 == o2 ) { return true; } else if (o1 == null || o2 == null) { ", "bugid": "207"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<0> but was:<1> should_return_zero_if_mock_is_compared_to_itself . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   //then  assertEquals(0, result); }", "input": "[BUG] [BUGGY] return 1; [FE] AssertionFailedError: expected:<0> but was:<1> should_return_zero_if_mock_is_compared_to_itself [CONTEXT] MockName name = mockUtil.getMockName(mock); if (name.isDefault()) { return\"Mock for\" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() +\", hashCode:\" + mock.hashCode(); } else { return name.toString(); } } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {  [BUGGY] return 1; [BUGGY] } Class<?> returnType = invocation.getMethod().getReturnType(); return returnValueFor(returnType); } [CLASS] ReturnsEmptyValues [METHOD] answer [RETURN_TYPE] Object InvocationOnMock invocation [VARIABLES] ObjectMethodsGuru methodsGuru MockName name boolean MockUtil mockUtil InvocationOnMock invocation Object mock Class returnType long serialVersionUID ", "output": "[PATCH] return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1; ", "bugid": "208"}, {"instruction": "The following code contains a buggy line with the following test error: ClassCastException: javalangInteger cannot be cast to javalangDouble should_default_values_for_primitive . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertThat(h.returnFor(long.class)).isEqualTo(0L);  assertThat(h.returnFor(float.class)).isEqualTo(0.0F);  assertThat(h.returnFor(double.class)).isEqualTo(0.0D); }", "input": "[BUG] [BUGGY] primitiveValues.put(double.class, 0); [FE] ClassCastException: javalangInteger cannot be cast to javalangDouble should_default_values_for_primitive [CONTEXT] } static { primitiveValues.put(boolean.class, false); primitiveValues.put(char.class, '\\u0000'); primitiveValues.put(byte.class, (byte) 0); primitiveValues.put(short.class, (short) 0); primitiveValues.put(int.class, 0); primitiveValues.put(long.class, 0L); primitiveValues.put(float.class, 0F); [BUGGY] primitiveValues.put(double.class, 0); [BUGGY] } } [CLASS] ", "output": "[PATCH] primitiveValues.put(double.class, 0D); ", "bugid": "209"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: listener . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   mockedList.clear();  verify(invocationListener).reportInvocation(any(MethodInvocationReport.class)); }", "input": "[BUG] [BUGGY] MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS)); [FE] AssertionFailedError: listener [CONTEXT] public <T> void resetMock(T mock) { MockHandlerInterface<T> oldMockHandler = getMockHandler(mock); [BUGGY] MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS)); [BUGGY] ((Factory) mock).setCallback(0, newFilter); } [CLASS] MockUtil [METHOD] resetMock [RETURN_TYPE] <T> T mock [VARIABLES] MockHandler newMockHandler boolean T mock MockHandlerInterface oldMockHandler MockCreationValidator creationValidator MethodInterceptorFilter newFilter ", "output": "[PATCH] MethodInterceptorFilter newFilter = newMethodInterceptorFilter(oldMockHandler.getMockSettings()); ", "bugid": "210"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected same:<javalangObject@1a6aecec> was not:<mockedBean> mock_should_be_injected_once_and_in_the_best_matching_type . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  }", "input": "[BUG] [BUGGY] mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(); [FE] AssertionFailedError: expected same:<javalangObject@1a6aecec> was not:<mockedBean> mock_should_be_injected_once_and_in_the_best_matching_type [CONTEXT] private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) { for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) { [BUGGY] mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(); [BUGGY] } } [CLASS] DefaultInjectionEngine 1 [METHOD] injectMockCandidate [RETURN_TYPE] void Class<?> awaitingInjectionClazz Object> mocks Object fieldInstance [VARIABLES] Field field Set mocks boolean MockCandidateFilter mockCandidateFilter Class awaitingInjectionClazz Object fieldInstance Comparator supertypesLast ", "output": "[PATCH] Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(); mocks.remove(injected); ", "bugid": "211"}, {"instruction": "The following code contains a buggy line with the following test error: null  . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   mock.objectArgMethod(\"not null\");  verify(mock).objectArgMethod(same(null)); }", "input": "[BUG] [BUGGY] description.appendText(wanted.toString()); [FE] null  [CONTEXT]  appendQuoting(description); [BUGGY] description.appendText(wanted.toString()); [BUGGY]  [CLASS] Same [METHOD] describeTo [RETURN_TYPE] void Description description [VARIABLES] Object actual wanted Description description boolean long serialVersionUID ", "output": "[PATCH] description.appendText(wanted == null ?\"null\" : wanted.toString()); ", "bugid": "212"}, {"instruction": "The following code contains a buggy line with the following test error: ArrayIndexOutOfBoundsException: 0 shouldMatchCaptureArgumentsWhenArgsCountDoesNOTMatch . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   //then  invocationMatcher.captureArgumentsFrom(invocation); }", "input": "[BUG] [BUGGY] if (m instanceof CapturesArguments) { [FE] ArrayIndexOutOfBoundsException: 0 shouldMatchCaptureArgumentsWhenArgsCountDoesNOTMatch [CONTEXT]   if (m instanceof CapturesArguments) { [BUGGY] ((CapturesArguments) m).captureFrom(i.getArguments()[k]); [BUGGY] } k++; } } [CLASS] InvocationMatcher [METHOD] captureArgumentsFrom [RETURN_TYPE] void Invocation i [VARIABLES] List matchers int k Invocation actual candidate i invocation Matcher m ", "output": "[PATCH] if (m instanceof CapturesArguments && i.getArguments().length > k) { ", "bugid": "214"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError shouldFailWhenCallingRealMethodOnIterface . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    validator.validate(new CallsRealMethods(), inovcationOnIterface);   //then   fail();  } catch (MockitoException e) {} }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError shouldFailWhenCallingRealMethodOnIterface [CONTEXT] } if (answer instanceof Returns) { validateReturnValue((Returns) answer, invocation); } if (answer instanceof DoesNothing) { validateDoNothing((DoesNothing) answer, invocation); } [BUGGY] [BUGGY] } private void validateDoNothing(DoesNothing answer, Invocation invocation) { if (!invocation.isVoid()) { reporter.onlyVoidMethodsCanBeSetToDoNothing(); } } private void validateReturnValue(Returns answer, Invocation invocation) { if (invocation.isVoid()) { [CLASS] ", "output": "[PATCH] if (answer instanceof CallsRealMethods) { validateMockingConcreteClass((CallsRealMethods) answer, invocation); } private void validateMockingConcreteClass(CallsRealMethods answer, Invocation invocation) { if (invocation.getMethod().getDeclaringClass().isInterface()) { reporter.cannotCallRealMethodOnInterface(); } } ", "bugid": "215"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<dy>pre <script>inner[</script> aft]</body></html>> but was:<dy>pre <script>inner[ aft</script>]</body></html>> handlesTextAfterData . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   String h = \"<html><body>pre <script>inner</script> aft</body></html>\";  Document doc = Jsoup.parse(h);  assertEquals(\"<html><head></head><body>pre <script>inner</script> aft</body></html>\", TextUtil.stripNewlines(doc.html())); }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: expected:<dy>pre <script>inner[</script> aft]</body></html>> but was:<dy>pre <script>inner[ aft</script>]</body></html>> handlesTextAfterData [CONTEXT] isEmptyElement = true; } else { tq.matchChomp(\">\"); } addChildToParent(child, isEmptyElement); if (tag.isData()) { String data = tq.chompTo(\"</\" + tagName); tq.chompTo(\">\"); [BUGGY] [BUGGY] Node dataNode; if (tag.equals(titleTag) || tag.equals(textareaTag)) dataNode = TextNode.createFromEncoded(data, baseUri); else dataNode = new DataNode(data, baseUri); child.appendChild(dataNode); } if (child.tagName().equals(\"base\")) { [CLASS] Parser [METHOD] parseStartTag [RETURN_TYPE] void [VARIABLES] TokenQueue tq boolean isEmptyElement Attribute attribute Element child Node dataNode Attributes attributes String DQ SQ baseUri bodyHtml data href html tagName Tag bodyTag headTag htmlTag tag textareaTag titleTag Document doc LinkedList stack ", "output": "[PATCH] popStackToClose(tag); ", "bugid": "216"}, {"instruction": "The following code contains a buggy line with the following test error: StringIndexOutOfBoundsException: String index out of range: 14 parsesQuiteRoughAttributes . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  @Test public void parsesQuiteRoughAttributes() {  String html = \"<p =a>One<a =a\";  Document doc = Jsoup.parse(html);  assertEquals(\"<p>One<a></a></p>\", doc.body().html());  ", "input": "[BUG] [BUGGY] tq.consume(); [FE] StringIndexOutOfBoundsException: String index out of range: 14 parsesQuiteRoughAttributes [CONTEXT] if (key.length() != 0) return Attribute.createFromEncoded(key, value); else { [BUGGY] tq.consume(); [BUGGY] return null; } [CLASS] Parser [METHOD] parseAttribute [RETURN_TYPE] Attribute [VARIABLES] TokenQueue tq boolean isBodyFragment isEmptyElement procInstr relaxed StringBuilder valueAccum String DQ SQ baseUri bodyHtml data href html key tagName value Tag bodyTag headTag htmlTag tag textareaTag titleTag Document doc LinkedList stack ", "output": "[PATCH] if (value.length() == 0) tq.advance(); ", "bugid": "217"}, {"instruction": "The following code contains a buggy line with the following test error: IllegalArgumentException: Illegal group reference: group index is missing testYahooArticle . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void testYahooArticle() throws IOException {  File in = getFile(\"/htmltests/yahoo-article-1.html\");  Document doc = Jsoup.parse(in, \"UTF-8\", \"http://news.yahoo.com/s/nm/20100831/bs_nm/us_gm_china\");  Element p = doc.select(\"p:contains(Volt will be sold in the United States\").first();  assertEquals(\"In July, GM said its electric Chevrolet Volt will be sold in the United States at $41,000 -- $8,000 more than its nearest competitor, the Nissan Leaf.\", p.text());", "input": "[BUG] [BUGGY] m.appendReplacement(accum, c); [FE] IllegalArgumentException: Illegal group reference: group index is missing testYahooArticle [CONTEXT] } catch (NumberFormatException e) { } } else { String name = m.group(1); if (full.containsKey(name)) charval = full.get(name); } if (charval != -1 || charval > 0xFFFF) { String c = Character.toString((char) charval); [BUGGY] m.appendReplacement(accum, c); [BUGGY]} else { m.appendReplacement(accum, m.group(0)); } } m.appendTail(accum); return accum.toString(); } [CLASS] Entities EscapeMode [METHOD] unescape [RETURN_TYPE] String String string [VARIABLES] Pattern unescapePattern StringBuffer accum boolean Matcher m EscapeMode base escapeMode extended Object[][] baseArray fullArray NumberFormatException e String c name num string Map baseByVal full fullByVal map int base charval ", "output": "[PATCH] m.appendReplacement(accum, Matcher.quoteReplacement(c)); ", "bugid": "218"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<<> unescape . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  @Test public void unescape() {  String text = \"Hello &amp;&LT&gt; &angst &#960; &#960 &#x65B0; there &! &frac34;\";  assertEquals(\"Hello &<> \u00c5 \u03c0 \u03c0 \u65b0 there &! \u00be\", Entities.unescape(text));  assertEquals(\"&0987654321; &unknown\", Entities.unescape(\"&0987654321; &unknown\"));", "input": "[BUG] [BUGGY] private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\"); [FE] AssertionFailedError: expected:<<> unescape [CONTEXT] private static final Map<Character, String> baseByVal; [CLASS] Entities EscapeMode [VARIABLES] ", "output": "[PATCH] private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+\\\\\\\\d*);?\"); ", "bugid": "219"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<tp://jsouporg/path/[file]?foo> but was:<tp://jsouporg/path/[]?foo> absHandlesRelativeQuery . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: expected:<tp://jsouporg/path/[file]?foo> but was:<tp://jsouporg/path/[]?foo> absHandlesRelativeQuery [CONTEXT] URL base; try { try { base = new URL(baseUri); } catch (MalformedURLException e) { URL abs = new URL(relUrl); return abs.toExternalForm(); } [BUGGY] [BUGGY] URL abs = new URL(base, relUrl); return abs.toExternalForm(); } catch (MalformedURLException e) { return\"\"; } } } [CLASS] Node OuterHtmlVisitor [METHOD] absUrl [RETURN_TYPE] String String attributeKey [VARIABLES] MalformedURLException e boolean StringBuilder accum OutputSettings out Node parentNode Attributes attributes List childNodes String attributeKey attributeValue baseUri relUrl int siblingIndex URL abs base ", "output": "[PATCH] if (relUrl.startsWith(\"?\")) { relUrl = base.getPath() + relUrl; } ", "bugid": "220"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError handlesAbsPrefixOnHasAttr . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertEquals(\"\", one.absUrl(\"href\"));  assertTrue(two.hasAttr(\"abs:href\"));  assertTrue(two.hasAttr(\"href\"));  assertEquals(\"http://jsoup.org/\", two.absUrl(\"href\"));", "input": "[BUG] [BUGGY] [FE] AssertionFailedError handlesAbsPrefixOnHasAttr [CONTEXT] public boolean hasAttr(String attributeKey) { Validate.notNull(attributeKey); [BUGGY] [BUGGY] return attributes.hasKey(attributeKey); } [CLASS] Node OuterHtmlVisitor [METHOD] hasAttr [RETURN_TYPE] boolean String attributeKey [VARIABLES] boolean StringBuilder accum OutputSettings out Node parentNode Attributes attributes List childNodes String attributeKey attributeValue baseUri int siblingIndex ", "output": "[PATCH] if (attributeKey.toLowerCase().startsWith(\"abs:\")) { String key = attributeKey.substring(\"abs:\".length()); if (attributes.hasKey(key) && !absUrl(key).equals(\"\")) return true; } ", "bugid": "221"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<Hello []There> but was:<Hello ['); i++; ]There> handlesDataOnlyTags . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   String s = \"<p>Hello</p><script>obj.insert('<a rel=\\\"none\\\" />');\\ni++;</script><p>There</p>\";  Document doc = Jsoup.parse(s);  assertEquals(\"Hello There\", doc.text());  assertEquals(\"obj.insert('<a rel=\\\"none\\\" />');\\ni++;\", doc.data()); }", "input": "[BUG] [BUGGY] } else if (StringUtil.in(name,\"base\",\"basefont\",\"bgsound\",\"command\",\"link\",\"meta\",\"noframes\",\"style\",\"title\")) { [FE] AssertionFailedError: expected:<Hello []There> but was:<Hello ['); i++; ]There> handlesDataOnlyTags [CONTEXT] Token.StartTag startTag = t.asStartTag(); String name = startTag.name(); if (name.equals(\"html\")) { tb.error(this); Element html = tb.getStack().getFirst(); for (Attribute attribute : startTag.getAttributes()) { if (!html.hasAttr(attribute.getKey())) html.attributes().put(attribute); } [BUGGY] } else if (StringUtil.in(name,\"base\",\"basefont\",\"bgsound\",\"command\",\"link\",\"meta\",\"noframes\",\"style\",\"title\")) { [BUGGY] return tb.process(t, InHead); } else if (name.equals(\"body\")) { tb.error(this); LinkedList<Element> stack = tb.getStack(); if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) { return false; } else { tb.framesetOk(false); Element body = stack.get(1); [CLASS] ", "output": "[PATCH] } else if (StringUtil.in(name,\"base\",\"basefont\",\"bgsound\",\"command\",\"link\",\"meta\",\"noframes\",\"script\",\"style\",\"title\")) { ", "bugid": "222"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<[0 handles0CharacterAsText . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  @Test public void handles0CharacterAsText() {  Document doc = Jsoup.parse(\"0<p>0</p>\");  assertEquals(\"0\\n<p>0</p>\", doc.body().html()); }", "input": "[BUG] [BUGGY] private static String nullString = String.valueOf(0x0000); [FE] AssertionFailedError: expected:<[0 handles0CharacterAsText [CONTEXT] return true; } }, ForeignContent { boolean process(Token t, TreeBuilder tb) { return true; } }; [BUGGY] private static String nullString = String.valueOf(0x0000); [BUGGY] abstract boolean process(Token t, TreeBuilder tb); private static boolean isWhitespace(Token t) { if (t.isCharacter()) { String data = t.asCharacter().getData(); for (int i = 0; i < data.length(); i++) { char c = data.charAt(i); if (!Character.isWhitespace(c)) [CLASS] ", "output": "[PATCH] private static String nullString = String.valueOf('\\u0000');", "bugid": "223"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<<img [src=\"cid:12345\" /> handlesCustomProtocols . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   String preserved = Jsoup.clean(html, Whitelist.basicWithImages().addProtocols(\"img\", \"src\", \"cid\", \"data\"));  assertEquals(\"<img src=\\\"cid:12345\\\" /> \\n<img src=\\\"data:gzzt\\\" />\", preserved); }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: expected:<<img [src=\"cid:12345\" /> handlesCustomProtocols [CONTEXT] private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) {  String value = el.absUrl(attr.getKey()); [BUGGY] [BUGGY] if (!preserveRelativeLinks) attr.setValue(value); for (Protocol protocol : protocols) { String prot = protocol.toString() +\":\"; if (value.toLowerCase().startsWith(prot)) { return true; } } return false; } [CLASS] Whitelist TagName AttributeKey AttributeValue Protocol TypedValue [METHOD] testValidProtocol [RETURN_TYPE] boolean Element el Attribute attr Protocol> protocols [VARIABLES] Set attributeSet currentSet protSet protocols tagNames boolean preserve preserveRelativeLinks Attribute attr Element el String key prot protocol tag tagName value Protocol protocol Map attrMap attrProts attributes enforcedAttributes protocols ", "output": "[PATCH] if (value.length() == 0) value = attr.getValue(); ", "bugid": "224"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<[One]> but was:<[]> discardsSpuriousByteOrderMark . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   ByteBuffer buffer = Charset.forName(\"UTF-8\").encode(html);  Document doc = DataUtil.parseByteData(buffer, \"UTF-8\", \"http://foo.com/\", Parser.htmlParser());  assertEquals(\"One\", doc.head().text()); }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: expected:<[One]> but was:<[]> discardsSpuriousByteOrderMark [CONTEXT] } } } else { Validate.notEmpty(charsetName,\"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\"); docData = Charset.forName(charsetName).decode(byteData).toString(); } if (doc == null) {  [BUGGY] [BUGGY] doc = parser.parseInput(docData, baseUri); doc.outputSettings().charset(charsetName); } return doc; } [CLASS] DataUtil [METHOD] parseByteData [RETURN_TYPE] Document ByteBuffer byteData String charsetName String baseUri Parser parser [VARIABLES] Pattern charsetPattern boolean Element meta String baseUri charsetName defaultCharset docData foundCharset Document doc ByteBuffer byteData int bufferSize Parser parser ", "output": "[PATCH] if (docData.charAt(0) == 65279) docData = docData.substring(1); ", "bugid": "225"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<ocumentwrite('</scr['] + 'ipt>'); handlesQuotesInCommentsInScripts . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] r.advance(); [FE] AssertionFailedError: expected:<ocumentwrite('</scr['] + 'ipt>'); handlesQuotesInCommentsInScripts [CONTEXT] void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { String name = r.consumeLetterSequence(); t.tagPending.appendTagName(name.toLowerCase()); t.dataBuffer.append(name); [BUGGY] r.advance(); [BUGGY] return; } if (t.isAppropriateEndTagToken() && !r.isEmpty()) { char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\f': case ' ': [CLASS] TokeniserState 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 [METHOD] read [RETURN_TYPE] void Tokeniser t CharacterReader r [VARIABLES] char c eof nullChar replacementChar Tokeniser t String data name replacementStr tagName CharacterReader r boolean TokeniserState AfterAttributeName AfterAttributeValue_quoted AfterDoctypeName AfterDoctypePublicIdentifier AfterDoctypePublicKeyword AfterDoctypeSystemIdentifier AfterDoctypeSystemKeyword AttributeName AttributeValue_doubleQuoted AttributeValue_singleQuoted AttributeValue_unquoted BeforeAttributeName BeforeAttributeValue BeforeDoctypeName BeforeDoctypePublicIdentifier BeforeDoctypeSystemIdentifier BetweenDoctypePublicAndSystemIdentifiers BogusComment BogusDoctype CdataSection CharacterReferenceInData CharacterReferenceInRcdata Comment CommentEnd CommentEndBang CommentEndDash CommentStart CommentStartDash Data Doctype DoctypeName DoctypePublicIdentifier_doubleQuoted DoctypePublicIdentifier_singleQuoted DoctypeSystemIdentifier_doubleQuoted DoctypeSystemIdentifier_singleQuoted EndTagOpen MarkupDeclarationOpen PLAINTEXT RCDATAEndTagName RCDATAEndTagOpen Rawtext RawtextEndTagName RawtextEndTagOpen RawtextLessthanSign Rcdata RcdataLessthanSign ScriptData ScriptDataDoubleEscapeEnd ScriptDataDoubleEscapeStart ScriptDataDoubleEscaped ScriptDataDoubleEscapedDash ScriptDataDoubleEscapedDashDash ScriptDataDoubleEscapedLessthanSign ScriptDataEndTagName ScriptDataEndTagOpen ScriptDataEscapeStart ScriptDataEscapeStartDash ScriptDataEscaped ScriptDataEscapedDash ScriptDataEscapedDashDash ScriptDataEscapedEndTagName ScriptDataEscapedEndTagOpen ScriptDataEscapedLessthanSign ScriptDataLessthanSign SelfClosingStartTag TagName TagOpen ", "output": "[PATCH] [Delete] ", "bugid": "226"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<One[ preservesSpaceInTextArea . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   String expect = \"One\\n\\tTwo\\n\\tThree\"; // the leading and trailing spaces are dropped as a convenience to authors  Element el = doc.select(\"textarea\").first();  assertEquals(expect, el.text());  assertEquals(expect, el.val());  assertEquals(expect, el.html());", "input": "[BUG] [BUGGY] private static final String[] preserveWhitespaceTags = {\"pre\",\"plaintext\",\"title\"}; [FE] AssertionFailedError: expected:<One[ preservesSpaceInTextArea [CONTEXT] [BUGGY] private static final String[] preserveWhitespaceTags = {\"pre\",\"plaintext\",\"title\"}; [CLASS] Tag [VARIABLES] ", "output": "[PATCH] private static final String[] preserveWhitespaceTags = {\"pre\",\"plaintext\",\"title\",\"textarea\"}; ", "bugid": "227"}, {"instruction": "The following code contains a buggy line with the following test error: null  handlesFramesets . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   Document dirtyDoc = Jsoup.parse(dirty);  Document cleanDoc = new Cleaner(Whitelist.basic()).clean(dirtyDoc);  assertFalse(cleanDoc == null);  assertEquals(0, cleanDoc.body().childNodes().size());", "input": "[BUG] [BUGGY] [FE] null  handlesFramesets [CONTEXT] public Document clean(Document dirtyDocument) { Validate.notNull(dirtyDocument); Document clean = Document.createShell(dirtyDocument.baseUri()); [BUGGY] [BUGGY] copySafeNodes(dirtyDocument.body(), clean.body()); return clean; } [CLASS] Cleaner ElementMeta [METHOD] clean [RETURN_TYPE] Document Document dirtyDocument [VARIABLES] Whitelist whitelist boolean Document clean dirtyDocument int numAttribsDiscarded Element el ", "output": "[PATCH] if (dirtyDocument.body() != null)", "bugid": "228"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<[utf]-8> but was:<[UTF]-8> testCharset . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] return charset; [FE] AssertionFailedError: expected:<[utf]-8> but was:<[UTF]-8> testCharset [CONTEXT] static String getCharsetFromContentType(String contentType) { if (contentType == null) return null; Matcher m = charsetPattern.matcher(contentType); if (m.find()) { String charset = m.group(1).trim(); [BUGGY] charset = charset.toUpperCase(Locale.ENGLISH); [BUGGY] return charset; } return null; } [CLASS] DataUtil [METHOD] getCharsetFromContentType [RETURN_TYPE] String String contentType [VARIABLES] Pattern charsetPattern String baseUri charset charsetName contentType defaultCharset docData foundCharset boolean Matcher m int bufferSize read ", "output": "[PATCH] if (Charset.isSupported(charset)) return charset; if (Charset.isSupported(charset)) return charset; ", "bugid": "229"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testClonesClassnames . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   copyClasses.remove(\"one\");  assertTrue(classes.contains(\"one\"));  assertFalse(classes.contains(\"three\"));  assertFalse(copyClasses.contains(\"one\"));", "input": "[BUG] [BUGGY] clone.classNames(); [FE] AssertionFailedError testClonesClassnames [CONTEXT] public Element clone() { Element clone = (Element) super.clone(); [BUGGY] clone.classNames(); [BUGGY] return clone; } [CLASS] Element [METHOD] clone [RETURN_TYPE] Element [VARIABLES] Set classNames classes Tag tag boolean Element clone ", "output": "[PATCH] clone.classNames = null; ", "bugid": "230"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<src=\"/foo\"> but was:<src=\"/foo\"> handlesKnownEmptyBlocks . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   String h = \"<div id='1' /><script src='/foo' /><div id=2><img /><img></div><a id=3 /><i /><foo /><foo>One</foo> <hr /> hr text <hr> hr text two\";  Document doc = Jsoup.parse(h);  assertEquals(\"<div id=\\\"1\\\"></div><script src=\\\"/foo\\\"></script><div id=\\\"2\\\"><img /><img /></div><a id=\\\"3\\\"></a><i></i><foo /><foo>One</foo> <hr /> hr text <hr /> hr text two\", TextUtil.stripNewlines(doc.body().html())); }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: expected:<src=\"/foo\"> but was:<src=\"/foo\"> handlesKnownEmptyBlocks [CONTEXT] Element insert(Token.StartTag startTag) {  if (startTag.isSelfClosing()) { Element el = insertEmpty(startTag); stack.add(el); [BUGGY] [BUGGY] tokeniser.emit(new Token.EndTag(el.tagName())); return el; } Element el = new Element(Tag.valueOf(startTag.name()), baseUri, startTag.attributes); insert(el); return el; } [CLASS] HtmlTreeBuilder [METHOD] insert [RETURN_TYPE] Element StartTag startTag [VARIABLES] HtmlTreeBuilderState originalState state boolean baseUriSetFromDoc fosterInserts fragmentParsing framesetOk DescendableLinkedList formattingElements Element base context contextElement el headElement parent root List pendingTableCharacters FormElement formElement StartTag startTag ", "output": "[PATCH] tokeniser.transition(TokeniserState.Data); ", "bugid": "231"}, {"instruction": "The following code contains a buggy line with the following test error: ArrayIndexOutOfBoundsException: 8 nextIndexOfUnmatched . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  @Test public void nextIndexOfUnmatched() {  CharacterReader r = new CharacterReader(\"<[[one]]\");  assertEquals(-1, r.nextIndexOf(\"]]>\")); }", "input": "[BUG] [BUGGY] if (offset < length) { [FE] ArrayIndexOutOfBoundsException: 8 nextIndexOfUnmatched [CONTEXT] int nextIndexOf(CharSequence seq) { char startChar = seq.charAt(0); for (int offset = pos; offset < length; offset++) { if (startChar != input[offset]) while(++offset < length && startChar != input[offset]); int i = offset + 1; int last = i + seq.length()-1; [BUGGY] if (offset < length) { [BUGGY] for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++); if (i == last) return offset - pos; } } return -1; } [CLASS] CharacterReader [METHOD] nextIndexOf [RETURN_TYPE] int CharSequence seq [VARIABLES] char EOF c startChar val CharSequence seq boolean int i j last length mark offset pos char[] input ", "output": "[PATCH] if (offset < length && last <= length) { ", "bugid": "232"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<com/\">Link</a> handlesUnclosedAnchors . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   Document doc = Jsoup.parse(h);  String want = \"<a href=\\\"http://example.com/\\\">Link</a>\\n<p><a href=\\\"http://example.com/\\\">Error link</a></p>\";  assertEquals(want, doc.body().html()); }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: expected:<com/\">Link</a> handlesUnclosedAnchors [CONTEXT] if (lastNode.parent() != null) lastNode.remove(); tb.insertInFosterParent(lastNode); } else { if (lastNode.parent() != null) lastNode.remove(); commonAncestor.appendChild(lastNode); } Element adopter = new Element(formatEl.tag(), tb.getBaseUri()); [BUGGY] [BUGGY] Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]); for (Node childNode : childNodes) { adopter.appendChild(childNode); } furthestBlock.appendChild(adopter); tb.removeFromActiveFormattingElements(formatEl); tb.removeFromStack(formatEl); tb.insertOnStackAfter(furthestBlock, adopter); } } else if (StringUtil.in(name,\"applet\",\"marquee\",\"object\")) { [CLASS] ", "output": "[PATCH] adopter.attributes().addAll(formatEl.attributes()); ", "bugid": "233"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<[ testNotPretty . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   Element div = doc.select(\"div\").first();  assertEquals(\"   \\n<p>Hello\\n there\\n</p>\", div.html()); }", "input": "[BUG] [BUGGY] return accum.toString().trim(); [FE] AssertionFailedError: expected:<[ testNotPretty [CONTEXT] public String html() { StringBuilder accum = new StringBuilder(); html(accum); [BUGGY] return accum.toString().trim(); [BUGGY] } [CLASS] Element 1 [METHOD] html [RETURN_TYPE] String [VARIABLES] Set classNames classes Tag tag boolean StringBuilder accum ", "output": "[PATCH] return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString(); ", "bugid": "234"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<<img /> convertsImageToImg . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   String h = \"<body><image><svg><image /></svg></body>\";  Document doc = Jsoup.parse(h);  assertEquals(\"<img />\\n<svg>\\n <image />\\n</svg>\", doc.body().html()); }", "input": "[BUG] [BUGGY] return tb.process(startTag.name(\"img\")); [FE] AssertionFailedError: expected:<<img /> convertsImageToImg [CONTEXT] tb.framesetOk(false); } else if (StringUtil.in(name, Constants.InBodyStartMedia)) { tb.insertEmpty(startTag); } else if (name.equals(\"hr\")) { if (tb.inButtonScope(\"p\")) { tb.process(new Token.EndTag(\"p\")); } tb.insertEmpty(startTag); tb.framesetOk(false); } else if (name.equals(\"image\")) { [BUGGY] return tb.process(startTag.name(\"img\")); [BUGGY] } else if (name.equals(\"isindex\")) { tb.error(this); if (tb.getFormElement() != null) return false; tb.tokeniser.acknowledgeSelfClosingFlag(); tb.process(new Token.StartTag(\"form\")); if (startTag.attributes.hasKey(\"action\")) { Element form = tb.getFormElement(); [CLASS] ", "output": "[PATCH] if (tb.getFromStack(\"svg\") == null) return tb.process(startTag.name(\"img\")); else tb.insert(startTag); ", "bugid": "235"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<[One]> but was:<[]> discardsSpuriousByteOrderMarkWhenNoCharsetSet . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   ByteBuffer buffer = Charset.forName(\"UTF-8\").encode(html);  Document doc = DataUtil.parseByteData(buffer, null, \"http://foo.com/\", Parser.htmlParser());  assertEquals(\"One\", doc.head().text());  assertEquals(\"UTF-8\", doc.outputSettings().charset().displayName()); }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: expected:<[One]> but was:<[]> discardsSpuriousByteOrderMarkWhenNoCharsetSet [CONTEXT] } else { Validate.notEmpty(charsetName,\"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\"); docData = Charset.forName(charsetName).decode(byteData).toString(); } if (docData.length() > 0 && docData.charAt(0) == 65279) { byteData.rewind(); docData = Charset.forName(defaultCharset).decode(byteData).toString(); docData = docData.substring(1); charsetName = defaultCharset; [BUGGY] [BUGGY] } if (doc == null) { doc = parser.parseInput(docData, baseUri); doc.outputSettings().charset(charsetName); } return doc; } [CLASS] DataUtil [METHOD] parseByteData [RETURN_TYPE] Document ByteBuffer byteData String charsetName String baseUri Parser parser [VARIABLES] Pattern charsetPattern IllegalCharsetNameException e boolean Element meta String baseUri charsetName defaultCharset docData foundCharset Document doc ByteBuffer byteData int bufferSize Parser parser ", "output": "[PATCH] doc = null; ", "bugid": "236"}, {"instruction": "The following code contains a buggy line with the following test error: IllegalArgumentException: String must not be empty constructorValidationOkWithBlankName . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  }", "input": "[BUG] [BUGGY] Validate.notEmpty(name); [FE] IllegalArgumentException: String must not be empty constructorValidationOkWithBlankName [CONTEXT] public DocumentType(String name, String publicId, String systemId, String baseUri) { super(baseUri); [BUGGY] Validate.notEmpty(name); [BUGGY] attr(\"name\", name); attr(\"publicId\", publicId); attr(\"systemId\", systemId); } [CLASS] DocumentType [METHOD] <init> [RETURN_TYPE] String) String name String publicId String systemId String baseUri [VARIABLES] boolean String baseUri name publicId systemId ", "output": "[PATCH] [Delete] ", "bugid": "237"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError expected testHashAndEquals . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   Element e7 = els.get(7);  assertEquals(e0, e1);  assertEquals(e0, e4);  assertEquals(e0, e5);", "input": "[BUG] [BUGGY] return this == o; [FE] AssertionFailedError expected testHashAndEquals [CONTEXT]  if (!super.equals(o)) return false; Element element = (Element) o; [BUGGY] return this == o; [BUGGY] } [CLASS] Element 1 [METHOD] equals [RETURN_TYPE] boolean Object o [VARIABLES] Object o Tag tag boolean Element element ", "output": "[PATCH] return tag.equals(element.tag); ", "bugid": "238"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testElementSiblingIndexSameContent . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   Elements ps = doc.select(\"p\");  assertTrue(0 == ps.get(0).elementSiblingIndex());  assertTrue(1 == ps.get(1).elementSiblingIndex());  assertTrue(2 == ps.get(2).elementSiblingIndex()); }", "input": "[BUG] [BUGGY] if (element.equals(search)) return i; [FE] AssertionFailedError testElementSiblingIndexSameContent [CONTEXT]  for (int i = 0; i < elements.size(); i++) { E element = elements.get(i); [BUGGY] if (element.equals(search))  return i; [BUGGY] [CLASS] Element 1 [METHOD] indexInList [RETURN_TYPE] <E Element search List<E> elements [VARIABLES] Pattern classSplit boolean E element Element search List elements Tag tag int i ", "output": "[PATCH] if (element == search) return i; ", "bugid": "239"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<1> but was:<5> testReinsertionModeForThCelss . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   String body = \"<body> <table> <tr> <th> <table><tr><td></td></tr></table> <div> <table><tr><td></td></tr></table> </div> <div></div> <div></div> <div></div> </th> </tr> </table> </body>\";  Document doc = Jsoup.parse(body);  assertEquals(1, doc.body().children().size()); }", "input": "[BUG] [BUGGY] } else if ((\"td\".equals(name) ||\"td\".equals(name) && !last)) { [FE] AssertionFailedError: expected:<1> but was:<5> testReinsertionModeForThCelss [CONTEXT] for (int pos = stack.size() -1; pos >= 0; pos--) { Element node = stack.get(pos); if (pos == 0) { last = true; node = contextElement; } String name = node.nodeName(); if (\"select\".equals(name)) { transition(HtmlTreeBuilderState.InSelect); break; [BUGGY] } else if ((\"td\".equals(name) ||\"td\".equals(name) && !last)) { [BUGGY] transition(HtmlTreeBuilderState.InCell); break; } else if (\"tr\".equals(name)) { transition(HtmlTreeBuilderState.InRow); break; } else if (\"tbody\".equals(name) ||\"thead\".equals(name) ||\"tfoot\".equals(name)) { transition(HtmlTreeBuilderState.InTableBody); break; } else if (\"caption\".equals(name)) { transition(HtmlTreeBuilderState.InCaption); [CLASS] HtmlTreeBuilder [METHOD] resetInsertionMode [RETURN_TYPE] void [VARIABLES] HtmlTreeBuilderState originalState state boolean baseUriSetFromDoc fosterInserts fragmentParsing framesetOk last onStack EndTag emptyEnd Element after base context contextElement el element headElement in next node out parent root ArrayList formattingElements queue List pendingTableCharacters String[] TagSearchButton TagSearchEndTags TagSearchList TagSearchSelectScope TagSearchSpecial TagSearchTableScope TagsScriptStyle TagsSearchInScope elNames nodeNames specificScopeTarget String name FormElement el formElement int pos ", "output": "[PATCH] } else if ((\"td\".equals(name) ||\"th\".equals(name) && !last)) { ", "bugid": "240"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Should not have contained a '?' testShiftJisRoundtrip . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   String output = new String(doc.html().getBytes(doc.outputSettings().charset()), doc.outputSettings().charset());  assertFalse(\"Should not have contained a '?'.\", output.contains(\"?\"));  assertTrue(\"Should have contained a '&#xa0;' or a '&nbsp;'.\",    output.contains(\"&#xa0;\") || output.contains(\"&nbsp;\"));", "input": "[BUG] [BUGGY] accum.append(c); [FE] AssertionFailedError: Should not have contained a '?' testShiftJisRoundtrip [CONTEXT] final char c = (char) codePoint; switch (c) { case '&': accum.append(\"&amp;\"); break; case 0xA0: if (escapeMode != EscapeMode.xhtml) accum.append(\"&nbsp;\"); else [BUGGY] accum.append(c); [BUGGY] break; case '<': if (!inAttribute) accum.append(\"&lt;\"); else accum.append(c); break; case '>': if (!inAttribute) accum.append(\"&gt;\"); [CLASS] Entities EscapeMode CoreCharset [METHOD] escape [RETURN_TYPE] void StringBuilder accum String string OutputSettings out boolean inAttribute boolean normaliseWhite boolean stripLeadingWhite [VARIABLES] boolean inAttribute lastWasWhite normaliseWhite reachedNonWhite stripLeadingWhite StringBuilder accum OutputSettings out CoreCharset ascii coreCharset fallback utf EscapeMode base escapeMode extended xhtml Object[][] xhtmlArray char c String c string Map base baseByVal full fullByVal map xhtmlByVal CharsetEncoder encoder int codePoint length offset ", "output": "[PATCH] accum.append(\"&#xa0;\"); ", "bugid": "241"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<<a title=\"[&lt;p>One&lt;]/p>\">One</a>> but was:<<a title=\"[<p>One<]/p>\">One</a>> escapesGtInXmlAttributesButNotInHtml . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   doc.outputSettings().escapeMode(xhtml);  assertEquals(\"<a title=\\\"&lt;p>One&lt;/p>\\\">One</a>\", element.outerHtml()); }", "input": "[BUG] [BUGGY] if (!inAttribute) [FE] AssertionFailedError: expected:<<a title=\"[&lt;p>One&lt;]/p>\">One</a>> but was:<<a title=\"[<p>One<]/p>\">One</a>> escapesGtInXmlAttributesButNotInHtml [CONTEXT] accum.append(\"&amp;\"); break; case 0xA0: if (escapeMode != EscapeMode.xhtml) accum.append(\"&nbsp;\"); else accum.append(\"&#xa0;\"); break; case '<': [BUGGY] if (!inAttribute) [BUGGY] accum.append(\"&lt;\"); else accum.append(c); break; case '>': if (!inAttribute) accum.append(\"&gt;\"); else accum.append(c); break; [CLASS] Entities EscapeMode CoreCharset [METHOD] escape [RETURN_TYPE] void StringBuilder accum String string OutputSettings out boolean inAttribute boolean normaliseWhite boolean stripLeadingWhite [VARIABLES] boolean inAttribute lastWasWhite normaliseWhite reachedNonWhite stripLeadingWhite StringBuilder accum OutputSettings out CoreCharset ascii coreCharset fallback utf EscapeMode base escapeMode extended xhtml Object[][] xhtmlArray char c String c string Map base baseByVal full fullByVal map xhtmlByVal CharsetEncoder encoder int codePoint length offset ", "output": "[PATCH] if (!inAttribute || escapeMode == EscapeMode.xhtml) ", "bugid": "242"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<no-cache[, no-store]> but was:<no-cache[]> sameHeadersCombineWithComma . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   HttpConnection.Response res = new HttpConnection.Response();  res.processResponseHeaders(headers);  assertEquals(\"no-cache, no-store\", res.header(\"Cache-Control\")); }", "input": "[BUG] [BUGGY] if (!values.isEmpty()) [FE] AssertionFailedError: expected:<no-cache[, no-store]> but was:<no-cache[]> sameHeadersCombineWithComma [CONTEXT] continue; TokenQueue cd = new TokenQueue(value); String cookieName = cd.chompTo(\"=\").trim(); String cookieVal = cd.consumeTo(\";\").trim();  if (cookieName.length() > 0) cookie(cookieName, cookieVal); } } else { [BUGGY] if (!values.isEmpty()) [BUGGY] header(name, values.get(0)); } } } [CLASS] HttpConnection Base Request Response 1 2 KeyVal [METHOD] processResponseHeaders [RETURN_TYPE] void String>> resHeaders [VARIABLES] Pattern xmlContentTypeRxp TokenQueue cd InputStream bodyStream dataStream inputStream stream Request req request String CONTENT_ENCODING CONTENT_TYPE FORM_URL_ENCODED LOCATION MULTIPART_FORM_DATA authType body charset contentType cookieName cookieVal filename key lc location mimeBoundary name postDataCharset protocol referrer statusMessage url urlHostName userAgent val value Method method ByteBuffer byteData URL url int MAX_REDIRECTS bytes i maxBodySizeBytes millis numRedirects status statusCode timeoutMilliseconds Parser parser Response previousResponse res response Entry entry boolean executed followRedirects ignoreContentType ignoreHttpErrors parserDefined validateTSLCertificates value Collection data List values SSLSocketFactory sslSocketFactory Map cookies data headers resHeaders ", "output": "[PATCH] if (values.size() == 1) else if (values.size() > 1) { StringBuilder accum = new StringBuilder(); for (int i = 0; i < values.size(); i++) { final String val = values.get(i); if (i != 0) accum.append(\",\"); accum.append(val); } header(name, accum.toString()); } ", "bugid": "243"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<><div3>Check</div3><[div4></div4><div1></div1><div2></div2><]/body>> but was:<><div3>Check</div3><[]/body>> appendMustCorrectlyMoveChildrenInsideOneParentElement . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   final Element div3 = body.appendElement(\"div3\");  div3.text(\"Check\");  final Element div4 = body.appendElement(\"div4\");  ArrayList<Element> toMove = new ArrayList<Element>();", "input": "[BUG] [BUGGY] } reindexChildren(index); [FE] AssertionFailedError: expected:<><div3>Check</div3><[div4></div4><div1></div1><div2></div2><]/body>> but was:<><div3>Check</div3><[]/body>> appendMustCorrectlyMoveChildrenInsideOneParentElement [CONTEXT] protected void addChildren(int index, Node... children) { Validate.noNullElements(children); ensureChildNodes(); for (int i = children.length - 1; i >= 0; i--) { Node in = children[i]; reparentChild(in); childNodes.add(index, in); [BUGGY] } [BUGGY] reindexChildren(index); } [CLASS] Node 1 OuterHtmlVisitor [METHOD] addChildren [RETURN_TYPE] void int index children [VARIABLES] Node[] children boolean StringBuilder accum OutputSettings out Node child firstChild in node out parentNode remainder wrapNode Attributes attributes List EMPTY_NODES childNodes children nodes wrapChildren String attributeKey attributeValue baseUri html key int depth i index siblingIndex ", "output": "[PATCH] reindexChildren(index); } ", "bugid": "244"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<[Yes]> but was:<[]> testSupportsNonAsciiTags . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   Document doc = Jsoup.parse(body);  Elements els = doc.select(\"\u9032\u6357\u63a8\u79fb\u30b0\u30e9\u30d5\");  assertEquals(\"Yes\", els.text()); }", "input": "[BUG] [BUGGY] return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'); [FE] AssertionFailedError: expected:<[Yes]> but was:<[]> testSupportsNonAsciiTags [CONTEXT] boolean matchesLetter() { if (isEmpty()) return false; char c = input[pos]; [BUGGY] return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'); [BUGGY] } [CLASS] CharacterReader [METHOD] matchesLetter [RETURN_TYPE] boolean [VARIABLES] char EOF c seek startChar upScan upTarget val String[] stringCache boolean int i j last length mark maxCacheLen offset pos remaining scanLength start char[] chars input seq val ", "output": "[PATCH] return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c); ", "bugid": "245"}, {"instruction": "The following code contains a buggy line with the following test error: domDOMException: INVALID_CHARACTER_ERR: An invalid or illegal XML character is specified handlesInvalidAttributeNames . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertTrue(body.hasAttr(\"name\\\"\"));  Document w3Doc = new W3CDom().fromJsoup(jsoupDoc); }", "input": "[BUG] [BUGGY] [FE] domDOMException: INVALID_CHARACTER_ERR: An invalid or illegal XML character is specified handlesInvalidAttributeNames [CONTEXT] private void copyAttributes(org.jsoup.nodes.Node source, Element el) { for (Attribute attribute : source.attributes()) { String key = attribute.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\",\"\"); [BUGGY] [BUGGY] el.setAttribute(key, attribute.getValue()); } } [CLASS] W3CDom W3CBuilder [METHOD] copyAttributes [RETURN_TYPE] void Node source Element el [VARIABLES] DocumentBuilderFactory factory boolean HashMap namespaces Attribute attribute Element dest el rootEl sourceEl Node source String key namespace prefix xmlnsKey xmlnsPrefix Document doc in out ", "output": "[PATCH] if (key.matches(\"[a-zA-Z_:]{1}[-a-zA-Z0-9_:.]*\")) ", "bugid": "246"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError dropsSlashFromAttributeName . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   String html = \"<img /onerror='doMyJob'/>\";  Document doc = Jsoup.parse(html);  assertTrue(\"SelfClosingStartTag ignores last character\", doc.select(\"img[onerror]\").size() != 0);  assertEquals(\"<img onerror=\\\"doMyJob\\\">\", doc.body().html());", "input": "[BUG] [BUGGY] [FE] AssertionFailedError dropsSlashFromAttributeName [CONTEXT]  case eof: t.eofError(this); t.transition(Data); break; default: [BUGGY] [BUGGY] t.error(this);  t.transition(BeforeAttributeName);  [CLASS] TokeniserState  [METHOD] read [RETURN_TYPE] void Tokeniser t CharacterReader r [VARIABLES] CharacterReader r char c eof nullChar replacementChar Tokeniser t String data name replacementStr tagName value ", "output": "[PATCH] r.unconsume(); ", "bugid": "247"}, {"instruction": "The following code contains a buggy line with the following test error: ConcurrentModificationException testChainedRemoveAttributes . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   Document doc = Jsoup.parse(html);  Element a = doc.select(\"a\").first();  a   .removeAttr(\"zero\")   .removeAttr(\"one\")", "input": "[BUG] [BUGGY] attributes.remove(attrKey); [FE] ConcurrentModificationException testChainedRemoveAttributes [CONTEXT] public void removeIgnoreCase(String key) { Validate.notEmpty(key); if (attributes == null) return; for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) { String attrKey = it.next(); if (attrKey.equalsIgnoreCase(key)) [BUGGY] attributes.remove(attrKey); [BUGGY] } } [CLASS] Attributes Dataset EntrySet DatasetIterator [METHOD] removeIgnoreCase [RETURN_TYPE] void String key [VARIABLES] Iterator attrIter it String attrKey dataPrefix key value boolean Attribute attr attribute LinkedHashMap attributes ", "output": "[PATCH] it.remove(); ", "bugid": "248"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError hasClassCaseInsensitive . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   Element thr = els.get(2);  assertTrue(one.hasClass(\"One\"));  assertTrue(one.hasClass(\"ONE\"));", "input": "[BUG] [BUGGY] final String classAttr = attributes.get(\"class\"); [FE] AssertionFailedError hasClassCaseInsensitive [CONTEXT] public boolean hasClass(String className) { [BUGGY] final String classAttr = attributes.get(\"class\"); [BUGGY] final int len = classAttr.length(); final int wantLen = className.length(); if (len == 0 || len < wantLen) { return false; } if (len == wantLen) { return className.equalsIgnoreCase(classAttr); [CLASS] Element 1 [METHOD] hasClass [RETURN_TYPE] boolean String className [VARIABLES] Pattern classSplit pattern Tag tag String classAttr className boolean inClass int i len start wantLen ", "output": "[PATCH] final String classAttr = attributes.getIgnoreCase(\"class\"); ", "bugid": "249"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<<r> <X> A <[/X> <y> B </y]> </r>> but was:<<r> <X> A <[y> B </y> </X]> </r>> caseSensitiveParseTree . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   parser.settings(ParseSettings.preserveCase);  Document doc = parser.parseInput(html, \"\");  assertEquals(\"<r> <X> A </X> <y> B </y> </r>\", StringUtil.normaliseWhitespace(doc.body().html())); }", "input": "[BUG] [BUGGY] String name = t.asEndTag().normalName(); [FE] AssertionFailedError: expected:<<r> <X> A <[/X> <y> B </y]> </r>> but was:<<r> <X> A <[y> B </y> </X]> </r>> caseSensitiveParseTree [CONTEXT] break; case EOF:  break; } return true; } boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) { [BUGGY] String name = t.asEndTag().normalName(); [BUGGY] ArrayList<Element> stack = tb.getStack(); for (int pos = stack.size() -1; pos >= 0; pos--) { Element node = stack.get(pos); if (node.nodeName().equals(name)) { tb.generateImpliedEndTags(name); if (!name.equals(tb.currentElement().nodeName())) tb.error(this); tb.popStackToClose(name); break; } else { [CLASS] ", "output": "[PATCH] String name = t.asEndTag().name(); ", "bugid": "250"}, {"instruction": "The following code contains a buggy line with the following test error: StackOverflowError testHandlesDeepSpans . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: None", "input": "[BUG] [BUGGY] int bottom = stack.size() -1; if (bottom > MaxScopeSearchDepth) { bottom = MaxScopeSearchDepth; } [FE] StackOverflowError testHandlesDeepSpans [CONTEXT] private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) { [BUGGY] int bottom = stack.size() -1; if (bottom > MaxScopeSearchDepth) { bottom = MaxScopeSearchDepth; } [BUGGY] final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0; for (int pos = bottom; pos >= top; pos--) { final String elName = stack.get(pos).nodeName(); if (inSorted(elName, targetNames)) return true; [CLASS] HtmlTreeBuilder [METHOD] inSpecificScope [RETURN_TYPE] boolean String[] targetNames String[] baseTypes String[] extraTypes [VARIABLES] HtmlTreeBuilderState originalState state boolean baseUriSetFromDoc fosterInserts fragmentParsing framesetOk last onStack EndTag emptyEnd Element after base context contextElement el element headElement in next node out parent root ArrayList formattingElements queue List pendingTableCharacters String[] TagSearchButton TagSearchEndTags TagSearchList TagSearchSelectScope TagSearchSpecial TagSearchTableScope TagsSearchInScope baseTypes elNames extraTypes nodeNames specificScopeTarget targetNames String elName int MaxScopeSearchDepth bottom i pos size top FormElement el formElement ", "output": "[PATCH] final int bottom = stack.size() -1; ", "bugid": "251"}, {"instruction": "The following code contains a buggy line with the following test error: StringIndexOutOfBoundsException: String index out of range: -1 consumeToNonexistentEndWhenAtAnd . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertTrue(r.isEmpty());  String after = r.consumeTo('>');  assertEquals(\"\", after);", "input": "[BUG] [BUGGY] [FE] StringIndexOutOfBoundsException: String index out of range: -1 consumeToNonexistentEndWhenAtAnd [CONTEXT] private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) { if (count > maxStringCacheLen) return new String(charBuf, start, count); [BUGGY] [BUGGY] int hash = 0; int offset = start; for (int i = 0; i < count; i++) { hash = 31 * hash + charBuf[offset++]; } final int index = hash & stringCache.length - 1; String cached = stringCache[index]; [CLASS] CharacterReader [METHOD] cacheString [RETURN_TYPE] String final char[] charBuf String[] stringCache final int start final int count [VARIABLES] boolean char EOF c seek startChar upScan upTarget val Reader input reader String[] stringCache String cached int bufLength bufMark bufPos bufSplitPoint count hash i index j last maxBufferLen maxStringCacheLen offset readAheadLimit readerPos remaining scanLength start sz char[] charBuf chars seq val ", "output": "[PATCH] if (count < 1) return\"\"; ", "bugid": "254"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<mg src=\"foo\" noshade[] nohref async autofo> but was:<mg src=\"foo\" noshade[=\"\"] nohref async autofo> booleanAttributeOutput . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   Element img = doc.selectFirst(\"img\");  assertEquals(\"<img src=\\\"foo\\\" noshade nohref async autofocus=\\\"false\\\">\", img.outerHtml()); }", "input": "[BUG] [BUGGY] if (!(out.syntax() == Document.OutputSettings.Syntax.html && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) { [FE] AssertionFailedError: expected:<mg src=\"foo\" noshade[] nohref async autofo> but was:<mg src=\"foo\" noshade[=\"\"] nohref async autofo> booleanAttributeOutput [CONTEXT] final void html(final Appendable accum, final Document.OutputSettings out) throws IOException { final int sz = size; for (int i = 0; i < sz; i++) { final String key = keys[i]; final String val = vals[i]; accum.append(' ').append(key);  [BUGGY] if (!(out.syntax() == Document.OutputSettings.Syntax.html && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) { [BUGGY] accum.append(\"=\\\"\"); Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false); accum.append('\"'); } } } [CLASS] Attributes 1 Dataset EntrySet DatasetIterator [METHOD] html [RETURN_TYPE] void Appendable accum OutputSettings out [VARIABLES] boolean OutputSettings out Attribute attr attribute Appendable accum Attributes attributes incoming Iterator attrIter String EmptyString dataPrefix key val value String[] Empty copy keys orig vals int GrowthFactor InitialCapacity NotFound curSize i index minNewSize newSize shifted size sz ", "output": "[PATCH] if (!Attribute.shouldCollapseAttribute(key, val, out)) { ", "bugid": "255"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<preSkipsFirstNewline . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   Element pre = doc.selectFirst(\"pre\");  assertEquals(\"One\\nTwo\", pre.text());  assertEquals(\"\\nOne\\nTwo\\n\", pre.wholeText());  }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: expected:<preSkipsFirstNewline [CONTEXT] if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) { tb.error(this); tb.pop(); } tb.insert(startTag); } else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) { if (tb.inButtonScope(\"p\")) { tb.processEndTag(\"p\"); } tb.insert(startTag); [BUGGY] [BUGGY] tb.framesetOk(false); } else if (name.equals(\"form\")) { if (tb.getFormElement() != null) { tb.error(this); return false; } if (tb.inButtonScope(\"p\")) { tb.processEndTag(\"p\"); } tb.insertForm(startTag, true); } else if (StringUtil.inSorted(name, Constants.DdDt)) { [CLASS] ", "output": "[PATCH] tb.reader.matchConsume(\"\\n\"); ", "bugid": "256"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<<div> normalizesDiscordantTags . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   Parser parser = Parser.xmlParser().settings(ParseSettings.htmlDefault);  Document document = Jsoup.parse(\"<div>test</DIV><p></p>\", \"\", parser);  assertEquals(\"<div>\\n test\\n</div>\\n<p></p>\", document.html());  // was failing -> toString() = \"<div>\\n test\\n <p></p>\\n</div>\" }", "input": "[BUG] [BUGGY] String elName = endTag.name(); [FE] AssertionFailedError: expected:<<div> normalizesDiscordantTags [CONTEXT] private void popStackToClose(Token.EndTag endTag) { [BUGGY] String elName = endTag.name(); [BUGGY] Element firstFound = null; for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (next.nodeName().equals(elName)) { firstFound = next; break; } } if (firstFound == null) [CLASS] XmlTreeBuilder [METHOD] popStackToClose [RETURN_TYPE] void EndTag endTag [VARIABLES] boolean EndTag endTag Element firstFound next String elName int pos ", "output": "[PATCH] String elName = endTag.normalName(); ", "bugid": "257"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<[UTF-8]> but was:<[ISO-2022-CN]> fallbackToUtfIfCantEncode . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   Document doc = Jsoup.parse(new ByteArrayInputStream(in.getBytes()), null, \"\");  assertEquals(\"UTF-8\", doc.charset().name());  assertEquals(\"One\", doc.text());", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: expected:<[UTF-8]> but was:<[ISO-2022-CN]> fallbackToUtfIfCantEncode [CONTEXT] if (bomCharset != null && bomCharset.offset) reader.skip(1); try { doc = parser.parseInput(reader, baseUri); } catch (UncheckedIOException e) { throw e.ioException(); } Charset charset = Charset.forName(charsetName); doc.outputSettings().charset(charset); [BUGGY] [BUGGY] } input.close(); return doc; } [CLASS] DataUtil BomCharset [METHOD] parseInputStream [RETURN_TYPE] Document InputStream input String charsetName String baseUri Parser parser [VARIABLES] Pattern charsetPattern Comment comment InputStream input Element meta Node first Charset charset UncheckedIOException e String baseUri charset charsetName defaultCharset docData foundCharset Document doc Elements metaElements ByteBuffer firstBytes BomCharset bomCharset int boundaryLength bufferSize firstReadBufferSize len char[] mimeBoundaryChars Parser parser boolean fullyRead offset BufferedReader reader XmlDeclaration decl ", "output": "[PATCH] if (!charset.canEncode()) { doc.charset(Charset.forName(defaultCharset)); } ", "bugid": "258"}, {"instruction": "The following code contains a buggy line with the following test error: domDOMException: NAMESPACE_ERR: An attempt is made to create or change an object in a way which is incorrect with regard to namespaces treatsUndeclaredNamespaceAsLocalName . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   org.jsoup.nodes.Document doc = Jsoup.parse(html);  Document w3Doc = new W3CDom().fromJsoup(doc);  Node htmlEl = w3Doc.getFirstChild();", "input": "[BUG] [BUGGY] Element el = doc.createElementNS(namespace, tagName); [FE] domDOMException: NAMESPACE_ERR: An attempt is made to create or change an object in a way which is incorrect with regard to namespaces treatsUndeclaredNamespaceAsLocalName [CONTEXT] public void head(org.jsoup.nodes.Node source, int depth) { namespacesStack.push(new HashMap<>(namespacesStack.peek())); if (source instanceof org.jsoup.nodes.Element) { org.jsoup.nodes.Element sourceEl = (org.jsoup.nodes.Element) source; String prefix = updateNamespaces(sourceEl); String namespace = namespacesStack.peek().get(prefix); String tagName = sourceEl.tagName(); [BUGGY] Element el = doc.createElementNS(namespace, tagName); [BUGGY] copyAttributes(sourceEl, el); if (dest == null) { doc.appendChild(el); } else { dest.appendChild(el); } dest = el; } else if (source instanceof org.jsoup.nodes.TextNode) { org.jsoup.nodes.TextNode sourceText = (org.jsoup.nodes.TextNode) source; [CLASS] W3CDom W3CBuilder [METHOD] head [RETURN_TYPE] void Node source int depth [VARIABLES] Comment comment sourceComment DocumentBuilderFactory factory boolean DataNode sourceData Element dest el rootEl sourceEl Node source TextNode sourceText Text node text String namespace prefix tagName xmlnsKey xmlnsPrefix Document doc in out int depth Stack namespacesStack ", "output": "[PATCH] Element el = namespace == null && tagName.contains(\":\") ? doc.createElementNS(\"\", tagName) : doc.createElementNS(namespace, tagName); ", "bugid": "259"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Expected exception: javalangIllegalArgumentException validatesKeysNotEmpty . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: None", "input": "[BUG] [BUGGY] this.key = key.trim(); [FE] AssertionFailedError: Expected exception: javalangIllegalArgumentException validatesKeysNotEmpty [CONTEXT] public Attribute(String key, String val, Attributes parent) { Validate.notNull(key); [BUGGY] this.key = key.trim(); [BUGGY] Validate.notEmpty(key); this.val = val; this.parent = parent; } [CLASS] Attribute [METHOD] <init> [RETURN_TYPE] Attributes) String key String val Attributes parent [VARIABLES] Attributes parent String[] booleanAttributes String key val value boolean ", "output": "[PATCH] key = key.trim(); this.key = key; ", "bugid": "260"}, {"instruction": "The following code contains a buggy line with the following test error: IndexOutOfBoundsException: Index: 0, Size: 0 handlesLTinScript . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   // https://github.com/jhy/jsoup/issues/1139  String html = \"<script> var a=\\\"<?\\\"; var b=\\\"?>\\\"; </script>\";  Document doc = Jsoup.parse(html, \"\", Parser.xmlParser());  assertEquals(\"<script> var a=\\\"\\n <!--?\\\"; var b=\\\"?-->\\\"; </script>\", doc.html()); // converted from pseudo xmldecl to comment }", "input": "[BUG] [BUGGY] if (doc.childNodeSize() > 0) { [FE] IndexOutOfBoundsException: Index: 0, Size: 0 handlesLTinScript [CONTEXT] public XmlDeclaration asXmlDeclaration() { String data = getData(); Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) +\">\", baseUri(), Parser.xmlParser()); XmlDeclaration decl = null; [BUGGY] if (doc.childNodeSize() > 0) { [BUGGY] Element el = doc.child(0); decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\")); decl.attributes().addAll(el.attributes()); } return decl; } [CLASS] Comment [METHOD] asXmlDeclaration [RETURN_TYPE] XmlDeclaration [VARIABLES] XmlDeclaration decl String COMMENT_KEY baseUri data boolean Document doc Element el ", "output": "[PATCH] if (doc.children().size() > 0) { ", "bugid": "261"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<> but was:<null> booleanAttributesAreEmptyStringValues . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   Attribute first = attributes.iterator().next();  assertEquals(\"hidden\", first.getKey());  assertEquals(\"\", first.getValue()); }", "input": "[BUG] [BUGGY] return val; [FE] AssertionFailedError: expected:<> but was:<null> booleanAttributesAreEmptyStringValues [CONTEXT] public String getValue() { [BUGGY] return val; [BUGGY] } [CLASS] Attribute [METHOD] getValue [RETURN_TYPE] String [VARIABLES] Attributes parent String[] booleanAttributes String key val value boolean ", "output": "[PATCH] return Attributes.checkNotNull(val); ", "bugid": "262"}, {"instruction": "The following code contains a buggy line with the following test error: null  settersOnOrphanAttribute . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   Attribute attr = new Attribute(\"one\", \"two\");  attr.setKey(\"three\");  String oldVal = attr.setValue(\"four\");  assertEquals(\"two\", oldVal);  assertEquals(\"three\", attr.getKey());", "input": "[BUG] [BUGGY] String oldVal = parent.get(this.key); [FE] null  settersOnOrphanAttribute [CONTEXT] public String setValue(String val) { [BUGGY] String oldVal = parent.get(this.key); [BUGGY] if (parent != null) { int i = parent.indexOfKey(this.key); if (i != Attributes.NotFound) parent.vals[i] = val; } this.val = val; return Attributes.checkNotNull(oldVal); } [CLASS] Attribute [METHOD] setValue [RETURN_TYPE] String String val [VARIABLES] Attributes parent String[] booleanAttributes String key oldVal val value boolean int i ", "output": "[PATCH] String oldVal = this.val; oldVal = parent.get(this.key); ", "bugid": "263"}, {"instruction": "The following code contains a buggy line with the following test error: ArrayIndexOutOfBoundsException: 1 handlesHeaderEncodingOnRequest . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  @Test public void handlesHeaderEncodingOnRequest() {  Connection.Request req = new HttpConnection.Request();  req.addHeader(\"xxx\", \"\u00e9\"); }", "input": "[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException: 1 handlesHeaderEncodingOnRequest [CONTEXT] if ((o & 0xE0) == 0xC0) { end = i + 1; } else if ((o & 0xF0) == 0xE0) { end = i + 2; } else if ((o & 0xF8) == 0xF0) { end = i + 3; } else { return false; } [BUGGY] [BUGGY] while (i < end) { i++; o = input[i]; if ((o & 0xC0) != 0x80) { return false; } } } return true; } [CLASS] HttpConnection Base Request Response KeyVal [METHOD] looksLikeUtf8 [RETURN_TYPE] boolean byte[] input [VARIABLES] Pattern xmlContentTypeRxp InputStream bodyStream inputStream stream Request req request String CONTENT_ENCODING CONTENT_TYPE DEFAULT_UA DefaultUploadType FORM_URL_ENCODED LOCATION MULTIPART_FORM_DATA USER_AGENT body charset contentType filename host key name postDataCharset referrer statusMessage url urlS userAgent val value Method method ByteBuffer byteData int HTTP_TEMP_REDIR MAX_REDIRECTS bytes end i j maxBodySizeBytes millis numRedirects o port statusCode timeoutMilliseconds URL u url Parser parser Response previousResponse res response byte[] input Proxy proxy boolean executed followRedirects ignoreContentType ignoreHttpErrors inputStreamRead parserDefined HttpURLConnection conn Collection data SSLSocketFactory sslSocketFactory Map cookies data headers ", "output": "[PATCH] if (end >= input.length) return false; ", "bugid": "264"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<6> but was:<7> createsFormData . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   List<Connection.KeyVal> data = form.formData();  assertEquals(6, data.size());  assertEquals(\"one=two\", data.get(0).toString());  assertEquals(\"three=four\", data.get(1).toString());", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: expected:<6> but was:<7> createsFormData [CONTEXT] ArrayList<Connection.KeyVal> data = new ArrayList<>(); for (Element el: elements) { if (!el.tag().isFormSubmittable()) continue; if (el.hasAttr(\"disabled\")) continue; String name = el.attr(\"name\"); if (name.length() == 0) continue; String type = el.attr(\"type\"); [BUGGY] [BUGGY] if (\"select\".equals(el.normalName())) { Elements options = el.select(\"option[selected]\"); boolean set = false; for (Element option: options) { data.add(HttpConnection.KeyVal.create(name, option.val())); set = true; } if (!set) { Element option = el.select(\"option\").first(); if (option != null) [CLASS] FormElement [METHOD] formData [RETURN_TYPE] List [VARIABLES] ArrayList data String name type val boolean set Elements elements options Element el option ", "output": "[PATCH] if (type.equalsIgnoreCase(\"button\")) continue; ", "bugid": "265"}, {"instruction": "The following code contains a buggy line with the following test error: jacksondatabindJsonMappingException: No serializer found for class comfasterxmljacksondatabindintrospectTestMixinMerging$PersonImpl and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeatureFAIL_ON_EMPTY_BEANS) ) testDisappearingMixins515 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   mapper.registerModule(module);  assertEquals(\"{\\\"city\\\":\\\"Seattle\\\"}\", mapper.writeValueAsString(new PersonImpl())); }", "input": "[BUG] [BUGGY] [FE] jacksondatabindJsonMappingException: No serializer found for class comfasterxmljacksondatabindintrospectTestMixinMerging$PersonImpl and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeatureFAIL_ON_EMPTY_BEANS) ) testDisappearingMixins515 [CONTEXT] if (am != null) { _addMixUnders(m, am); } else { [BUGGY] [BUGGY] mixIns.add(_constructMethod(m)); } [CLASS] AnnotatedClass [METHOD] _addMethodMixIns [RETURN_TYPE] void Class<?> targetClass AnnotatedMethodMap methods Class<?> mixInCls AnnotatedMethodMap mixIns [VARIABLES] AnnotationMap[] NO_ANNOTATION_MAPS MixInResolver _mixInResolver mir boolean _creatorsResolved AnnotatedConstructor _defaultConstructor AnnotationMap _classAnnotations ann annotations classAnnotations AnnotatedMethod am AnnotationIntrospector _annotationIntrospector aintr Class _class _primaryMixIn acls cls mixInCls mixin parent targetClass toMask List _constructors _creatorMethods _fields _superTypes constructors creatorMethods parents superTypes AnnotatedMethodMap _memberMethods methods mixIns mixins Method m ", "output": "[PATCH] am = mixIns.find(m); if (am != null) { _addMixUnders(m, am); } else { } ", "bugid": "266"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<{\"[]javalangString\":2}> but was:<{\"[class ]javalangString\":2}> testClassKey . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   map.put(String.class, 2);  String json = MAPPER.writeValueAsString(map);  assertEquals(aposToQuotes(\"{'java.lang.String':2}\"), json); }", "input": "[BUG] [BUGGY] if (value instanceof Date) { [FE] ComparisonFailure: expected:<{\"[]javalangString\":2}> but was:<{\"[class ]javalangString\":2}> testClassKey [CONTEXT] public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException { String str; [BUGGY] [BUGGY] if (value instanceof Date) { provider.defaultSerializeDateKey((Date) value, jgen); return; } else { str = value.toString(); } jgen.writeFieldName(str); } [CLASS] StdKeySerializer [METHOD] serialize [RETURN_TYPE] void Object value JsonGenerator jgen SerializerProvider provider [VARIABLES] boolean JsonGenerator jgen Object value String str SerializerProvider provider ", "output": "[PATCH] Class<?> cls = value.getClass(); if (cls == String.class) { str = (String) value; } else if (Date.class.isAssignableFrom(cls)) { } else if (cls == Class.class) { str = ((Class<?>) value).getName(); ", "bugid": "267"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<1> but was:<100> testCustomMapValueDeser735 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertEquals(100, bean.map1.get(\"a\").intValue());  assertEquals(1, bean.map2.get(\"a\").intValue()); }", "input": "[BUG] [BUGGY] return (_valueTypeDeserializer == null) && (_ignorableProperties == null); [FE] AssertionFailedError: expected:<1> but was:<100> testCustomMapValueDeser735 [CONTEXT] public boolean isCachable() {  [BUGGY] return (_valueTypeDeserializer == null) && (_ignorableProperties == null); [BUGGY] } [CLASS] MapDeserializer MapReferringAccumulator MapReferring [METHOD] isCachable [RETURN_TYPE] boolean [VARIABLES] ValueInstantiator _valueInstantiator valueInstantiator JsonDeserializer _delegateDeserializer _valueDeserializer valueDeser vd PropertyBasedCreator _propertyBasedCreator long serialVersionUID KeyDeserializer _keyDeserializer kd keyDeser JavaType _mapType delegateType keyType mapType boolean _hasDefaultCreator _standardStringKey MapReferringAccumulator _parent parent Class _valueType rawKeyType valueType List _accumulator Object key TypeDeserializer _valueTypeDeserializer valueTypeDeser vtd Map _result next result HashSet _ignorableProperties ignorable ignored ", "output": "[PATCH] return (_valueDeserializer == null) && (_keyDeserializer == null) && (_valueTypeDeserializer == null) && (_ignorableProperties == null); ", "bugid": "268"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<{\"[bar]\":\"result\"}> but was:<{\"[stuff]\":\"result\"}> testMixinWithBundles . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   ObjectMapper mapper = new ObjectMapper().addMixIn(Foo.class, FooMixin.class);  String result = mapper.writeValueAsString(new Foo(\"result\"));  assertEquals(\"{\\\"bar\\\":\\\"result\\\"}\", result); }", "input": "[BUG] [BUGGY] return (previous != null) && previous.equals(ann); [FE] ComparisonFailure: expected:<{\"[bar]\":\"result\"}> but was:<{\"[stuff]\":\"result\"}> testMixinWithBundles [CONTEXT] protected final boolean _add(Annotation ann) { if (_annotations == null) { _annotations = new HashMap<Class<? extends Annotation>,Annotation>(); } Annotation previous = _annotations.put(ann.annotationType(), ann); [BUGGY] return (previous != null) && previous.equals(ann); [BUGGY] } [CLASS] AnnotationMap [METHOD] _add [RETURN_TYPE] boolean Annotation ann [VARIABLES] HashMap _annotations a annotations Annotation ann previous boolean ", "output": "[PATCH] return (previous == null) || !previous.equals(ann); ", "bugid": "269"}, {"instruction": "The following code contains a buggy line with the following test error: jacksondatabindJsonMappingException: Unexpected token (VALUE_NUMBER_INT), expected VALUE_STRING: need JSON String that contains type id (for subtype of comfasterxmljacksondatabindJsonNode) testArrayWithDefaultTyping . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    .enableDefaultTyping();  JsonNode array = mapper.readTree(\"[ 1, 2 ]\");  assertTrue(array.isArray());  assertEquals(2, array.size());", "input": "[BUG] [BUGGY] || TreeNode.class.isAssignableFrom(t.getRawClass())); [FE] jacksondatabindJsonMappingException: Unexpected token (VALUE_NUMBER_INT), expected VALUE_STRING: need JSON String that contains type id (for subtype of comfasterxmljacksondatabindJsonNode) testArrayWithDefaultTyping [CONTEXT] case NON_CONCRETE_AND_ARRAYS: while (t.isArrayType()) { t = t.getContentType(); } case OBJECT_AND_NON_CONCRETE: return (t.getRawClass() == Object.class) || (!t.isConcrete() [BUGGY] || TreeNode.class.isAssignableFrom(t.getRawClass())); [BUGGY] case NON_FINAL: while (t.isArrayType()) { t = t.getContentType(); } return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass()); default:  [CLASS] ObjectMapper DefaultTyping DefaultTypeResolverBuilder 1 [METHOD] useForType [RETURN_TYPE] boolean JavaType t [VARIABLES] RootNameLookup _rootNames SerializerFactory _serializerFactory DefaultDeserializationContext _deserializationContext dc SubtypeResolver _subtypeResolver HashMap _mixInAnnotations mixins SerializationConfig _serializationConfig config DefaultSerializerProvider _serializerProvider sp AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR JsonFactory _jsonFactory jf DeserializationConfig _deserializationConfig config InjectableValues _injectableValues long serialVersionUID ClassIntrospector DEFAULT_INTROSPECTOR JavaType JSON_NODE_TYPE baseType t PrettyPrinter _defaultPrettyPrinter boolean VisibilityChecker STD_VISIBILITY_CHECKER BaseSettings DEFAULT_BASE DefaultTyping JAVA_LANG_OBJECT NON_CONCRETE_AND_ARRAYS NON_FINAL OBJECT_AND_NON_CONCRETE _appliesFor t TypeFactory _typeFactory ConcurrentHashMap _rootDeserializers ", "output": "[PATCH] && !TreeNode.class.isAssignableFrom(t.getRawClass())); ", "bugid": "270"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<129> but was:<null> testMapToProperties . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertEquals(\"13\", props.getProperty(\"B\"));  // should coercce non-Strings to Strings  assertEquals(\"129\", props.getProperty(\"A\")); }", "input": "[BUG] [BUGGY] [FE] ComparisonFailure: expected:<129> but was:<null> testMapToProperties [CONTEXT] private JavaType _mapType(Class<?> rawClass) { [BUGGY] [BUGGY] JavaType[] typeParams = findTypeParameters(rawClass, Map.class); if (typeParams == null) { return MapType.construct(rawClass, _unknownType(), _unknownType()); } if (typeParams.length != 2) { throw new IllegalArgumentException(\"Strange Map type\"+rawClass.getName()+\": can not determine type parameters\"); } return MapType.construct(rawClass, typeParams[0], typeParams[1]); } [CLASS] TypeFactory [METHOD] _mapType [RETURN_TYPE] JavaType Class<?> rawClass [VARIABLES] TypeModifier[] _modifiers mods SimpleType CORE_TYPE_BOOL CORE_TYPE_INT CORE_TYPE_LONG CORE_TYPE_STRING TypeParser _parser p boolean HierarchicType _cachedArrayListType _cachedHashMapType subType superType LRUMap _typeCache JavaType[] NO_TYPES collectionParams mapParams parameterTypes pt pts result typeParams Class rawClass TypeFactory instance long serialVersionUID ", "output": "[PATCH] if (rawClass == Properties.class) { return MapType.construct(rawClass, CORE_TYPE_STRING, CORE_TYPE_STRING); } ", "bugid": "271"}, {"instruction": "The following code contains a buggy line with the following test error: NotSerializableException: comfasterxmljacksondatabindserBeanPropertyWriter testEnumHandlers . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    * at this point; comment out for now. Try to fix later on.   */  bytes = jdkSerialize(mapper.writerFor(EnumPOJO.class));  ObjectWriter w = jdkDeserialize(bytes);  assertNotNull(w);", "input": "[BUG] [BUGGY] implements BeanProperty [FE] NotSerializableException: comfasterxmljacksondatabindserBeanPropertyWriter testEnumHandlers [CONTEXT]   @JacksonStdImpl public class BeanPropertyWriter extends PropertyWriter [BUGGY] implements BeanProperty [BUGGY] { public final static Object MARKER_FOR_EMPTY = JsonInclude.Include.NON_EMPTY;  [CLASS] ", "output": "[PATCH] implements BeanProperty, java.io.Serializable private static final long serialVersionUID = 4603296144163950020L; ", "bugid": "273"}, {"instruction": "The following code contains a buggy line with the following test error: IllegalStateException: No fallback setter/field defined: can not use creator property for comfasterxmljacksondatabinddeserCreatorProperty testInverseExternalId928 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   // and then re-ordered case that was problematic  final String failCase = \"{\\\"class\\\":\\\"\"+CLASS+\"\\\",\\\"payload\\\":{\\\"something\\\":\\\"test\\\"}}\";  Envelope928 envelope2 = mapper.readValue(failCase, Envelope928.class);  assertNotNull(envelope2);  assertEquals(Payload928.class, envelope2._payload.getClass());", "input": "[BUG] [BUGGY] if (ext.handlePropertyValue(p, ctxt, propName, buffer)) { [FE] IllegalStateException: No fallback setter/field defined: can not use creator property for comfasterxmljacksondatabinddeserCreatorProperty testInverseExternalId928 [CONTEXT] JsonToken t = p.getCurrentToken(); for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) { String propName = p.getCurrentName(); p.nextToken(); SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); if (creatorProp != null) {  [BUGGY] if (ext.handlePropertyValue(p, ctxt, propName, buffer)) { [BUGGY] ; } else { if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) { t = p.nextToken(); Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); [CLASS] BeanDeserializer [METHOD] deserializeUsingPropertyBasedWithExternalTypeId [RETURN_TYPE] Object JsonParser p DeserializationContext ctxt [VARIABLES] PropertyValueBuffer buffer SettableBeanProperty creatorProp prop String propName PropertyBasedCreator creator long serialVersionUID Exception e boolean TokenBuffer tokens DeserializationContext ctxt JsonToken t Object bean ExternalTypeHandler ext JsonParser p ", "output": "[PATCH] if (ext.handlePropertyValue(p, ctxt, propName, null)) { ", "bugid": "274"}, {"instruction": "The following code contains a buggy line with the following test error: jacksondatabindJsonMappingException: No serializer found for class comfasterxmljacksondatabindstructTestUnwrapped$Outer and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeatureFAIL_ON_EMPTY_BEANS) ) testUnwrappedAsPropertyIndicator . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  {  Inner inner = new Inner();  inner.animal = \"Zebra\";  Outer outer = new Outer();", "input": "[BUG] [BUGGY] || _hasAnnotation(a, JsonRawValue.class)) { [FE] jacksondatabindJsonMappingException: No serializer found for class comfasterxmljacksondatabindstructTestUnwrapped$Outer and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeatureFAIL_ON_EMPTY_BEANS) ) testUnwrappedAsPropertyIndicator [CONTEXT] } else { JsonProperty pann = _findAnnotation(a, JsonProperty.class); if (pann != null) { name = pann.value(); } else if (_hasAnnotation(a, JsonSerialize.class) || _hasAnnotation(a, JsonView.class) [BUGGY] || _hasAnnotation(a, JsonRawValue.class)) { [BUGGY] name =\"\"; } else { return null; } } return PropertyName.construct(name); } [CLASS] JacksonAnnotationIntrospector [METHOD] findNameForSerialization [RETURN_TYPE] PropertyName Annotated a [VARIABLES] Annotated a String name JsonProperty pann boolean JsonGetter jg long serialVersionUID ", "output": "[PATCH] || _hasAnnotation(a, JsonRawValue.class) || _hasAnnotation(a, JsonUnwrapped.class) || _hasAnnotation(a, JsonBackReference.class) || _hasAnnotation(a, JsonManagedReference.class)) { ", "bugid": "275"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<dec([numberType=BIG_[DECIMAL]])][optProp bigInt([> but was:<dec([numberType=BIG_[INTEGER]])][optProp bigInt([> testSimpleNumbers . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    }  });  assertEquals(\"[optProp dec([numberType=BIG_DECIMAL])][optProp bigInt([numberType=BIG_INTEGER])]\",    sb.toString()); }", "input": "[BUG] [BUGGY] visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); [FE] ComparisonFailure: expected:<dec([numberType=BIG_[DECIMAL]])][optProp bigInt([> but was:<dec([numberType=BIG_[INTEGER]])][optProp bigInt([> testSimpleNumbers [CONTEXT] public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException { if (_isInt) { visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); } else { Class<?> h = handledType(); if (h == BigDecimal.class) { [BUGGY] visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); [BUGGY] } else {  } } } [CLASS] NumberSerializer [METHOD] acceptJsonFormatVisitor [RETURN_TYPE] void JsonFormatVisitorWrapper visitor JavaType typeHint [VARIABLES] NumberSerializer instance JavaType typeHint Class h boolean _isInt JsonFormatVisitorWrapper visitor ", "output": "[PATCH] visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL); ", "bugid": "276"}, {"instruction": "The following code contains a buggy line with the following test error: jacksondatabindexcUnrecognizedPropertyException: Unrecognized field\"name\" (class comfasterxmljacksondatabindobjectidObjecid1083Test$JsonMapSchema), not marked as ignorable (0 known properties: ]) testSimple . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  + \"  'name': 'FoodMart'\\n\" + \"}]}\\n\");    mapper.readValue(json, JsonRoot.class);   }", "input": "[BUG] [BUGGY] return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, [FE] jacksondatabindexcUnrecognizedPropertyException: Unrecognized field\"name\" (class comfasterxmljacksondatabindobjectidObjecid1083Test$JsonMapSchema), not marked as ignorable (0 known properties: ]) testSimple [CONTEXT] if (!_class.isAssignableFrom(subclass)) { throw new IllegalArgumentException(\"Class\"+subclass.getName()+\" not sub-type of\" +_class.getName()); }  [BUGGY] return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, [BUGGY] _valueHandler, _typeHandler, _asStatic); } [CLASS] SimpleType [METHOD] _narrow [RETURN_TYPE] JavaType Class<?> subclass [VARIABLES] long serialVersionUID Class subclass boolean ", "output": "[PATCH] return new SimpleType(subclass, _bindings, this, _superInterfaces, ", "bugid": "277"}, {"instruction": "The following code contains a buggy line with the following test error: jacksondatabindexcUnrecognizedPropertyException: Unrecognized field\"location\" (class comfasterxmljacksondatabindjsontypeTestPolymorphicWithDefaultImpl$CallRecord), not marked as ignorable (4 known properties:\"version\",\"item\",\"item2\",\"application\"]) testUnknownTypeIDRecovery . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:     +\"'item2':{'type':'event','location':'location1'}}\");  // can't read item2 - which is valid  CallRecord r = reader.readValue(json);  assertNull(r.item);  assertNotNull(r.item2);", "input": "[BUG] [BUGGY] [FE] jacksondatabindexcUnrecognizedPropertyException: Unrecognized field\"location\" (class comfasterxmljacksondatabindjsontypeTestPolymorphicWithDefaultImpl$CallRecord), not marked as ignorable (4 known properties:\"version\",\"item\",\"item2\",\"application\"]) testUnknownTypeIDRecovery [CONTEXT] public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {  [BUGGY] [BUGGY] p.skipChildren(); return null; } [CLASS] NullifyingDeserializer [METHOD] deserialize [RETURN_TYPE] Object JsonParser p DeserializationContext ctxt [VARIABLES] DeserializationContext ctxt boolean NullifyingDeserializer instance long serialVersionUID JsonParser p ", "output": "[PATCH] if (p.hasToken(JsonToken.FIELD_NAME)) { while (true) { JsonToken t = p.nextToken(); if ((t == null) || (t == JsonToken.END_OBJECT)) { break; } p.skipChildren(); } } else { } ", "bugid": "278"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected same:<> was not:<null> testLocale . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   // [databind#1123]  Locale loc = MAPPER.readValue(quote(\"\"), Locale.class);  assertSame(Locale.ROOT, loc); }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: expected same:<> was not:<null> testLocale [CONTEXT] protected Object _deserializeFromEmptyString() throws IOException { if (_kind == STD_URI) { return URI.create(\"\"); } [BUGGY] [BUGGY] return super._deserializeFromEmptyString(); } [CLASS] FromStringDeserializer Std [METHOD] _deserializeFromEmptyString [RETURN_TYPE] Object [VARIABLES] long serialVersionUID int STD_CHARSET STD_CLASS STD_CURRENCY STD_FILE STD_INET_ADDRESS STD_INET_SOCKET_ADDRESS STD_JAVA_TYPE STD_LOCALE STD_PATTERN STD_TIME_ZONE STD_URI STD_URL _kind i ix j kind port boolean ", "output": "[PATCH] if (_kind == STD_LOCALE) { return Locale.ROOT; } ", "bugid": "280"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<{\"date\":[\"1970-01-01\"]}> but was:<{\"date\":[0]}> testDateDefaultShape . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);  String json = mapper.writeValueAsString(new DateAsDefaultBean(0L));  assertEquals(aposToQuotes(\"{'date':0}\"), json);  mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);  json = mapper.writeValueAsString(new DateAsDefaultBean(0L));", "input": "[BUG] [BUGGY] if (format.getShape() == JsonFormat.Shape.STRING) { [FE] ComparisonFailure: expected:<{\"date\":[\"1970-01-01\"]}> but was:<{\"date\":[0]}> testDateDefaultShape [CONTEXT] if (property != null) { JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember()); if (format != null) { JsonFormat.Shape shape = format.getShape(); if (shape.isNumeric()) { return withFormat(Boolean.TRUE, null); } [BUGGY] if (format.getShape() == JsonFormat.Shape.STRING) { [BUGGY] TimeZone tz = format.getTimeZone(); final String pattern = format.hasPattern() ? format.getPattern() : StdDateFormat.DATE_FORMAT_STR_ISO8601; final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(pattern, loc); if (tz == null) { tz = serializers.getTimeZone(); [CLASS] DateTimeSerializerBase [METHOD] createContextual [RETURN_TYPE] JsonSerializer SerializerProvider serializers BeanProperty property [VARIABLES] Locale loc TimeZone tz Shape shape boolean DateFormat _customFormat customFormat Value format String pattern Boolean _useTimestamp timestamp useTimestamp SerializerProvider serializers SimpleDateFormat df BeanProperty property ", "output": "[PATCH] if ((shape == JsonFormat.Shape.STRING) || format.hasPattern() || format.hasLocale() || format.hasTimeZone()) { ", "bugid": "281"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<String;[>];> but was:<String;[];> testGenericSignature1195 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   m = Generic1195.class.getMethod(\"getGeneric\");  t  = tf.constructType(m.getGenericReturnType());  assertEquals(\"Ljava/util/concurrent/atomic/AtomicReference<Ljava/lang/String;>;\", t.getGenericSignature()); }", "input": "[BUG] [BUGGY] sb.append(';'); [FE] ComparisonFailure: expected:<String;[>];> but was:<String;[];> testGenericSignature1195 [CONTEXT] public StringBuilder getGenericSignature(StringBuilder sb) { _classSignature(_class, sb, false); sb.append('<'); sb = _referencedType.getGenericSignature(sb); [BUGGY] sb.append(';'); [BUGGY] return sb; } [CLASS] ReferenceType [METHOD] getGenericSignature [RETURN_TYPE] StringBuilder StringBuilder sb [VARIABLES] JavaType _referencedType refType boolean StringBuilder sb long serialVersionUID ", "output": "[PATCH] sb.append(\">;\"); ", "bugid": "282"}, {"instruction": "The following code contains a buggy line with the following test error: jacksondatabinddeserUnresolvedForwardReference testIssue1255 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   String json = mapper.writeValueAsString(mo);  Foo result = mapper.readValue(json, Foo.class);  assertNotNull(result); }", "input": "[BUG] [BUGGY] id = generator.generateId(forPojo); [FE] jacksondatabinddeserUnresolvedForwardReference testIssue1255 [CONTEXT] public Object generateId(Object forPojo) {  [BUGGY] id = generator.generateId(forPojo); [BUGGY] return id; } [CLASS] WritableObjectId [METHOD] generateId [RETURN_TYPE] Object Object forPojo [VARIABLES] ObjectIdGenerator generator Object forPojo id boolean idWritten ", "output": "[PATCH] if (id == null) { id = generator.generateId(forPojo); } ", "bugid": "283"}, {"instruction": "The following code contains a buggy line with the following test error: jacksondatabindJsonMappingException: Problem deserializing property 'options' testPolymorphicTypeViaCustom . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   // Can we reverse the process? I have some doubts  Top1270 itemRead = MAPPER.readValue(json, Top1270.class);  assertNotNull(itemRead);  assertNotNull(itemRead.b);", "input": "[BUG] [BUGGY] type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass()); [FE] jacksondatabindJsonMappingException: Problem deserializing property 'options' testPolymorphicTypeViaCustom [CONTEXT] && _baseType.getClass() == type.getClass()) { [BUGGY] type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass()); [BUGGY] } [CLASS] TypeDeserializerBase [METHOD] _findDeserializer [RETURN_TYPE] JsonDeserializer DeserializationContext ctxt String typeId [VARIABLES] JavaType _baseType _defaultImpl actual baseType defaultImpl type boolean _typeIdVisible typeIdVisible DeserializationContext ctxt String _typePropertyName typeId typePropertyName JsonDeserializer _defaultImplDeserializer deser Map _deserializers long serialVersionUID TypeIdResolver _idResolver idRes BeanProperty _property prop property ", "output": "[PATCH] if (!type.hasGenericTypes()) { type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());} ", "bugid": "284"}, {"instruction": "The following code contains a buggy line with the following test error: CharConversionException testRootBeans . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  {  for (Source src : Source.values()) {   _testRootBeans(src);  } }", "input": "[BUG] [BUGGY] return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src),true)); [FE] CharConversionException testRootBeans [CONTEXT] return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false); } [BUGGY] return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), true)); [BUGGY] } [CLASS] ObjectReader [METHOD] readValues [RETURN_TYPE] <T> byte[] src int offset int length [VARIABLES] DefaultDeserializationContext _context FormatSchema _schema schema JsonFactory _parserFactory f DeserializationConfig _config config newConfig DataFormatReaders _dataFormatReaders dataFormatReaders det readers JsonDeserializer _rootDeserializer deser rootDeser InjectableValues _injectableValues injectableValues long serialVersionUID int length offset byte[] src JavaType JSON_NODE_TYPE _valueType t valueType boolean _unwrapRoot parserManaged Object _valueToUpdate key value valueToUpdate ConcurrentHashMap _rootDeserializers TokenFilter _filter filter ", "output": "[PATCH] return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length), true));", "bugid": "285"}, {"instruction": "The following code contains a buggy line with the following test error: jacksondatabindJsonMappingException testCauseOfThrowableIgnoral . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   try {   System.setSecurityManager(new CauseBlockingSecurityManager());   _testCauseOfThrowableIgnoral();  } finally {   System.setSecurityManager(origSecMan);", "input": "[BUG] [BUGGY] mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS)); [FE] jacksondatabindJsonMappingException testCauseOfThrowableIgnoral [CONTEXT] { AnnotatedMember mutator = propDef.getNonConstructorMutator(); if (ctxt.canOverrideAccessModifiers()) { [BUGGY] mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS)); [BUGGY] } BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(), propType0, propDef.getWrapperName(), beanDesc.getClassAnnotations(), mutator, propDef.getMetadata()); JavaType type = resolveType(ctxt, beanDesc, propType0, mutator); if (type != propType0) { property = property.withType(type); } [CLASS] BeanDeserializerFactory [METHOD] constructSettableProperty [RETURN_TYPE] SettableBeanProperty DeserializationContext ctxt BeanDescription beanDesc BeanPropertyDefinition propDef JavaType propType0 [VARIABLES] Std property Class[] INIT_CAUSE_PARAMS NO_VIEWS views SettableBeanProperty prop ReferenceProperty ref BeanDescription beanDesc AnnotatedMember mutator JsonDeserializer propDeser ObjectIdInfo objectIdInfo long serialVersionUID JavaType propType0 type boolean BeanDeserializerFactory instance BeanPropertyDefinition propDef DeserializationContext ctxt TypeDeserializer typeDeser ", "output": "[PATCH] if ((mutator instanceof AnnotatedField) &&\"cause\".equals(mutator.getName())) { ; } else { mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS)); } ", "bugid": "286"}, {"instruction": "The following code contains a buggy line with the following test error: IllegalStateException: No default constructor for [collection type; class javautilCollections$UnmodifiableSet, contains [simple type, class javalangObject]] testUnmodifiable . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   final String EXPECTED_JSON = \"[\\\"\"+unmodSetType.getName()+\"\\\",[]]\";  Set<?> foo = mapper.readValue(EXPECTED_JSON, Set.class);  assertTrue(foo.isEmpty()); }", "input": "[BUG] [BUGGY] [FE] IllegalStateException: No default constructor for [collection type; class javautilCollections$UnmodifiableSet, contains [simple type, class javalangObject]] testUnmodifiable [CONTEXT] JsonDeserializer<Object> delegateDeser = null; if (_valueInstantiator != null) { if (_valueInstantiator.canCreateUsingDelegate()) { JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); if (delegateType == null) { throw new IllegalArgumentException(\"Invalid delegate-creator definition for\"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\"); } delegateDeser = findDeserializer(ctxt, delegateType, property); [BUGGY] [BUGGY] } }  Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class, JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY); JsonDeserializer<?> valueDeser = _valueDeserializer;  [CLASS] CollectionDeserializer CollectionReferringAccumulator CollectionReferring [METHOD] createContextual [RETURN_TYPE] CollectionDeserializer DeserializationContext ctxt BeanProperty property [VARIABLES] ValueInstantiator _valueInstantiator valueInstantiator JsonDeserializer _delegateDeserializer _valueDeserializer dd delegateDeser valueDeser vd long serialVersionUID BeanProperty property JavaType _collectionType collectionType delegateType vt CollectionReferringAccumulator _parent parent boolean Collection _result result DeserializationContext ctxt Class _elementType contentType elementType List _accumulator next TypeDeserializer _valueTypeDeserializer valueTypeDeser vtd Boolean _unwrapSingle unwrapSingle ", "output": "[PATCH] } else if (_valueInstantiator.canCreateUsingArrayDelegate()) { JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig()); if (delegateType == null) { throw new IllegalArgumentException(\"Invalid array-delegate-creator definition for\"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for \\'canCreateUsingArrayDelegate()\\', but null for \\'getArrayDelegateType()\\'\"); } delegateDeser = findDeserializer(ctxt, delegateType, property); ", "bugid": "287"}, {"instruction": "The following code contains a buggy line with the following test error: jacksondatabindexcInvalidFormatException: Can not deserialize Map key of type comfasterxmljacksondatabindmoduleTestCustomEnumKeyDeserializer$KeyEnum from String\"REPlaceMENTS\": not a valid representation, problem: (comfasterxmljacksondatabindexcInvalidFormatException) Can not deserialize Map key of type comfasterxmljacksondatabindmoduleTestCustomEnumKeyDeserializer$KeyEnum from String\"REPlaceMENTS\": not one of values excepted for Enum class: [rootDirectory, replacements, licenseString] testCustomEnumValueAndKeyViaModifier . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   // and then as key  EnumMap<KeyEnum,String> map = mapper.readValue(    aposToQuotes(\"{'REPlaceMENTS':'foobar'}\"),    new TypeReference<EnumMap<KeyEnum,String>>() { });", "input": "[BUG] [BUGGY] return _createEnumKeyDeserializer(ctxt, type); [FE] jacksondatabindexcInvalidFormatException: Can not deserialize Map key of type comfasterxmljacksondatabindmoduleTestCustomEnumKeyDeserializer$KeyEnum from String\"REPlaceMENTS\": not a valid representation, problem: (comfasterxmljacksondatabindexcInvalidFormatException) Can not deserialize Map key of type comfasterxmljacksondatabindmoduleTestCustomEnumKeyDeserializer$KeyEnum from String\"REPlaceMENTS\": not one of values excepted for Enum class: [rootDirectory, replacements, licenseString] testCustomEnumValueAndKeyViaModifier [CONTEXT] for (KeyDeserializers d: _factoryConfig.keyDeserializers()) { deser = d.findKeyDeserializer(type, config, beanDesc); if (deser != null) { break; } } } if (deser == null) { if (type.isEnumType()) { [BUGGY] return _createEnumKeyDeserializer(ctxt, type); [BUGGY] } deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type); } if (deser != null) { if (_factoryConfig.hasDeserializerModifiers()) { for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { deser = mod.modifyKeyDeserializer(config, type, deser); } } [CLASS] BasicDeserializerFactory [METHOD] createKeyDeserializer [RETURN_TYPE] KeyDeserializer DeserializationContext ctxt JavaType type [VARIABLES] PropertyName UNWRAPPED_CREATOR_PARAM_NAME impl n name pn BeanDeserializerModifier mod JavaType type boolean DeserializerFactoryConfig _factoryConfig config HashMap _collectionFallbacks _mapFallbacks BeanDescription beanDesc DeserializationContext ctxt KeyDeserializers d Class CLASS_CHAR_BUFFER CLASS_ITERABLE CLASS_MAP_ENTRY CLASS_OBJECT CLASS_STRING collectionClass currClass enumClass fallback instClass kt mapClass nextCls nodeClass prevCls raw returnType type DeserializationConfig config KeyDeserializer deser ", "output": "[PATCH] deser = _createEnumKeyDeserializer(ctxt, type); } else { deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type); ", "bugid": "288"}, {"instruction": "The following code contains a buggy line with the following test error: NoSuchElementException: No entry 'businessAddress' found, can't remove testCaseInsensitiveUnwrap . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   ObjectMapper mapper = new ObjectMapper();  mapper.enable(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES);  Person p = mapper.readValue(\"{ }\", Person.class);  assertNotNull(p); }", "input": "[BUG] [BUGGY] found = key.equals(prop.getName()); [FE] NoSuchElementException: No entry 'businessAddress' found, can't remove testCaseInsensitiveUnwrap [CONTEXT] boolean found = false; for (int i = 1, end = _hashArea.length; i < end; i += 2) { SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i]; if (prop == null) { continue; } if (!found) {  [BUGGY] found = key.equals(prop.getName()); [BUGGY] if (found) { _propsInOrder[_findFromOrdered(prop)] = null; continue; } } props.add(prop); } if (!found) { throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\"); [CLASS] BeanPropertyMap [METHOD] remove [RETURN_TYPE] void SettableBeanProperty propToRm [VARIABLES] boolean _caseInsensitive caseInsensitive found state SettableBeanProperty prop propToRm ArrayList props SettableBeanProperty[] _propsInOrder String key long serialVersionUID int _hashMask _size _spillCount alloc end hashSize i index ix last len needed result size slot spillCount Object[] _hashArea hashed ", "output": "[PATCH] found = key.equals(_hashArea[i-1]); ", "bugid": "289"}, {"instruction": "The following code contains a buggy line with the following test error: jacksondatabindJsonMappingException: Unexpected token (VALUE_STRING), expected FIELD_NAME: missing property 'type' that is to contain type id (for class comfasterxmljacksondatabindjsontypeTestPolymorphicWithDefaultImpl$AsProperty) testWithEmptyStringAsNullObject1533 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  {  ObjectMapper mapper = new ObjectMapper().enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);  AsPropertyWrapper wrapper = mapper.readValue(\"{ \\\"value\\\": \\\"\\\" }\", AsPropertyWrapper.class);  assertNull(wrapper.value); }", "input": "[BUG] [BUGGY] [FE] jacksondatabindJsonMappingException: Unexpected token (VALUE_STRING), expected FIELD_NAME: missing property 'type' that is to contain type id (for class comfasterxmljacksondatabindjsontypeTestPolymorphicWithDefaultImpl$AsProperty) testWithEmptyStringAsNullObject1533 [CONTEXT] return deser.deserialize(p, ctxt); } Object result = TypeDeserializer.deserializeIfNatural(p, ctxt, _baseType); if (result != null) { return result; } if (p.getCurrentToken() == JsonToken.START_ARRAY) { return super.deserializeTypedFromAny(p, ctxt); [BUGGY] [BUGGY] } ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME,\"missing property '\"+_typePropertyName+\"' that is to contain type id(for class\"+baseTypeName()+\")\"); return null; } [CLASS] AsPropertyTypeDeserializer [METHOD] _deserializeTypedUsingDefaultImpl [RETURN_TYPE] Object JsonParser p DeserializationContext ctxt TokenBuffer tb [VARIABLES] As _inclusion inclusion boolean TokenBuffer tb DeserializationContext ctxt Object result JsonDeserializer deser long serialVersionUID JsonParser p ", "output": "[PATCH] } else if (p.getCurrentToken() == JsonToken.VALUE_STRING) { if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { String str = p.getText().trim(); if (str.isEmpty()) { return null; } } ", "bugid": "290"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<John> but was:<null> testWithUnwrappedAndCreatorSingleParameterAtBeginning . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertEquals(1234, person.getId());  assertNotNull(person.getName());  assertEquals(\"John\", person.getName().getFirst());  assertEquals(\"Doe\", person.getName().getLast());  assertEquals(30, person.getAge());", "input": "[BUG] [BUGGY] if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) { t = p.nextToken(); Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); continue; } while (t == JsonToken.FIELD_NAME) { p.nextToken(); tokens.copyCurrentStructure(p); t = p.nextToken(); } tokens.writeEndObject(); if (bean.getClass() != _beanType.getRawClass()) { ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\"); return null; } return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); } [FE] ComparisonFailure: expected:<John> but was:<null> testWithUnwrappedAndCreatorSingleParameterAtBeginning [CONTEXT] TokenBuffer tokens = new TokenBuffer(p, ctxt); tokens.writeStartObject(); JsonToken t = p.getCurrentToken(); for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) { String propName = p.getCurrentName(); p.nextToken(); SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); if (creatorProp != null) { [BUGGY] if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) { t = p.nextToken(); Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); continue; } while (t == JsonToken.FIELD_NAME) { p.nextToken(); [CLASS] BuilderBasedDeserializer [METHOD] deserializeUsingPropertyBasedWithUnwrapped [RETURN_TYPE] Object JsonParser p DeserializationContext ctxt [VARIABLES] PropertyValueBuffer buffer AnnotatedMethod _buildMethod SettableBeanProperty creatorProp prop String propName PropertyBasedCreator creator long serialVersionUID Exception e boolean TokenBuffer tokens DeserializationContext ctxt JsonToken t Object bean JsonParser p ", "output": "[PATCH] buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt)); ", "bugid": "291"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<jack> but was:<null> testIgnoreGetterNotSetter1595 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertEquals(aposToQuotes(\"{'id':123}\"), json);  Simple1595 des = mapper.readValue(aposToQuotes(\"{'id':123,'name':'jack'}\"), Simple1595.class);  assertEquals(\"jack\", des.getName()); }", "input": "[BUG] [BUGGY] ignored = ignorals.getIgnored(); [FE] ComparisonFailure: expected:<jack> but was:<null> testIgnoreGetterNotSetter1595 [CONTEXT] JsonIgnoreProperties.Value ignorals = ctxt.getConfig() .getDefaultPropertyIgnorals(beanDesc.getBeanClass(), beanDesc.getClassInfo()); Set<String> ignored; if (ignorals != null) { boolean ignoreAny = ignorals.getIgnoreUnknown(); builder.setIgnoreUnknownProperties(ignoreAny); [BUGGY] ignored = ignorals.getIgnored(); [BUGGY] for (String propName : ignored) { builder.addIgnorable(propName); } } else { ignored = Collections.emptySet(); } AnnotatedMethod anySetterMethod = beanDesc.findAnySetter(); AnnotatedMember anySetterField = null; [CLASS] BeanDeserializerFactory [METHOD] addBeanProps [RETURN_TYPE] void DeserializationContext ctxt BeanDescription beanDesc BeanDeserializerBuilder builder [VARIABLES] BeanDeserializerModifier mod Class[] INIT_CAUSE_PARAMS NO_VIEWS views Set DEFAULT_NO_DESER_CLASS_NAMES _cfgIllegalClassNames ignored AnnotatedMethod anySetterMethod getter SettableBeanProperty cp prop BeanDescription beanDesc AnnotatedMember anySetterField SettableBeanProperty[] creatorProps String name propName CreatorProperty cprop long serialVersionUID BeanDeserializerBuilder builder JavaType propertyType boolean hasCreatorProps ignoreAny isConcrete useGettersAsSetters BeanDeserializerFactory instance Value ignorals BeanPropertyDefinition propDef DeserializationContext ctxt Collection ignored2 List n propDefs Class rawPropertyType ", "output": "[PATCH] ignored = ignorals.findIgnoredForDeserialization(); ", "bugid": "292"}, {"instruction": "The following code contains a buggy line with the following test error: InvalidFormatException testWeirdStringHandling . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   mapper = new ObjectMapper()    .addHandler(new WeirdStringHandler(null));  UUID result2 = mapper.readValue(quote(\"not a uuid!\"), UUID.class);  assertNull(result2); }", "input": "[BUG] [BUGGY] if (_deserialize(text, ctxt) != null) { return _deserialize(text, ctxt); } [FE] InvalidFormatException testWeirdStringHandling [CONTEXT] if (text != null) { if (text.length() == 0 || (text = text.trim()).length() == 0) { return _deserializeFromEmptyString(); } Exception cause = null; try {  [BUGGY] if (_deserialize(text, ctxt) != null) { return _deserialize(text, ctxt); [BUGGY] } } catch (IllegalArgumentException iae) { cause = iae; } catch (MalformedURLException me) { cause = me; } String msg =\"not a valid textual representation\"; if (cause != null) { String m2 = cause.getMessage(); [CLASS] FromStringDeserializer Std [METHOD] deserialize [RETURN_TYPE] T JsonParser p DeserializationContext ctxt [VARIABLES] MalformedURLException me boolean JsonMappingException e DeserializationContext ctxt JsonToken t Object ob String m2 msg text long serialVersionUID int STD_CHARSET STD_CLASS STD_CURRENCY STD_FILE STD_INET_ADDRESS STD_INET_SOCKET_ADDRESS STD_JAVA_TYPE STD_LOCALE STD_PATTERN STD_STRING_BUILDER STD_TIME_ZONE STD_URI STD_URL _kind kind Exception cause IllegalArgumentException iae JsonParser p ", "output": "[PATCH] return _deserialize(text, ctxt);", "bugid": "293"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Expected an exception with one of substrings ([not subtype of]): got one (of type comfasterxmljacksondatabindJsonMappingException) with message\"Problem deserializing property testNestedTypeCheck1735 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    fail(\"Should not pass\");  } catch (JsonMappingException e) {   verifyException(e, \"not subtype of\");  } }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: Expected an exception with one of substrings ([not subtype of]): got one (of type comfasterxmljacksondatabindJsonMappingException) with message\"Problem deserializing property testNestedTypeCheck1735 [CONTEXT]  TypeFactory tf = ctxt.getTypeFactory(); if (id.indexOf('<') > 0) { JavaType t = tf.constructFromCanonical(id); [BUGGY] [BUGGY] return t; } Class<?> cls; try { cls =tf.findClass(id); } catch (ClassNotFoundException e) {  if (ctxt instanceof DeserializationContext) { DeserializationContext dctxt = (DeserializationContext) ctxt; [CLASS] ClassNameIdResolver [METHOD] _typeFromId [RETURN_TYPE] JavaType String id DatabindContext ctxt [VARIABLES] DatabindContext ctxt JavaType t boolean DeserializationContext dctxt Class cls String id TypeFactory tf ClassNotFoundException e Exception e ", "output": "[PATCH] if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) { \"Class %s not subtype of %s\", t.getRawClass().getName(), _baseType)); } ", "bugid": "296"}, {"instruction": "The following code contains a buggy line with the following test error: null  testJDKTypes1872 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   String json = aposToQuotes(String.format(\"{'@class':'%s','authorities':['java.util.ArrayList',[]]}\",    Authentication1872.class.getName()));  Authentication1872 result = mapper.readValue(json, Authentication1872.class);  assertNotNull(result); }", "input": "[BUG] [BUGGY] if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) { [FE] null  testJDKTypes1872 [CONTEXT] main_check: do { if (_cfgIllegalClassNames.contains(full)) { break; } [BUGGY] if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) { [BUGGY] String name = cls.getSimpleName(); if (\"AbstractPointcutAdvisor\".equals(name) ||\"AbstractApplicationContext\".equals(name)) { break main_check; } } } [CLASS] SubTypeValidator [METHOD] validateSubType [RETURN_TYPE] void DeserializationContext ctxt JavaType type [VARIABLES] JavaType type Set DEFAULT_NO_DESER_CLASS_NAMES _cfgIllegalClassNames boolean DeserializationContext ctxt SubTypeValidator instance Class cls raw String PREFIX_STRING full name ", "output": "[PATCH] if (!raw.isInterface() && full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()) { ", "bugid": "300"}, {"instruction": "The following code contains a buggy line with the following test error: InvalidDefinitionException testSnakeCaseWithOneArg . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  {  final String MSG = \"1st\";  OneProperty actual = MAPPER.readValue(    \"{\\\"param_name0\\\":\\\"\"+MSG+\"\\\"}\",    OneProperty.class);", "input": "[BUG] [BUGGY] paramName = candidate.findImplicitParamName(0); [FE] InvalidDefinitionException testSnakeCaseWithOneArg [CONTEXT] boolean useProps = (paramName != null) || (injectId != null); if (!useProps && (paramDef != null)) {  [BUGGY] paramName = candidate.findImplicitParamName(0); [BUGGY] useProps = (paramName != null) && paramDef.couldSerialize(); } if (useProps) { SettableBeanProperty[] properties = new SettableBeanProperty[] { constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId) }; creators.addPropertyCreator(candidate.creator(), true, properties); return; } _handleSingleArgumentCreator(creators, candidate.creator(), true, true); [CLASS] BasicDeserializerFactory [METHOD] _addExplicitAnyCreator [RETURN_TYPE] void DeserializationContext ctxt BeanDescription beanDesc CreatorCollector creators CreatorCandidate candidate [VARIABLES] PropertyName UNWRAPPED_CREATOR_PARAM_NAME impl name paramName DeserializerFactoryConfig _factoryConfig config HashMap _collectionFallbacks _mapFallbacks AnnotatedParameter param BeanDescription beanDesc SettableBeanProperty[] properties int oneNotInjected boolean useProps Value injectId BeanPropertyDefinition paramDef DeserializationContext ctxt Class CLASS_CHAR_SEQUENCE CLASS_ITERABLE CLASS_MAP_ENTRY CLASS_OBJECT CLASS_STRING currClass instClass nextCls prevCls raw CreatorCollector creators CreatorCandidate candidate ", "output": "[PATCH] paramName = candidate.paramName(0); ", "bugid": "301"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<Str\":\"The value is: [Hello!]\"}}> but was:<Str\":\"The value is: [NULL]\"}}> testPOJONodeCustomSer . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    String treeOut = MAPPER.writer().withAttribute(\"myAttr\", \"Hello!\").writeValueAsString(treeTest);   assertEquals(EXP, treeOut); }", "input": "[BUG] [BUGGY] gen.writeObject(_value); [FE] ComparisonFailure: expected:<Str\":\"The value is: [Hello!]\"}}> but was:<Str\":\"The value is: [NULL]\"}}> testPOJONodeCustomSer [CONTEXT] public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException { if (_value == null) { ctxt.defaultSerializeNull(gen); } else if (_value instanceof JsonSerializable) { ((JsonSerializable) _value).serialize(gen, ctxt); } else {  [BUGGY] gen.writeObject(_value); [BUGGY] } } [CLASS] POJONode [METHOD] serialize [RETURN_TYPE] void JsonGenerator gen SerializerProvider ctxt [VARIABLES] JsonGenerator gen Object _value v boolean SerializerProvider ctxt ", "output": "[PATCH] ctxt.defaultSerializeValue(_value, gen); ", "bugid": "302"}, {"instruction": "The following code contains a buggy line with the following test error: jacksondatabindexcInvalidDefinitionException: Cannot construct instance of `comfasterxmljacksondatabindjsontypeextExternalTypeIdWithEnum1328Test$AnimalAndType`, problem: argument type mismatch testExample . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   String json = mapper.writerWithDefaultPrettyPrinter()    .writeValueAsString(Arrays.asList(new AnimalAndType(AnimalType.Dog, new Dog())));  List<AnimalAndType> list = mapper.readerFor(new TypeReference<List<AnimalAndType>>() { })   .readValue(json);  assertNotNull(list);", "input": "[BUG] [BUGGY] buffer.assignParameter(typeProp, typeId); [FE] jacksondatabindexcInvalidDefinitionException: Cannot construct instance of `comfasterxmljacksondatabindjsontypeextExternalTypeIdWithEnum1328Test$AnimalAndType`, problem: argument type mismatch testExample [CONTEXT] if (prop.getCreatorIndex() >= 0) { buffer.assignParameter(prop, values[i]); SettableBeanProperty typeProp = extProp.getTypeProperty(); if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {  [BUGGY] buffer.assignParameter(typeProp, typeId); [BUGGY] } } } Object bean = creator.build(ctxt, buffer); for (int i = 0; i < len; ++i) { SettableBeanProperty prop = _properties[i].getProperty(); if (prop.getCreatorIndex() < 0) { prop.set(bean, values[i]); } [CLASS] ExternalTypeHandler Builder ExtTypedProperty [METHOD] complete [RETURN_TYPE] Object JsonParser p DeserializationContext ctxt PropertyValueBuffer buffer PropertyBasedCreator creator [VARIABLES] PropertyValueBuffer buffer SettableBeanProperty _property _typeProperty extProp prop property typeProp TokenBuffer[] _tokens tokens String[] _typeIds typeIds String _typePropertyName propName typeId PropertyBasedCreator creator int i len JavaType _beanType beanType t boolean ExtTypedProperty extProp DeserializationContext ctxt List _properties Object bean ExtTypedProperty[] _properties properties TypeDeserializer _typeDeserializer typeDeser Map _nameToPropertyIndex nameToPropertyIndex Object[] values JsonParser p ", "output": "[PATCH] final Object v; if (typeProp.getType().hasRawClass(String.class)) { v = typeId; } else { TokenBuffer tb = new TokenBuffer(p, ctxt); tb.writeString(typeId); v = typeProp.getValueDeserializer().deserialize(tb.asParserOnFirstToken(), ctxt); tb.close(); } buffer.assignParameter(typeProp, v); ", "bugid": "303"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<[>]> but was:<[]> testCanonicalNames . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);  can = t.toCanonical();  assertEquals(\"java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>\",    can);  assertEquals(t, tf.constructFromCanonical(can));", "input": "[BUG] [BUGGY] [FE] ComparisonFailure: expected:<[>]> but was:<[]> testCanonicalNames [CONTEXT] protected String buildCanonicalName() { StringBuilder sb = new StringBuilder(); sb.append(_class.getName()); sb.append('<'); sb.append(_referencedType.toCanonical()); [BUGGY] [BUGGY] return sb.toString(); } [CLASS] ReferenceType [METHOD] buildCanonicalName [RETURN_TYPE] String [VARIABLES] JavaType _anchorType _referencedType anchorType baseType contentType refType refdType superClass boolean StringBuilder sb long serialVersionUID ", "output": "[PATCH] sb.append('>'); ", "bugid": "304"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Failed (variant MODIFIED-FOR-URL, data length 1): Cannot access contents of TextNode as binary due to broken Base64 encoding: Unexpected end-of-String in base64 content testBase64Text . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  data = n.getBinaryValue(variant);    } catch (Exception e) { fail(\"Failed (variant \"+variant+\", data length \"+len+\"): \"+e.getMessage());    }    assertNotNull(data);", "input": "[BUG] [BUGGY] byte[] data = n.binaryValue(); if (data != null) { return data; } if (n.isPojo()) { Object ob = ((POJONode) n).getPojo(); if (ob instanceof byte[]) { return (byte[]) ob; } [FE] AssertionFailedError: Failed (variant MODIFIED-FOR-URL, data length 1): Cannot access contents of TextNode as binary due to broken Base64 encoding: Unexpected end-of-String in base64 content testBase64Text [CONTEXT] public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { JsonNode n = currentNode(); if (n != null) {  [BUGGY] byte[] data = n.binaryValue(); if (data != null) { return data; } if (n.isPojo()) { Object ob = ((POJONode) n).getPojo(); if (ob instanceof byte[]) { return (byte[]) ob; } [BUGGY] } } [CLASS] TreeTraversingParser [METHOD] getBinaryValue [RETURN_TYPE] byte[] Base64Variant b64variant [VARIABLES] byte[] data boolean _closed _startContainer Base64Variant b64variant NodeCursor _nodeCursor JsonToken _nextToken JsonNode n Object ob ObjectCodec _objectCodec c codec ", "output": "[PATCH] if (n instanceof TextNode) { return ((TextNode) n).getBinaryValue(b64variant); return n.binaryValue(); ", "bugid": "305"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<[\"1980+04+14\"]> but was:<[324547200000]> testSqlDateConfigOverride . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   mapper.configOverride(java.sql.Date.class)   .setFormat(JsonFormat.Value.forPattern(\"yyyy+MM+dd\"));    assertEquals(\"\\\"1980+04+14\\\"\",   mapper.writeValueAsString(java.sql.Date.valueOf(\"1980-04-14\"))); }", "input": "[BUG] [BUGGY] if (property == null) { return this; } [FE] ComparisonFailure: expected:<[\"1980+04+14\"]> but was:<[324547200000]> testSqlDateConfigOverride [CONTEXT] {  [BUGGY] if (property == null) { return this; } [BUGGY] JsonFormat.Value format = findFormatOverrides(serializers, property, handledType()); if (format == null) { return this; } JsonFormat.Shape shape = format.getShape(); if (shape.isNumeric()) { return withFormat(Boolean.TRUE, null); [CLASS] DateTimeSerializerBase [METHOD] createContextual [RETURN_TYPE] JsonSerializer SerializerProvider serializers BeanProperty property [VARIABLES] Locale loc TimeZone newTz tz Shape shape boolean asString changeTZ hasLocale hasTZ DateFormat _customFormat customFormat df0 Value format AtomicReference _reusedCustomFormat StdDateFormat std Boolean _useTimestamp timestamp useTimestamp SerializerProvider serializers SimpleDateFormat df BeanProperty property ", "output": "[PATCH] [Delete]", "bugid": "306"}, {"instruction": "The following code contains a buggy line with the following test error: jacksondatabindJsonMappingException: (was null ) testWithDeserializationProblemHandler . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    }  });  GenericContent processableContent = mapper.readValue(JSON, GenericContent.class);  assertNotNull(processableContent.getInnerObjects());  assertEquals(2, processableContent.getInnerObjects().size());", "input": "[BUG] [BUGGY] return null; [FE] jacksondatabindJsonMappingException: (was null ) testWithDeserializationProblemHandler [CONTEXT] JavaType type = _idResolver.typeFromId(ctxt, typeId); if (type == null) { deser = _findDefaultImplDeserializer(ctxt); if (deser == null) { JavaType actual = _handleUnknownTypeId(ctxt, typeId); if (actual == null) {  [BUGGY] return null; [BUGGY] } deser = ctxt.findContextualValueDeserializer(actual, _property); } } else { [CLASS] TypeDeserializerBase [METHOD] _findDeserializer [RETURN_TYPE] JsonDeserializer DeserializationContext ctxt String typeId [VARIABLES] JavaType _baseType _defaultImpl actual baseType defaultImpl type boolean _typeIdVisible typeIdVisible DeserializationContext ctxt String _typePropertyName typeId typePropertyName JsonDeserializer _defaultImplDeserializer deser Map _deserializers long serialVersionUID TypeIdResolver _idResolver idRes BeanProperty _property prop property ", "output": "[PATCH] return NullifyingDeserializer.instance; ", "bugid": "307"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<0> but was:<3> testOffsetWithInputOffset . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   loc = p.getTokenLocation();  assertEquals(0L, loc.getByteOffset());  assertEquals(-1L, loc.getCharOffset());  assertEquals(1, loc.getLineNr());", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: expected:<0> but was:<3> testOffsetWithInputOffset [CONTEXT] byte[] inputBuffer, int start, int end, boolean bufferRecyclable) { super(ctxt, features); _inputStream = in; _objectCodec = codec; _symbols = sym; _inputBuffer = inputBuffer; _inputPtr = start; _inputEnd = end; [BUGGY] [BUGGY] _bufferRecyclable = bufferRecyclable; } [CLASS] UTF8StreamJsonParser [METHOD] <init> [RETURN_TYPE] BytesToNameCanonicalizer,byte[],int,int,boolean) IOContext ctxt int features InputStream in ObjectCodec codec BytesToNameCanonicalizer sym byte[] inputBuffer int start int end boolean bufferRecyclable [VARIABLES] byte[] _inputBuffer inputBuffer boolean _bufferRecyclable _tokenIncomplete bufferRecyclable byte BYTE_LF InputStream _inputStream in BytesToNameCanonicalizer _symbols sym IOContext ctxt int[] _icLatin1 _icUTF8 _icWS _quadBuffer ObjectCodec _objectCodec codec int _quad1 end features start ", "output": "[PATCH] _currInputRowStart = start; _currInputProcessed = -start; ", "bugid": "309"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Expected buffer of 262145 to expand, did not, length now 262144 testExpand . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  buf = tb.expandCurrentSegment(); if (old.length >= buf.length) {  fail(\"Expected buffer of \"+old.length+\" to expand, did not, length now \"+buf.length); }    }", "input": "[BUG] [BUGGY] int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1)); [FE] AssertionFailedError: Expected buffer of 262145 to expand, did not, length now 262144 testExpand [CONTEXT] public char[] expandCurrentSegment() { final char[] curr = _currentSegment; final int len = curr.length; [BUGGY] [BUGGY] int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1)); return (_currentSegment = Arrays.copyOf(curr, newLen)); } [CLASS] TextBuffer [METHOD] expandCurrentSegment [RETURN_TYPE] char[] [VARIABLES] boolean _hasSegments BufferRecycler _allocator allocator ArrayList _segments String _resultString str value int MAX_SEGMENT_LEN MIN_SEGMENT_LEN _currentSize _inputLen _inputStart _segmentSize amount currLen i len max needed newLen offset oldLen segLen start char[] NO_CHARS _currentSegment _inputBuffer _resultArray buf c curr result ", "output": "[PATCH] int newLen = len + (len >> 1); if (newLen > MAX_SEGMENT_LEN) { newLen = len + (len >> 2); } ", "bugid": "310"}, {"instruction": "The following code contains a buggy line with the following test error: NumberFormatException testWonkyNumber173 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void testWonkyNumber173() throws Exception {  JsonPointer ptr = JsonPointer.compile(\"/1e0\");  assertFalse(ptr.matches()); }", "input": "[BUG] [BUGGY] char c = str.charAt(i++); [FE] NumberFormatException testWonkyNumber173 [CONTEXT] private final static int _parseIndex(String str) { final int len = str.length();  if (len == 0 || len > 10) { return -1; } for (int i = 0; i < len; ++i) { [BUGGY] char c = str.charAt(i++); [BUGGY] if (c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } [CLASS] JsonPointer [METHOD] _parseIndex [RETURN_TYPE] int String str [VARIABLES] char c JsonPointer EMPTY _nextSegment next String _asString _matchingPropertyName fullString input name segment str boolean int _matchingElementIndex i index len long l ", "output": "[PATCH] char c = str.charAt(i); ", "bugid": "311"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testFailOnWritingStringNotFieldNameBytes . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError testFailOnWritingStringNotFieldNameBytes [CONTEXT] public int writeValue() { if (_type == TYPE_OBJECT) { [BUGGY] [BUGGY] _gotName = false; ++_index; return STATUS_OK_AFTER_COLON; } if (_type == TYPE_ARRAY) { int ix = _index; ++_index; return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA; } [CLASS] JsonWriteContext [METHOD] writeValue [RETURN_TYPE] int [VARIABLES] DupDetector _dups dd dups boolean _gotName JsonWriteContext _child _parent ctxt parent Object _currentValue v String _currentName name int STATUS_EXPECT_NAME STATUS_EXPECT_VALUE STATUS_OK_AFTER_COLON STATUS_OK_AFTER_COMMA STATUS_OK_AFTER_SPACE STATUS_OK_AS_IS ix type ", "output": "[PATCH] if (!_gotName) { return STATUS_EXPECT_NAME; } ", "bugid": "313"}, {"instruction": "The following code contains a buggy line with the following test error: null  testEmpty . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   tb.resetWithEmpty();  assertTrue(tb.getTextBuffer().length == 0);  tb.contentsAsString();  assertTrue(tb.getTextBuffer().length == 0);", "input": "[BUG] [BUGGY] if (!_hasSegments) return _currentSegment; [FE] null  testEmpty [CONTEXT] public char[] getTextBuffer() { if (_inputStart >= 0) return _inputBuffer; if (_resultArray != null)return _resultArray; if (_resultString != null) { return (_resultArray = _resultString.toCharArray()); } [BUGGY] if (!_hasSegments)return _currentSegment; [BUGGY] return contentsAsArray(); } [CLASS] TextBuffer [METHOD] getTextBuffer [RETURN_TYPE] char[] [VARIABLES] boolean _hasSegments BufferRecycler _allocator allocator ArrayList _segments String _resultString value int MAX_SEGMENT_LEN MIN_SEGMENT_LEN _currentSize _inputLen _inputStart _segmentSize len needed start char[] NO_CHARS _currentSegment _inputBuffer _resultArray buf ", "output": "[PATCH] if (!_hasSegments && _currentSegment != null) return _currentSegment; ", "bugid": "314"}, {"instruction": "The following code contains a buggy line with the following test error: ArrayIndexOutOfBoundsException: 512 testSymbolTableExpansionBytes . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  }", "input": "[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException: 512 testSymbolTableExpansionBytes [CONTEXT] private void _verifySharing() { if (_hashShared) { _hashArea = Arrays.copyOf(_hashArea, _hashArea.length); _names = Arrays.copyOf(_names, _names.length); _hashShared = false;  [BUGGY] [BUGGY] } if (_needRehash) { rehash(); } } [CLASS] ByteQuadsCanonicalizer TableInfo [METHOD] _verifySharing [RETURN_TYPE] void [VARIABLES] boolean _failOnDoS _hashShared _intern _needRehash failOnDoS intern ByteQuadsCanonicalizer _parent parent src AtomicReference _tableInfo int[] _hashArea hashArea mainHash q String[] _names names int DEFAULT_T_SIZE MAX_ENTRIES_FOR_REUSE MAX_T_SIZE MIN_HASH_SIZE MULT MULT2 MULT3 _count _hashSize _longNameOffset _secondaryStart _seed _spilloverEnd _tertiaryShift _tertiaryStart bucketSize childCount count curr end flags hash ix len len2 longNameOffset longStart offset offset2 origOffset pri q1 q2 q3 qlen sec seed size spill spillCount spillOffset spilloverEnd sz tert tertiaryShift total ", "output": "[PATCH] _verifyNeedForRehash(); ", "bugid": "315"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Should not pass testInvalidSubClass . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   try {   pp.createInstance();   fail(\"Should not pass\");  } catch (IllegalStateException e) {   verifyException(e, \"does not override\");", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: Should not pass testInvalidSubClass [CONTEXT] public DefaultPrettyPrinter createInstance() { [BUGGY] [BUGGY] return new DefaultPrettyPrinter(this); } [CLASS] DefaultPrettyPrinter NopIndenter FixedSpaceIndenter [METHOD] createInstance [RETURN_TYPE] DefaultPrettyPrinter [VARIABLES] SerializedString DEFAULT_ROOT_VALUE_SEPARATOR Indenter _arrayIndenter _objectIndenter i SerializableString _rootSeparator rootSeparator boolean _spacesInObjectEntries state NopIndenter instance Separators _separators separators String _objectFieldValueSeparatorWithSpaces rootSeparator FixedSpaceIndenter instance long serialVersionUID int _nesting level ", "output": "[PATCH] if (getClass() != DefaultPrettyPrinter.class) { throw new IllegalStateException(\"Failed `createInstance()`:\"+getClass().getName() +\" does not override method; it has to\"); } ", "bugid": "319"}, {"instruction": "The following code contains a buggy line with the following test error: ArrayIndexOutOfBoundsException: 256 testUnquotedIssue510 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertToken(JsonToken.START_OBJECT, p.nextToken());  try {   p.nextToken();   fail(\"Should not pass\");  } catch (JsonParseException e) {", "input": "[BUG] [BUGGY] if (i <= maxCode) { [FE] ArrayIndexOutOfBoundsException: 256 testUnquotedIssue510 [CONTEXT] final int maxCode = codes.length; while (true) { if (_inputPtr >= _inputEnd) { if (!_loadMore()) { break; } } char c = _inputBuffer[_inputPtr]; int i = (int) c; [BUGGY] if (i <= maxCode) { [BUGGY] if (codes[i] != 0) { break; } } else if (!Character.isJavaIdentifierPart(c)) { break; } ++_inputPtr; hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; outBuf[outPtr++] = c; [CLASS] ReaderBasedJsonParser [METHOD] _handleOddName2 [RETURN_TYPE] String int startPtr int hash int[] codes [VARIABLES] boolean _bufferRecyclable _tokenIncomplete bufferRecyclable eof firstOk inObject neg negative TextBuffer tb char c Reader _reader r int[] _icLatin1 codes ObjectCodec _objectCodec c codec CharsToNameCanonicalizer _symbols st int FEAT_MASK_TRAILING_COMMA _hashSeed _nameStartCol _nameStartRow bits bufSize ch count decodedData defaultValue end endChar expLen features fractLen hash i id inputLen intLen len maxCode nameLen offset origPtr outPtr outputCount outputEnd outputPtr ptr start startPtr long _nameStartOffset defaultValue char[] _inputBuffer buf ch inputBuffer nameChars outBuf ", "output": "[PATCH] if (i < maxCode) { ", "bugid": "320"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<1> but was:<3> testLocationOffsets . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   feeder.feedInput(input, 2, 3);  assertEquals(JsonToken.START_ARRAY, parser.nextToken());  assertEquals(1, parser.getCurrentLocation().getByteOffset());  assertEquals(1, parser.getTokenLocation().getByteOffset());  assertEquals(1, parser.getCurrentLocation().getLineNr());", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: expected:<1> but was:<3> testLocationOffsets [CONTEXT]  _currInputProcessed += _origBufferLen; _currInputRowStart = start - (_inputEnd - _currInputRowStart);  [BUGGY] [BUGGY] _inputBuffer = buf; _inputPtr = start; _inputEnd = end; _origBufferLen = end - start; } [CLASS] NonBlockingJsonParser [METHOD] feedInput [RETURN_TYPE] void byte[] buf int start int end [VARIABLES] byte[] _inputBuffer buf int[] _icLatin1 _icUTF8 boolean int FEAT_MASK_ALLOW_JAVA_COMMENTS FEAT_MASK_ALLOW_MISSING FEAT_MASK_ALLOW_SINGLE_QUOTES FEAT_MASK_ALLOW_UNQUOTED_NAMES FEAT_MASK_ALLOW_YAML_COMMENTS FEAT_MASK_LEADING_ZEROS FEAT_MASK_TRAILING_COMMA _origBufferLen end parserFeatures start ", "output": "[PATCH] _currBufferStart = start; ", "bugid": "321"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: shouldn't be able to read from truncated entry testRead7ZipMultiVolumeArchiveForStream . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:     int read = 0;\t\twhile ((read = zi.read(buffer)) > 0) { }\t\tfail(\"shouldn't be able to read from truncated entry\");\t } catch (IOException e) {    assertEquals(\"Truncated ZIP file\", e.getMessage());", "input": "[BUG] [BUGGY] if (read == 0 && inf.finished()) { return -1; [FE] AssertionFailedError: shouldn't be able to read from truncated entry testRead7ZipMultiVolumeArchiveForStream [CONTEXT] if (lengthOfLastRead > 0) { bytesReadFromStream += lengthOfLastRead; } } int read = 0; try { read = inf.inflate(buffer, start, length); } catch (DataFormatException e) { throw new ZipException(e.getMessage()); } [BUGGY] if (read == 0 && inf.finished()) { return -1; [BUGGY] } crc.update(buffer, start, read); return read; } [CLASS] ZipArchiveInputStream [METHOD] read [RETURN_TYPE] int byte[] buffer int start int length [VARIABLES] byte[] buf buffer extraData fileName lfh boolean closed hasDataDescriptor hasEFS hitCentralDirectory useUnicodeExtraFields DataFormatException e ZipEncoding entryEncoding zipEncoding CRC32 crc InputStream in inputStream ZipArchiveEntry current Inflater inf int LFH_LEN SHORT WORD bytesReadFromStream csize extraLen fileNameLen generalPurposeFlag length lengthOfLastRead off offsetInBuffer read readBytesOfEntry start toRead versionMadeBy ", "output": "[PATCH] if (read == 0) { if (inf.finished()) { return -1; } else if (lengthOfLastRead == -1) { throw new IOException(\"Truncated ZIP file\"); } ", "bugid": "322"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<0302-0601-3[ testRoundTripNames . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   // checkName(\"\\0\"); // does not work, because NUL is ignored  // COMPRESS-114  checkName(\"0302-0601-3F06W220ZBLALALACANDC04060302MOE.model\"); }", "input": "[BUG] [BUGGY] if (buffer[i] == 0) { result.append((char) buffer[i]); [FE] ComparisonFailure: expected:<0302-0601-3[ testRoundTripNames [CONTEXT] public static String parseName(byte[] buffer, final int offset, final int length) { StringBuffer result = new StringBuffer(length); intend = offset + length; for (int i = offset; i < end; ++i) { [BUGGY] if (buffer[i] == 0) { break; [BUGGY] } result.append((char) buffer[i]); } return result.toString(); } [CLASS] TarUtils [METHOD] parseName [RETURN_TYPE] String byte[] buffer final int offset final int length [VARIABLES] byte[] buffer StringBuffer result boolean int BYTE_MASK end i length offset ", "output": "[PATCH] byte b = buffer[i]; if (b == 0) { result.append((char) (b & 0xFF)); ", "bugid": "323"}, {"instruction": "The following code contains a buggy line with the following test error: IllegalArgumentException: Invalid byte 0 at offset 2 in '00{NUL}0765{NUL}' len=8 testCOMPRESS178 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   final ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"tar\", is);  try {   in.getNextEntry();   fail(\"Expected IOException\");  } catch (IOException e) {", "input": "[BUG] [BUGGY] currEntry = new TarArchiveEntry(headerBuf); [FE] IllegalArgumentException: Invalid byte 0 at offset 2 in '00{NUL}0765{NUL}' len=8 testCOMPRESS178 [CONTEXT] readBuf = null; } byte[] headerBuf = getRecord(); if (hasHitEOF) { currEntry = null; return null; } [BUGGY] currEntry = new TarArchiveEntry(headerBuf); [BUGGY] entryOffset = 0; entrySize = currEntry.getSize(); if (currEntry.isGNULongNameEntry()) { StringBuffer longName = new StringBuffer(); byte[] buf = new byte[SMALL_BUFFER_SIZE]; int length = 0; while ((length = read(buf)) >= 0) { longName.append(new String(buf, 0, length)); [CLASS] TarArchiveInputStream 1 [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry [VARIABLES] byte[] buf headerBuf readBuf skipBuf StringBuffer longName boolean hasHitEOF TarBuffer buffer int BUFFER_SIZE SMALL_BUFFER_SIZE blockSize length numRead realSkip recordSize long entryOffset entrySize numToSkip skip skipped TarArchiveEntry currEntry ", "output": "[PATCH] try { currEntry = new TarArchiveEntry(headerBuf); } catch (IllegalArgumentException e) { IOException ioe = new IOException(\"Error detected parsing the header\"); ioe.initCause(e); throw ioe; } ", "bugid": "324"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:< winzipBackSlashWorkaround . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    zae = in.getNextZipEntry();   zae = in.getNextZipEntry();   assertEquals(\"\\u00e4/\", zae.getName());  } finally {   if (in != null) {", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: expected:< winzipBackSlashWorkaround [CONTEXT] protected void setName(String name) { [BUGGY] [BUGGY] this.name = name; } [CLASS] ZipArchiveEntry [METHOD] setName [RETURN_TYPE] void String name [VARIABLES] byte[] b extra rawName boolean String entryName name GeneralPurposeBit gpb UnparseableExtraFieldData unparseableExtra int PLATFORM_FAT PLATFORM_UNIX SHORT_MASK SHORT_SHIFT i internalAttributes method mode platform value long externalAttributes size value LinkedHashMap copy extraFields ", "output": "[PATCH] if (name != null && getPlatform() == PLATFORM_FAT && name.indexOf(\"/\") == -1) {  name = name.replace('\\\\\\\\', '/');\\n\", '+  } ", "bugid": "325"}, {"instruction": "The following code contains a buggy line with the following test error: IOException: Error detected parsing the header workaroundForBrokenTimeHeader . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    in = new TarArchiveInputStream(new FileInputStream(new File(new URI(tar.toString()))));   TarArchiveEntry tae = in.getNextTarEntry();   tae = in.getNextTarEntry();   assertEquals(\"sample/link-to-txt-file.lnk\", tae.getName());   assertEquals(new Date(0), tae.getLastModifiedDate());", "input": "[BUG] [BUGGY] boolean allNUL = true; for (int i = start; i < end; i++){ if (buffer[i] != 0){ allNUL = false; break; } } if (allNUL) { [FE] IOException: Error detected parsing the header workaroundForBrokenTimeHeader [CONTEXT] public static long parseOctal(final byte[] buffer, final int offset, final int length) { longresult = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length\"+length+\" must be at least 2\"); } [BUGGY] boolean allNUL = true; for (int i = start; i < end; i++){ if (buffer[i] != 0){ allNUL = false; break; } } if (allNUL) { [BUGGY] return 0L; } [CLASS] TarUtils [METHOD] parseOctal [RETURN_TYPE] long final byte[] buffer final int offset final int length [VARIABLES] byte[] buffer boolean allNUL int BYTE_MASK end i length offset start long result byte currentByte trailer ", "output": "[PATCH] if (buffer[start] == 0) { ", "bugid": "326"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<foo> but was:<foo> testNullCommentEqualsEmptyComment . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   entry2.setComment(\"\");  entry3.setComment(\"bar\");  assertEquals(entry1, entry2);  assertFalse(entry1.equals(entry3));  assertFalse(entry2.equals(entry3));", "input": "[BUG] [BUGGY] if (otherComment != null) { return false; } } else if (!myComment.equals(otherComment)) { return false; [FE] AssertionFailedError: expected:<foo> but was:<foo> testNullCommentEqualsEmptyComment [CONTEXT] if (myName == null) { if (otherName != null) { return false; } } else if (!myName.equals(otherName)) { return false; } String myComment = getComment(); String otherComment = other.getComment(); if (myComment == null) { [BUGGY] if (otherComment != null) { return false; } } else if (!myComment.equals(otherComment)) { return false; [BUGGY] } return getTime() == other.getTime() && getInternalAttributes() == other.getInternalAttributes() && getPlatform() == other.getPlatform() && getExternalAttributes() == other.getExternalAttributes() && getMethod() == other.getMethod() [CLASS] ZipArchiveEntry [METHOD] equals [RETURN_TYPE] boolean Object obj [VARIABLES] byte[] b extra rawName boolean ZipArchiveEntry other Object obj String entryName myComment myName name otherComment otherName GeneralPurposeBit b gpb UnparseableExtraFieldData unparseableExtra int PLATFORM_FAT PLATFORM_UNIX SHORT_MASK SHORT_SHIFT internalAttributes method mode platform value long externalAttributes size value LinkedHashMap copy extraFields ", "output": "[PATCH] myComment =\"\"; } if (otherComment == null) { otherComment =\"\"; && myComment.equals(otherComment) ", "bugid": "327"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: created an input stream for a non-archive aiffFilesAreNoTARs . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    is = new BufferedInputStream(new FileInputStream(\"src/test/resources/testAIFF.aif\"));   new ArchiveStreamFactory().createArchiveInputStream(is);   fail(\"created an input stream for a non-archive\");  } catch (ArchiveException ae) {   assertTrue(ae.getMessage().startsWith(\"No Archiver found\"));", "input": "[BUG] [BUGGY] tais.getNextEntry(); [FE] AssertionFailedError: created an input stream for a non-archive aiffFilesAreNoTARs [CONTEXT] signatureLength = in.read(tarheader); in.reset(); if (TarArchiveInputStream.matches(tarheader, signatureLength)) { return new TarArchiveInputStream(in); } if (signatureLength >= 512) { try { TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader)); [BUGGY] tais.getNextEntry(); [BUGGY] return new TarArchiveInputStream(in); } catch (Exception e) { } } } catch (IOException e) { throw new ArchiveException(\"Could not use reset and mark operations.\", e); [CLASS] ArchiveStreamFactory [METHOD] createArchiveInputStream [RETURN_TYPE] ArchiveInputStream InputStream in [VARIABLES] byte[] dumpsig signature tarheader TarArchiveInputStream tais boolean InputStream in String AR CPIO DUMP JAR TAR ZIP archiverName IOException e int signatureLength Exception e ", "output": "[PATCH] if (tais.getNextTarEntry().isCheckSumOK()) { } ", "bugid": "328"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: COMPRESS-197: Error detected parsing the header testCompress197 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    }  } catch (IOException e) {   fail(\"COMPRESS-197: \" + e.getMessage());  } finally {   tar.close();", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: COMPRESS-197: Error detected parsing the header testCompress197 [CONTEXT] byte trailer; trailer = buffer[end-1]; if (trailer == 0 || trailer == ' '){ end--; } else { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, end-1, trailer)); } trailer = buffer[end - 1]; [BUGGY] [BUGGY] if (trailer == 0 || trailer == ' '){ end--; } for ( ;start < end; start++) { final byte currentByte = buffer[start]; if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } [CLASS] TarUtils 1 [METHOD] parseOctal [RETURN_TYPE] long final byte[] buffer final int offset final int length [VARIABLES] byte[] buffer boolean ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING int BYTE_MASK end i length offset start long result byte currentByte trailer ", "output": "[PATCH] trailer = buffer[end - 1]; ", "bugid": "329"}, {"instruction": "The following code contains a buggy line with the following test error: IOException: request to write '15' bytes exceeds size in header of '0' bytes for entry '/PaxHeadersX/fvv/' testWriteNonAsciiDirectoryNamePosixMode . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);  tos.setAddPaxHeadersForNonAsciiNames(true);  tos.putArchiveEntry(t);  tos.closeArchiveEntry();  tos.close();", "input": "[BUG] [BUGGY] [FE] IOException: request to write '15' bytes exceeds size in header of '0' bytes for entry '/PaxHeadersX/fvv/' testWriteNonAsciiDirectoryNamePosixMode [CONTEXT] Map<String, String> headers) throws IOException { String name =\"./PaxHeaders.X/\" + stripTo7Bits(entryName); [BUGGY] [BUGGY]  if (name.length() >= TarConstants.NAMELEN) { name = name.substring(0, TarConstants.NAMELEN - 1); } TarArchiveEntry pex = new TarArchiveEntry(name, TarConstants.LF_PAX_EXTENDED_HEADER_LC); StringWriter w = new StringWriter(); for (Map.Entry<String, String> h : headers.entrySet()) { String key = h.getKey(); [CLASS] TarArchiveOutputStream [METHOD] writePaxHeaders [RETURN_TYPE] void String entryName String> headers [VARIABLES] byte[] assemBuf data recordBuf wBuf Entry h boolean addPaxHeadersForNonAsciiNames b closed finished haveUnclosedEntry paxHeaderContainsPath ZipEncoding ASCII encoding StringWriter w OutputStream os out TarBuffer buffer String currName encoding entryName key line name value Map headers int BIGNUMBER_ERROR BIGNUMBER_POSIX BIGNUMBER_STAR LONGFILE_ERROR LONGFILE_GNU LONGFILE_POSIX LONGFILE_TRUNCATE aLen actualLength assemLen bigNumberMode blockSize i len longFileMode nameLen num numToWrite recordSize wOffset long currBytes currSize TarArchiveEntry pex ", "output": "[PATCH] while (name.endsWith(\"/\")) {  name = name.substring(0, name.length() - 1); } ", "bugid": "330"}, {"instruction": "The following code contains a buggy line with the following test error: zipZipException testExcessDataInZip64ExtraField . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void testExcessDataInZip64ExtraField() throws Exception {  File archive = getFile(\"COMPRESS-228.zip\");  zf = new ZipFile(archive);  // actually, if we get here, the test already has passed", "input": "[BUG] [BUGGY] if (rawCentralDirectoryData.length != expectedLength) { [FE] zipZipException testExcessDataInZip64ExtraField [CONTEXT] [BUGGY] if (rawCentralDirectoryData.length != expectedLength) { [BUGGY] throw new ZipException(\"central directory zip64 extended\" +\" information extra field's length\" +\" doesn't match central directory\" +\" data.Expected length\" + expectedLength +\" but is\" + rawCentralDirectoryData.length); } int offset = 0; if (hasUncompressedSize) { size = new ZipEightByteInteger(rawCentralDirectoryData, offset); [CLASS] Zip64ExtendedInformationExtraField [METHOD] reparseCentralDirectoryData [RETURN_TYPE] void boolean hasUncompressedSize boolean hasCompressedSize boolean hasRelativeHeaderOffset boolean hasDiskStart [VARIABLES] byte[] EMPTY buffer data rawCentralDirectoryData ZipLong diskStart ZipShort HEADER_ID boolean hasCompressedSize hasDiskStart hasRelativeHeaderOffset hasUncompressedSize String LFH_MUST_HAVE_BOTH_SIZES_MSG ZipEightByteInteger compressedSize relativeHeaderOffset size int expectedLength offset ", "output": "[PATCH] if (rawCentralDirectoryData.length < expectedLength) { ", "bugid": "331"}, {"instruction": "The following code contains a buggy line with the following test error: xzUnsupportedOptionsException: LZMA dictionary is too big for this implementation testCompressedHeaderWithNonDefaultDictionarySize . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] dictSize |= (coder.properties[i + 1] << (8 * i)); [FE] xzUnsupportedOptionsException: LZMA dictionary is too big for this implementation testCompressedHeaderWithNonDefaultDictionarySize [CONTEXT] InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException { byte propsByte = coder.properties[0]; long dictSize = coder.properties[1]; for (int i = 1; i < 4; i++) { [BUGGY] dictSize |= (coder.properties[i + 1] << (8 * i)); [BUGGY] } if (dictSize > LZMAInputStream.DICT_SIZE_MAX) { throw new IOException(\"Dictionary larger than 4GiB maximum size\"); } return new LZMAInputStream(in, -1, propsByte, (int) dictSize); } [CLASS] Coders CoderId CoderBase CopyDecoder LZMADecoder DeflateDecoder BZIP2Decoder AES256SHA256Decoder 1 DummyByteAddingInputStream [METHOD] decode [RETURN_TYPE] InputStream InputStream in Coder coder byte[] password [VARIABLES] byte[] password Coder coder boolean addDummyByte isInitialized CipherInputStream cipherInputStream InputStream in byte propsByte SevenZMethod method CoderBase coder long dictSize int i CoderId[] coderTable ", "output": "[PATCH] dictSize |= (coder.properties[i + 1] & 0xffl) << (8 * i); ", "bugid": "332"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: arrays first differed at element [0]; expected:<100> but was:<0> testReadingOfFirstStoredEntry . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    ZipArchiveEntry ze = in.getNextZipEntry();   assertEquals(5, ze.getSize());   assertArrayEquals(new byte[] {'d', 'a', 't', 'a', '\\n'},     IOUtils.toByteArray(in));  } finally {", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: arrays first differed at element [0]; expected:<100> but was:<0> testReadingOfFirstStoredEntry [CONTEXT] public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) { zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); this.useUnicodeExtraFields = useUnicodeExtraFields; in = new PushbackInputStream(inputStream, buf.capacity()); this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor; [BUGGY] [BUGGY] } public ZipArchiveEntry getNextZipEntry() throws IOException { boolean firstEntry = true; if (closed || hitCentralDirectory) { return null; } if (current != null) { closeEntry(); firstEntry = false; } [CLASS] ", "output": "[PATCH] ", "bugid": "333"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<10> but was:<0> skipUsingRead . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: expected:<10> but was:<0> skipUsingRead [CONTEXT] public static long skip(InputStream input, long numToSkip) throws IOException { long available = numToSkip; while (numToSkip > 0) { long skipped = input.skip(numToSkip); if (skipped == 0) { break; } numToSkip -= skipped; } [BUGGY] [BUGGY] return available - numToSkip; } [CLASS] IOUtils [METHOD] skip [RETURN_TYPE] long InputStream input long numToSkip [VARIABLES] boolean int COPY_BUF_SIZE SKIP_BUF_SIZE buffersize n InputStream input long available numToSkip skipped ", "output": "[PATCH] if (numToSkip > 0) { byte[] skipBuf = new byte[SKIP_BUF_SIZE]; while (numToSkip > 0) { int read = readFully(input, skipBuf, 0, (int) Math.min(numToSkip, SKIP_BUF_SIZE)); if (read < 1) { break; } numToSkip -= read; } } ", "bugid": "334"}, {"instruction": "The following code contains a buggy line with the following test error: IllegalArgumentException . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertEquals(MAX_OCTAL, value);  buffer=new byte[]{0,0};  value = TarUtils.parseOctal(buffer,0, buffer.length);  assertEquals(0, value);  buffer=new byte[]{0,' '};", "input": "[BUG] [BUGGY] if (start == end) { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, trailer)); } [FE] IllegalArgumentException [CONTEXT][BUGGY] if (start == end) { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, trailer)); } [BUGGY] for ( ;start < end; start++) { final byte currentByte = buffer[start]; if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); [CLASS] TarUtils 1 [METHOD] parseOctal [RETURN_TYPE] long final byte[] buffer final int offset final int length [VARIABLES] byte[] buffer boolean ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING int BYTE_MASK end i length offset start long result byte currentByte trailer ", "output": "[PATCH] [Delete]", "bugid": "335"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Expected exception: javaioIOException shouldThrowAnExceptionOnTruncatedEntries . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: None", "input": "[BUG] [BUGGY] count(totalRead); [FE] AssertionFailedError: Expected exception: javaioIOException shouldThrowAnExceptionOnTruncatedEntries [CONTEXT] return -1; } if (currEntry == null) { throw new IllegalStateException(\"No current tar entry\"); } numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); [BUGGY] count(totalRead); [BUGGY] if (totalRead == -1) { hasHitEOF = true; } else { entryOffset += totalRead; } return totalRead; } [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int byte[] buf int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding encoding InputStream i is int SMALL_BUFFER_SIZE blockSize ch got len length numToRead offset read readNow recordSize totalRead long available entryOffset entrySize numRecords numToSkip padding skipped TarArchiveEntry currEntry ", "output": "[PATCH] if (numToRead > 0) { throw new IOException(\"Truncated TAR archive\"); } count(totalRead); ", "bugid": "336"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<0> but was:<-1> readOfLength0ShouldReturn0 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());  BZip2CompressorInputStream bzipIn = new BZip2CompressorInputStream(bais);  byte[] buffer = new byte[1024];  Assert.assertEquals(1024, bzipIn.read(buffer, 0, 1024));  Assert.assertEquals(0, bzipIn.read(buffer, 1024, 0));", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: expected:<0> but was:<-1> readOfLength0ShouldReturn0 [CONTEXT] if (len < 0) { throw new IndexOutOfBoundsException(\"\"); } if (offs + len > dest.length) { throw new IndexOutOfBoundsException(\"\"); } if (this.in == null) { throw new IOException(\"stream closed\"); } [BUGGY] [BUGGY] final int hi = offs + len; int destOffs = offs; int b; while (destOffs < hi && ((b = read0()) >= 0)) { dest[destOffs++] = (byte) b; count(1); } int c = (destOffs == offs) ? -1 : (destOffs - offs); return c; [CLASS] BZip2CompressorInputStream Data [METHOD] read [RETURN_TYPE] int final byte[] dest final int offs final int len [VARIABLES] int[][] base limit perm InputStream in char[][] temp_charArray2d Data data int[] cftab minLens tt unzftab int EOF NO_RAND_PART_A_STATE NO_RAND_PART_B_STATE NO_RAND_PART_C_STATE RAND_PART_A_STATE RAND_PART_B_STATE RAND_PART_C_STATE START_BLOCK_STATE b blockSize100k bsBuff bsLive c computedBlockCRC computedCombinedCRC currentState destOffs hi last len nInUse offs origPtr r storedBlockCRC storedCombinedCRC su_ch2 su_chPrev su_count su_i2 su_j2 su_rNToGo su_rTPos su_tPos char[] getAndMoveToFrontDecode_yy byte[] dest ll8 recvDecodingTables_pos selector selectorMtf seqToUnseq boolean blockRandomised decompressConcatenated CRC crc char su_z boolean[] inUse ", "output": "[PATCH] if (len == 0) { return 0; } ", "bugid": "337"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Expected IOException testCOMPRESS178 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   try {   in.getNextEntry();   fail(\"Expected IOException\");  } catch (IOException e) {   Throwable t = e.getCause();", "input": "[BUG] [BUGGY] if (currentByte == 0) { break; } [FE] AssertionFailedError: Expected IOException testCOMPRESS178 [CONTEXT]  byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer == ' ')) { end--; trailer = buffer[end - 1]; } for ( ;start < end; start++) { final byte currentByte = buffer[start]; [BUGGY] if (currentByte == 0) { break; } [BUGGY] if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); } [CLASS] TarUtils 1 [METHOD] parseOctal [RETURN_TYPE] long final byte[] buffer final int offset final int length [VARIABLES] byte[] buffer boolean ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING int BYTE_MASK end i length offset start long result byte currentByte trailer ", "output": "[PATCH] [Delete] ", "bugid": "338"}, {"instruction": "The following code contains a buggy line with the following test error: IllegalStateException: No current 7z entry (call getNextEntry() first) readEntriesOfSize0 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    while (entry != null) {    entries++;    int b = sevenZFile.read();    if (\"2.txt\".equals(entry.getName()) || \"5.txt\".equals(entry.getName())) { assertEquals(-1, b);", "input": "[BUG] [BUGGY] [FE] IllegalStateException: No current 7z entry (call getNextEntry() first) readEntriesOfSize0 [CONTEXT] private InputStream getCurrentStream() throws IOException { [BUGGY] [BUGGY] if (deferredBlockStreams.isEmpty()) { throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\"); } while (deferredBlockStreams.size() > 1) {  final InputStream stream = deferredBlockStreams.remove(0); IOUtils.skip(stream, Long.MAX_VALUE); stream.close(); [CLASS] SevenZFile [METHOD] getCurrentStream [RETURN_TYPE] InputStream [VARIABLES] byte[] names nextHeader password property sevenZSignature signature Archive archive boolean RandomAccessFile file InputStream currentFolderInputStream fileStream inputStreamStack stream ArrayList deferredBlockStreams String fileName int SIGNATURE_HEADER_SIZE areAllDefined bits cache currentEntryIndex currentFolderIndex emptyFileCounter external firstPackStreamIndex folderIndex i idSize mask nextCrc nextFile nextFolderIndex nextFolderPackStreamIndex nextFolderUnpackStreamIndex nextHeaderSizeInt nextMissingCrc nextName nextUnpackStream nid nonEmptyFileCounter numDigests numFolders numPackSizes propertyType size totalUnpackStreams ", "output": "[PATCH] if (archive.files[currentEntryIndex].getSize() == 0) { return new ByteArrayInputStream(new byte[0]); } ", "bugid": "339"}, {"instruction": "The following code contains a buggy line with the following test error: NegativeArraySizeException survivesBlankLinesInPaxHeader . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   final TarArchiveInputStream is = getTestStream(\"/COMPRESS-355.tar\");  try {   final TarArchiveEntry entry = is.getNextTarEntry();   assertEquals(\"package/package.json\", entry.getName());   assertNull(is.getNextTarEntry());", "input": "[BUG] [BUGGY] [FE] NegativeArraySizeException survivesBlankLinesInPaxHeader [CONTEXT] throws IOException { final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders); while(true){ int ch; int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; [BUGGY] [BUGGY] if (ch == ' '){ final ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ final String keyword = coll.toString(CharsetNames.UTF_8); final int restLen = len - read; if (restLen == 1) { headers.remove(keyword); [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry ", "output": "[PATCH] ", "bugid": "340"}, {"instruction": "The following code contains a buggy line with the following test error: IOException: Error detected parsing the header survivesPaxHeaderWithNameEndingInSlash . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   final TarArchiveInputStream is = getTestStream(\"/COMPRESS-356.tar\");  try {   final TarArchiveEntry entry = is.getNextTarEntry();   assertEquals(\"package/package.json\", entry.getName());   assertNull(is.getNextTarEntry());", "input": "[BUG] [BUGGY] if (getName().endsWith(\"/\")) { [FE] IOException: Error detected parsing the header survivesPaxHeaderWithNameEndingInSlash [CONTEXT] public boolean isDirectory() { if (file != null) { return file.isDirectory(); } if (linkFlag == LF_DIR) { return true; } [BUGGY] if (getName().endsWith(\"/\")) { [BUGGY] return true; } return false; } [CLASS] TarArchiveEntry [METHOD] isDirectory [RETURN_TYPE] boolean [VARIABLES] boolean checkSumOK isDir isExtended paxGNUSparse preserveLeadingSlashes starSparse byte linkFlag String fileName groupName link linkName magic name normalizedName user userName version File file int DEFAULT_DIR_MODE DEFAULT_FILE_MODE MAX_NAMELEN MILLIS_PER_SECOND devMajor devMinor devNo groupId mode nameLength userId long groupId modTime realSize size time userId TarArchiveEntry[] EMPTY_TAR_ARCHIVE_ENTRIES ", "output": "[PATCH] if (!isPaxHeader() && !isGlobalPaxHeader() && getName().endsWith(\"/\")) { ", "bugid": "341"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<1> but was:<0> testListAllFilesWithNestedArchive . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertTrue(results.contains(\"test2.xml\"));  assertTrue(results.contains(\"test3.xml\"));  assertEquals(1, expectedExceptions.size()); }", "input": "[BUG] [BUGGY] return null; [FE] AssertionFailedError: expected:<1> but was:<0> testListAllFilesWithNestedArchive [CONTEXT] readFully(LFH_BUF); } } catch (final EOFException e) { return null; } final ZipLong sig = new ZipLong(LFH_BUF); if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) { hitCentralDirectory = true; skipRemainderOfArchive(); [BUGGY] } [BUGGY] if (!sig.equals(ZipLong.LFH_SIG)) { return null; } int off = WORD; current = new CurrentEntry(); final int versionMadeBy = ZipShort.getValue(LFH_BUF, off); off += SHORT; current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK); [CLASS] ZipArchiveInputStream CurrentEntry BoundedInputStream [METHOD] getNextZipEntry [RETURN_TYPE] ZipArchiveEntry [VARIABLES] ZipEncoding entryEncoding zipEncoding CRC32 crc InputStream in inputStream String encoding GeneralPurposeBit gpFlag ByteBuffer buf int CFH_LEN LFH_LEN entriesRead extraLen fileNameLen off versionMadeBy long TWO_EXP_32 bytesRead bytesReadFromStream max pos size time byte[] CFH DD LFH LFH_BUF SHORT_BUF SKIP_BUF TWO_DWORD_BUF WORD_BUF extraData fileName CurrentEntry current ZipLong cSize sig size boolean allowStoredEntriesWithDataDescriptor closed firstEntry hasDataDescriptor hasUTF8Flag hitCentralDirectory useUnicodeExtraFields usesZip64 ByteArrayInputStream lastStoredEntry EOFException e ZipArchiveEntry entry Inflater inf ", "output": "[PATCH] return null; throw new ZipException(String.format(\"Unexpected record signature: 0X%X\", sig.getValue())); ", "bugid": "342"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Expected exception: javalangnull  testClassInstantiationWithParameterBeingNullThrowsnull One . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: None", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: Expected exception: javalangnull  testClassInstantiationWithParameterBeingNullThrowsnull One [CONTEXT] public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) { [BUGGY] [BUGGY] this.checksum = checksum; this.in = in; } [CLASS] ChecksumCalculatingInputStream [METHOD] <init> [RETURN_TYPE] InputStream) Checksum checksum InputStream in [VARIABLES] InputStream in Checksum checksum boolean ", "output": "[PATCH] if ( checksum == null ){ throw new null (\"Parameter checksum must not be null\"); } if ( in == null ){ throw new null (\"Parameter in must not be null\"); } ", "bugid": "343"}, {"instruction": "The following code contains a buggy line with the following test error: IllegalArgumentException: Value -72057594037927935 is too large for 8 byte field testRoundTripOctalOrBinary8 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  }", "input": "[BUG] [BUGGY] formatBigIntegerBinary(value, buf, offset, length, negative); [FE] IllegalArgumentException: Value -72057594037927935 is too large for 8 byte field testRoundTripOctalOrBinary8 [CONTEXT] final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE; final boolean negative = value < 0; if (!negative && value <= maxAsOctalChar) { return formatLongOctalBytes(value, buf, offset, length); } if (length < 9) { formatLongBinary(value, buf, offset, length, negative); [BUGGY] } [BUGGY] formatBigIntegerBinary(value, buf, offset, length, negative); buf[offset] = (byte) (negative ? 0xff : 0x80); return offset + length; } [CLASS] TarUtils 1 [METHOD] formatLongOctalOrBinaryBytes [RETURN_TYPE] int final long value final byte[] buf final int offset final int length [VARIABLES] byte[] buf boolean negative ZipEncoding DEFAULT_ENCODING FALLBACK_ENCODING encoding int BYTE_MASK current end i idx len length limit offset remaining start long maxAsOctalChar value ", "output": "[PATCH] } else { formatBigIntegerBinary(value, buf, offset, length, negative); ", "bugid": "344"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Time too big for 32 bits! testGettersSetters . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    // Java time is 1000 x larger (milliseconds).   xf.setModifyJavaTime(new Date(1000L * (MAX_TIME_SECONDS.getValue() + 1L)));   fail(\"Time too big for 32 bits!\");  } catch (final IllegalArgumentException iae) {   // All is good.", "input": "[BUG] [BUGGY] final long TWO_TO_32 = 0x100000000L; if (l >= TWO_TO_32) { [FE] AssertionFailedError: Time too big for 32 bits! testGettersSetters [CONTEXT] private static ZipLong unixTimeToZipLong(long l) { [BUGGY] final long TWO_TO_32 = 0x100000000L; if (l >= TWO_TO_32) { [BUGGY] throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer:\" + l); } return new ZipLong(l); } [CLASS] X5455_ExtendedTimestamp [METHOD] unixTimeToZipLong [RETURN_TYPE] ZipLong long l [VARIABLES] ZipLong accessTime createTime l modifyTime unixTime ZipShort HEADER_ID boolean bit0_modifyTimePresent bit1_accessTimePresent bit2_createTimePresent byte ACCESS_TIME_BIT CREATE_TIME_BIT MODIFY_TIME_BIT flags long TWO_TO_32 l serialVersionUID ", "output": "[PATCH] if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { ", "bugid": "345"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<3> but was:<0> testEqualsAfterSerializationOfDerivedClass . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   in.close();  assertEquals(mk.hashCode(), mk2.hashCode()); }", "input": "[BUG] [BUGGY] private Object readResolve() { [FE] AssertionFailedError: expected:<3> but was:<0> testEqualsAfterSerializationOfDerivedClass [CONTEXT] [BUGGY] private Object readResolve() { [BUGGY] calculateHashCode(keys); return this; } [CLASS] MultiKey [METHOD] readResolve [RETURN_TYPE] Object [VARIABLES] boolean K[] keys long serialVersionUID int hashCode index total ", "output": "[PATCH] protected Object readResolve() { ", "bugid": "346"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: unsafe clazz accepted when de-serializing MultiValueMap testUnsafeDeSerialization . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   try {   result = deserialize(bytes);   fail(\"unsafe clazz accepted when de-serializing MultiValueMap\");  } catch (UnsupportedOperationException ex) {   // expected", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: unsafe clazz accepted when de-serializing MultiValueMap testUnsafeDeSerialization [CONTEXT] @Override public T create() { try { return clazz.newInstance(); } catch (final Exception ex) { throw new FunctorException(\"Cannot instantiate class:\" + clazz, ex); } } [BUGGY] [BUGGY] } } [CLASS] ", "output": "[PATCH] private void readObject(ObjectInputStream is) throws IOException, ClassNotFoundException { is.defaultReadObject(); if (clazz != null && !Collection.class.isAssignableFrom(clazz)) { throw new UnsupportedOperationException(); } } ", "bugid": "347"}, {"instruction": "The following code contains a buggy line with the following test error: null  testPrefixMapClear . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertEquals(Arrays.asList(5, 4, 6), new ArrayList<Integer>(prefixMap.values()));  prefixMap.clear();  assertTrue(prefixMap.isEmpty());  assertTrue(prefixMap.keySet().isEmpty());", "input": "[BUG] [BUGGY] [FE] null  testPrefixMapClear [CONTEXT] public boolean isToInclusive() { return false; } @Override protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive, final K toKey, final boolean toInclusive) { return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive); } [BUGGY] [BUGGY] }  private final class PrefixRangeEntrySet extends RangeEntrySet { private final PrefixRangeMap delegate; private TrieEntry<K, V> prefixStart; [CLASS] ", "output": "[PATCH] @Override public void clear() { Iterator<Map.Entry<K, V>> it = AbstractPatriciaTrie.this.entrySet().iterator(); Set<K> currentKeys = keySet(); while (it.hasNext()) { if (currentKeys.contains(it.next().getKey())) { it.remove(); } } } ", "bugid": "348"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testWith3 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   try {   test.with(DateTimeFieldType.clockhourOfDay(), 6);   fail();  } catch (IllegalArgumentException ex) {}  check(test, 10, 20);", "input": "[BUG] [BUGGY] Partial newPartial = new Partial(iChronology, newTypes, newValues); [FE] AssertionFailedError testWith3 [CONTEXT]  [BUGGY] Partial newPartial = new Partial(iChronology, newTypes, newValues);  [BUGGY]  [CLASS] Partial Property [METHOD] with [RETURN_TYPE] Partial DateTimeFieldType fieldType int value [VARIABLES] DateTimeFieldType[]  newTypes  int[] newValues  Chronology chrono chronology iChronology  ", "output": "[PATCH] Partial newPartial = new Partial(newTypes, newValues, iChronology); ", "bugid": "349"}, {"instruction": "The following code contains a buggy line with the following test error: UnsupportedOperationException: Field is not supported testNormalizedStandard_periodType_months1 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void testNormalizedStandard_periodType_months1() {  Period test = new Period(1, 15, 0, 0, 0, 0, 0, 0);  Period result = test.normalizedStandard(PeriodType.months());  assertEquals(new Period(1, 15, 0, 0, 0, 0, 0, 0), test);  assertEquals(new Period(0, 27, 0, 0, 0, 0, 0, 0, PeriodType.months()), result);", "input": "[BUG] [BUGGY] years = FieldUtils.safeAdd(years, months / 12); months = months % 12; if (years != 0) { result = result.withYears(years); if (months != 0) { result = result.withMonths(months); [FE] UnsupportedOperationException: Field is not supported testNormalizedStandard_periodType_months1 [CONTEXT] long millis = getMillis(); millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND)); millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE)); millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR)); millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY)); millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK)); Period result = new Period(millis, type, ISOChronology.getInstanceUTC()); int years = getYears(); int months = getMonths(); if (years != 0 || months != 0) { [BUGGY] years = FieldUtils.safeAdd(years, months / 12); months = months % 12; if (years != 0) { result = result.withYears(years); } if (months != 0) { [BUGGY] result = result.withMonths(months); } } return result; } [CLASS] Period [METHOD] normalizedStandard [RETURN_TYPE] Period PeriodType type [VARIABLES] Period ZERO result PeriodType type boolean long days duration endInstant hours millis minutes seconds serialVersionUID startInstant weeks int months years ", "output": "[PATCH] long totalMonths = years * 12L + months; if (type.isSupported(DurationFieldType.YEARS_TYPE)) { int normalizedYears = FieldUtils.safeToInt(totalMonths / 12); result = result.withYears(normalizedYears); totalMonths = totalMonths - (normalizedYears * 12); if (type.isSupported(DurationFieldType.MONTHS_TYPE)) { int normalizedMonths = FieldUtils.safeToInt(totalMonths); result = result.withMonths(normalizedMonths); totalMonths = totalMonths - normalizedMonths; } if (totalMonths != 0) { throw new UnsupportedOperationException(\"Unable to normalize as PeriodType is missing either years or months but period has a month/year amount:\" + toString()); ", "bugid": "350"}, {"instruction": "The following code contains a buggy line with the following test error: timeIllegalFieldValueException testParseInto_monthDay_feb29_newYork_startOfYear . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   DateTimeFormatter f = DateTimeFormat.forPattern(\"M d\").withLocale(Locale.UK);  MutableDateTime result = new MutableDateTime(2004, 1, 1, 0, 0, 0, 0, NEWYORK);  assertEquals(4, f.parseInto(result, \"2 29\", 0));  assertEquals(new MutableDateTime(2004, 2, 29, 0, 0, 0, 0, NEWYORK), result); }", "input": "[BUG] [BUGGY] int defaultYear = chrono.year().get(instantLocal); [FE] timeIllegalFieldValueException testParseInto_monthDay_feb29_newYork_startOfYear [CONTEXT] public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException(\"Instant must not be null\"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); [BUGGY] long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); [BUGGY] chrono = selectChronology(chrono); int defaultYear = chrono.year().get(instantLocal); DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, defaultYear); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [CLASS] DateTimeFormatter [METHOD] parseInto [RETURN_TYPE] int ReadWritableInstant instant String text int position [VARIABLES] Locale iLocale locale Integer iPivotYear pivotYear DateTimeParser iParser parser boolean iOffsetParsed offsetParsed DateTimeParserBucket bucket ReadWritableInstant instant Chronology chrono iChrono String text DateTimePrinter iPrinter printer DateTimeZone iZone parsedZone zone int defaultYear iDefaultYear newPos offset parsedOffset pivotYear position long instantLocal instantMillis ", "output": "[PATCH] int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis); ", "bugid": "351"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testDateTimeZoneBuilder . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   t.start();  t.join();  assertNotNull(zone[0]); }", "input": "[BUG] [BUGGY] static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); } [FE] AssertionFailedError testDateTimeZoneBuilder [CONTEXT] static Chronology cLenientISO; [CLASS] ZoneInfoCompiler DateTimeOfYear Rule RuleSet Zone [VARIABLES] ", "output": "[PATCH] static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>() { protected Boolean initialValue() { return Boolean.FALSE; } }; ", "bugid": "352"}, {"instruction": "The following code contains a buggy line with the following test error: timeIllegalFieldValueException: Value 29 for dayOfMonth must be in the range [1,28] testPlusMonths_int_negativeFromLeap . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void testPlusMonths_int_negativeFromLeap() {  MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC());  MonthDay result = test.plusMonths(-1);  MonthDay expected = new MonthDay(1, 29, ISOChronology.getInstance());  assertEquals(expected, result);", "input": "[BUG] [BUGGY] [FE] timeIllegalFieldValueException: Value 29 for dayOfMonth must be in the range [1,28] testPlusMonths_int_negativeFromLeap [CONTEXT] public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {  if (valueToAdd == 0) { return values; } [BUGGY] [BUGGY] if (DateTimeUtils.isContiguous(partial)) { long instant = 0L; for (int i = 0, isize = partial.size(); i < isize; i++) { instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); } instant = add(instant, valueToAdd); return iChronology.get(partial, instant); } else { return super.add(partial, fieldIndex, values, valueToAdd); } [CLASS] BasicMonthOfYearDateTimeField [METHOD] add [RETURN_TYPE] int[] ReadablePartial partial int fieldIndex int[] values int valueToAdd [VARIABLES] int[] values ReadablePartial partial boolean long datePart instant monthToUse months serialVersionUID timePart yearToUse int MIN dayToUse fieldIndex i iLeapMonth iMax i_monthToUse i_months i_yearToUse isize leapMonth maxDay monthToUse months remMonthToUse thisMonth thisYear valueToAdd yearToUse BasicChronology chronology iChronology ", "output": "[PATCH] if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) { int curMonth0 = partial.getValue(0) - 1; int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1; return set(partial, 0, values, newMonth); } ", "bugid": "353"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testSafeMultiplyLongInt . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   try {   FieldUtils.safeMultiply(Long.MIN_VALUE, -1);   fail();  } catch (ArithmeticException e) {  }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError testSafeMultiplyLongInt [CONTEXT] public static long safeMultiply(long val1, int val2) { switch (val2) { case -1: [BUGGY] [BUGGY] return -val1; case 0: return 0L; case 1: return val1; } long total = val1 * val2; if (total / val2 != val1) { throw new ArithmeticException(\"Multiplication overflows a long:\" + val1 +\" *\" + val2); } return total; [CLASS] FieldUtils [METHOD] safeMultiply [RETURN_TYPE] long long val1 int val2 [VARIABLES] boolean long total val1 int val2 ", "output": "[PATCH] if (val1 == Long.MIN_VALUE) { throw new ArithmeticException(\"Multiplication overflows a long:\" + val1 +\" *\" + val2); } ", "bugid": "354"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<2004-05-01T12:20:30000+09:00> but was:<2000-05-01T12:20:30000+09:00> testParseInto_monthOnly_baseStartYear . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   MutableDateTime result = new MutableDateTime(2004, 1, 1, 12, 20, 30, 0, TOKYO);  assertEquals(1, f.parseInto(result, \"5\", 0));  assertEquals(new MutableDateTime(2004, 5, 1, 12, 20, 30, 0, TOKYO), result); }", "input": "[BUG] [BUGGY] instantLocal, chrono, iLocale, iPivotYear, iDefaultYear); [FE] AssertionFailedError: expected:<2004-05-01T12:20:30000+09:00> but was:<2000-05-01T12:20:30000+09:00> testParseInto_monthOnly_baseStartYear [CONTEXT] if (instant == null) { throw new IllegalArgumentException(\"Instant must not be null\"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); DateTimeParserBucket bucket = new DateTimeParserBucket( [BUGGY] instantLocal, chrono, iLocale, iPivotYear, iDefaultYear); [BUGGY] int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone() != null) { chrono = chrono.withZone(bucket.getZone()); } instant.setChronology(chrono); [CLASS] DateTimeFormatter [METHOD] parseInto [RETURN_TYPE] int ReadWritableInstant instant String text int position [VARIABLES] Locale iLocale locale Integer iPivotYear pivotYear DateTimeParser iParser parser boolean iOffsetParsed offsetParsed DateTimeParserBucket bucket ReadWritableInstant instant Chronology chrono iChrono String text DateTimePrinter iPrinter printer DateTimeZone iZone parsedZone zone int defaultYear iDefaultYear newPos offset parsedOffset pivotYear position long instantLocal instantMillis ", "output": "[PATCH] instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal)); ", "bugid": "355"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<1-10-30T01:15:00000[+01:00]> but was:<1-10-30T01:15:00000[Z]> testDateTimeCreation_london . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   DateTimeZone zone = DateTimeZone.forID(\"Europe/London\");  DateTime base = new DateTime(2011, 10, 30, 1, 15, zone);  assertEquals(\"2011-10-30T01:15:00.000+01:00\", base.toString());  assertEquals(\"2011-10-30T01:15:00.000Z\", base.plusHours(1).toString()); }", "input": "[BUG] [BUGGY] } else if (offsetLocal > 0) { [FE] ComparisonFailure: expected:<1-10-30T01:15:00000[+01:00]> but was:<1-10-30T01:15:00000[Z]> testDateTimeCreation_london [CONTEXT] if ((offsetLocal - offsetAdjusted) < 0) {  long nextLocal = nextTransition(instantAdjusted); long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); if (nextLocal != nextAdjusted) { return offsetLocal; } } [BUGGY] } else if (offsetLocal > 0) { [BUGGY] long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; } } } return offsetAdjusted; [CLASS] DateTimeZone 1 Stub [METHOD] getOffsetFromLocal [RETURN_TYPE] int long instantLocal [VARIABLES] Set cAvailableIDs ids boolean NameProvider cNameProvider nameProvider String convId iID id name nameKey providerClass str DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache map long instant instantAdjusted instantLocal nextAdjusted nextLocal prev serialVersionUID DateTimeZone UTC cDefault dtz temp zone int diff offsetAdjusted offsetLocal offsetPrev Provider cProvider provider ", "output": "[PATCH] } else if (offsetLocal >= 0) { ", "bugid": "356"}, {"instruction": "The following code contains a buggy line with the following test error: IllegalArgumentException: Invalid format:\"2007-03-04 12:30 America/Dawson_Creek\" is malformed at\"_Creek\" test_printParseZoneDawsonCreek . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forID(\"America/Dawson_Creek\"));  assertEquals(\"2007-03-04 12:30 America/Dawson_Creek\", f.print(dt));  assertEquals(dt, f.parseDateTime(\"2007-03-04 12:30 America/Dawson_Creek\")); }", "input": "[BUG] [BUGGY] bucket.setZone(DateTimeZone.forID(id)); return position + id.length(); [FE] IllegalArgumentException: Invalid format:\"2007-03-04 12:30 America/Dawson_Creek\" is malformed at\"_Creek\" test_printParseZoneDawsonCreek [CONTEXT] public int parseInto(DateTimeParserBucket bucket, String text, int position) { String str = text.substring(position); [BUGGY] for (String id : ALL_IDS) { if (str.startsWith(id)) { [BUGGY] bucket.setZone(DateTimeZone.forID(id)); return position + id.length(); } } return ~position; } [CLASS] DateTimeFormatterBuilder CharacterLiteral StringLiteral NumberFormatter UnpaddedNumber PaddedNumber FixedNumber TwoDigitYear TextField Fraction TimeZoneOffset TimeZoneName TimeZoneId Composite MatchingParser [METHOD] parseInto [RETURN_TYPE] int DateTimeParserBucket bucket String text int position [VARIABLES] DateTimePrinter[] iPrinters Set ALL_IDS validValues DateTimeParserBucket bucket ArrayList iElementPairs DateTimeParser[] copyOfParsers iParsers parsers String iValue iZeroOffsetParseText iZeroOffsetPrintText id match name pattern str text value zeroOffsetParseText zeroOffsetPrintText zeroOffsetText int LONG_NAME MAX_LENGTH SHORT_NAME amount count digits displayOffset est expectedPos hours i iMaxDigits iMaxFields iMaxParsedDigits iMinDigits iMinFields iMinPrintedDigits iParsedLengthEstimate iPivot iPrintedLengthEstimate iType len length limit low max maxDigits maxFields maxLength maxParsedDigits min minDigits minFields minPrintedDigits minutes newPos numDigits offset parseEst pivot position printEst seconds size t type value year boolean expectSeparators hasSignChar iLenientParse iShort iShowSeparators iSigned isShort lenientParse negative showSeparators signed TimeZoneId INSTANCE char a b c iValue value DateTimeFieldType fieldType iFieldType iType type Object element f iFormatter parser printer Map cParseCache iParseLookup innerMap parseLookup ", "output": "[PATCH] String best = null; \\tif (best == null || id.length() > best.length()) { \\t\\tbest = id; \\t} if (best != null) { bucket.setZone(DateTimeZone.forID(best)); return position + best.length(); } ", "bugid": "357"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<0> but was:<64> testToPeriod_fixedZone . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450   assertEquals(0, test.getMonths());   assertEquals(0, test.getWeeks());   assertEquals(0, test.getDays());   assertEquals((450 * 24) + 5, test.getHours());", "input": "[BUG] [BUGGY] this(duration, null, null); [FE] AssertionFailedError: expected:<0> but was:<64> testToPeriod_fixedZone [CONTEXT] protected BasePeriod(long duration) { [BUGGY] this(duration, null, null); [BUGGY] } [CLASS] BasePeriod [METHOD] <init> [RETURN_TYPE] BasePeriod(long) long duration [VARIABLES] PeriodType iType type int[] iValues boolean long duration durationMillis endInstant endMillis serialVersionUID startInstant startMillis ", "output": "[PATCH] super(); iType = PeriodType.time(); int[] values = ISOChronology.getInstanceUTC().get(this, duration); iType = PeriodType.standard(); iValues = new int[8]; System.arraycopy(values, 0, iValues, 4, 4); ", "bugid": "358"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<2010-01-04> but was:<2008-12-29> testParseLocalDate_weekyear_month_week_2010 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   Chronology chrono = GJChronology.getInstanceUTC();  DateTimeFormatter f = DateTimeFormat.forPattern(\"xxxx-MM-ww\").withChronology(chrono);  assertEquals(new LocalDate(2010, 1, 4, chrono), f.parseLocalDate(\"2010-01-01\")); }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: expected:<2010-01-04> but was:<2008-12-29> testParseLocalDate_weekyear_month_week_2010 [CONTEXT] saveField(DateTimeFieldType.year(), iDefaultYear); return computeMillis(resetFields, text); } } long millis = iMillis; try { for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, resetFields); } [BUGGY] [BUGGY] } catch (IllegalFieldValueException e) { if (text != null) { e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); } throw e; } if (iZone == null) { millis -= iOffset; } else { int offset = iZone.getOffsetFromLocal(millis); [CLASS] DateTimeParserBucket SavedState SavedField [METHOD] computeMillis [RETURN_TYPE] long boolean resetFields String text [VARIABLES] Locale iLocale locale IllegalFieldValueException e SavedField[] iSavedFields newArray savedFields DateTimeField field iField String iText message text long iMillis instantLocal millis DateTimeZone iZone zone int count defaultYear i iDefaultYear iOffset iSavedFieldsCount iValue offset savedFieldsCount value Integer iPivotYear pivotYear boolean iSavedFieldsShared resetFields Object iSavedState savedState Chronology chrono iChrono DurationField days first months ", "output": "[PATCH] if (resetFields) { for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, i == (count - 1)); } } ", "bugid": "359"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<10-28T02:30:00000+0[4]:00> but was:<10-28T02:30:00000+0[3]:00> test_DateTime_constructor_Moscow_Autumn . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void test_DateTime_constructor_Moscow_Autumn() {  DateTime dt = new DateTime(2007, 10, 28, 2, 30, ZONE_MOSCOW);  assertEquals(\"2007-10-28T02:30:00.000+04:00\", dt.toString()); }", "input": "[BUG] [BUGGY] [FE] ComparisonFailure: expected:<10-28T02:30:00000+0[4]:00> but was:<10-28T02:30:00000+0[3]:00> test_DateTime_constructor_Moscow_Autumn [CONTEXT] if ((offsetLocal - offsetAdjusted) < 0) {  long nextLocal = nextTransition(instantAdjusted); long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); if (nextLocal != nextAdjusted) { return offsetLocal; } } [BUGGY] [BUGGY] } return offsetAdjusted; } [CLASS] DateTimeZone 1 Stub [METHOD] getOffsetFromLocal [RETURN_TYPE] int long instantLocal [VARIABLES] Set cAvailableIDs ids boolean NameProvider cNameProvider nameProvider String convId iID id name nameKey providerClass str DateTimeFormatter cOffsetFormatter Map cZoneIdConversion iFixedOffsetCache map long instant instantAdjusted instantLocal nextAdjusted nextLocal serialVersionUID DateTimeZone UTC cDefault dtz temp zone int offsetAdjusted offsetLocal Provider cProvider provider ", "output": "[PATCH] } else if (offsetLocal > 0) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; } } ", "bugid": "360"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<7> but was:<null> testXmlAttributesWithNextTextValue . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void testXmlAttributesWithNextTextValue() throws Exception {  final String XML = \"<data max=\\\"7\\\" offset=\\\"9\\\"/>\";  FromXmlParser xp = (FromXmlParser) _xmlFactory.createParser(new StringReader(XML));", "input": "[BUG] [BUGGY] _currText = _xmlTokens.getText(); break; [FE] ComparisonFailure: expected:<7> but was:<null> testXmlAttributesWithNextTextValue [CONTEXT] _nextToken = JsonToken.FIELD_NAME; _currText = _xmlTokens.getText(); _parsingContext = _parsingContext.createChildObjectContext(-1, -1); _currToken = JsonToken.START_OBJECT; } else { _parsingContext.setCurrentName(_xmlTokens.getLocalName()); _currToken = JsonToken.FIELD_NAME; } break; case XmlTokenStream.XML_ATTRIBUTE_VALUE: [BUGGY] _currText = _xmlTokens.getText(); _currToken = JsonToken.VALUE_STRING; [BUGGY] break; case XmlTokenStream.XML_TEXT: _currText = _xmlTokens.getText(); if (_mayBeLeaf) { _mayBeLeaf = false; _xmlTokens.skipEndElement();  [CLASS] FromXmlParser Feature [METHOD] nextTextValue [RETURN_TYPE] String [VARIABLES] byte[] _binaryValue boolean _closed _defaultState _mayBeLeaf defaultState state Set _namesToWrap namesToWrap XmlReadContext _parsingContext ctxt parent XmlTokenStream _xmlTokens IOContext _ioContext ctxt JsonToken _nextToken t String DEFAULT_UNNAMED_TEXT_PROPERTY _cfgNameForTextElement _currText name ObjectCodec _objectCodec c codec ByteArrayBuilder _byteArrayBuilder int _formatFeatures _mask flags genericParserFeatures mask token values xmlFeatures ", "output": "[PATCH] return (_currText = _xmlTokens.getText()); ", "bugid": "361"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<<[rudy]/>> but was:<<[null]/>> testDynamicRootName . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   // and even with null will respect configured root name  xml = w.writeValueAsString(null);  assertEquals(\"<rudy/>\", xml); }", "input": "[BUG] [BUGGY] _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL); [FE] ComparisonFailure: expected:<<[rudy]/>> but was:<<[null]/>> testDynamicRootName [CONTEXT] protected void _serializeXmlNull(JsonGenerator jgen) throws IOException {  [BUGGY] if (jgen instanceof ToXmlGenerator) { [BUGGY] _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL); } super.serializeValue(jgen, null); } [CLASS] XmlSerializerProvider [METHOD] _serializeXmlNull [RETURN_TYPE] void JsonGenerator jgen [VARIABLES] XmlRootNameLookup _rootNameLookup rootNames JsonGenerator jgen boolean QName ROOT_NAME_FOR_NULL rootName long serialVersionUID ", "output": "[PATCH] QName rootName = _rootNameFromConfig(); if (rootName == null) { rootName = ROOT_NAME_FOR_NULL; } _initWithRootName((ToXmlGenerator) jgen, rootName); ", "bugid": "362"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Should NOT use name 'AnnotatedName' but 'Pojo282', xml = <AnnotatedName><a>3</a></AnnotatedName> testCopyWith . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   if (!xml1.contains(\"AnnotatedName\")) {   fail(\"Should use name 'AnnotatedName', xml = \"+xml1);  }  if (!xml2.contains(\"Pojo282\")", "input": "[BUG] [BUGGY] _rootNameLookup = src._rootNameLookup; [FE] AssertionFailedError: Should NOT use name 'AnnotatedName' but 'Pojo282', xml = <AnnotatedName><a>3</a></AnnotatedName> testCopyWith [CONTEXT] protected XmlSerializerProvider(XmlSerializerProvider src) { super(src);  [BUGGY] _rootNameLookup = src._rootNameLookup; [BUGGY] } [CLASS] XmlSerializerProvider [METHOD] <init> [RETURN_TYPE] XmlSerializerProvider) XmlSerializerProvider src [VARIABLES] XmlRootNameLookup _rootNameLookup rootNames boolean QName ROOT_NAME_FOR_NULL long serialVersionUID XmlSerializerProvider src ", "output": "[PATCH] _rootNameLookup = new XmlRootNameLookup(); ", "bugid": "363"}, {"instruction": "The following code contains a buggy line with the following test error: ClassCastException: Cannot cast comgooglegsonJsonPrimitive to comgooglegsonJsonObject testJsonElementTypeMismatch . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   public void testJsonElementTypeMismatch() { try {   gson.fromJson(\"\\\"abc\\\"\", JsonObject.class);   fail(); } catch (JsonSyntaxException expected) {", "input": "[BUG] [BUGGY] return (TypeAdapter<T2>) typeAdapter; [FE] ClassCastException: Cannot cast comgooglegsonJsonPrimitive to comgooglegsonJsonObject testJsonElementTypeMismatch [CONTEXT] public static <T1> TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings(\"unchecked\") public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) { final Class<? super T2> requestedType = typeToken.getRawType(); if (!clazz.isAssignableFrom(requestedType)) { return null; } [BUGGY] return (TypeAdapter<T2>) typeAdapter; [BUGGY] } @Override public String toString() { return\"Factory[typeHierarchy=\" + clazz.getName() +\",adapter=\" + typeAdapter +\"]\"; } }; } [CLASS] TypeAdapters 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 1 23 24 25 EnumTypeAdapter 26 27 28 29 30 31 [METHOD] newTypeHierarchyFactory [RETURN_TYPE] <T1> Class<T1> clazz TypeAdapter<T1> typeAdapter [VARIABLES] TypeAdapterFactory BIT_SET_FACTORY BOOLEAN_FACTORY BYTE_FACTORY CALENDAR_FACTORY CHARACTER_FACTORY CLASS_FACTORY ENUM_FACTORY INET_ADDRESS_FACTORY INTEGER_FACTORY JSON_ELEMENT_FACTORY LOCALE_FACTORY NUMBER_FACTORY SHORT_FACTORY STRING_BUFFER_FACTORY STRING_BUILDER_FACTORY STRING_FACTORY TIMESTAMP_FACTORY URI_FACTORY URL_FACTORY UUID_FACTORY boolean TypeToken typeToken TypeAdapter BIG_DECIMAL BIG_INTEGER BIT_SET BOOLEAN BOOLEAN_AS_STRING BYTE CALENDAR CHARACTER CLASS DOUBLE FLOAT INET_ADDRESS INTEGER JSON_ELEMENT LOCALE LONG NUMBER SHORT STRING STRING_BUFFER STRING_BUILDER URI URL UUID dateTypeAdapter typeAdapter Gson gson Class clazz requestedType String DAY_OF_MONTH HOUR_OF_DAY MINUTE MONTH SECOND YEAR alternate country language locale name nextString number str stringValue value variant Map constantToName nameToConstant ", "output": "[PATCH] return (TypeAdapter<T2>) new TypeAdapter<T1>() { @Override public void write(JsonWriter out, T1 value) throws IOException { typeAdapter.write(out, value); } @Override public T1 read(JsonReader in) throws IOException { T1 result = typeAdapter.read(in); if (result != null && !requestedType.isInstance(result)) { throw new JsonSyntaxException(\"Expected a\" + requestedType.getName() +\" but was\" + result.getClass().getName()); } return result; } }; ", "bugid": "364"}, {"instruction": "The following code contains a buggy line with the following test error: gsonJsonSyntaxException: 1970-01-01T01:00:00+01 testDateDeserializationISO8601 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  assertParsed(\"1970-01-01T00:00:00+00:00\", adapter); assertParsed(\"1970-01-01T01:00:00+01:00\", adapter); assertParsed(\"1970-01-01T01:00:00+01\", adapter);  }", "input": "[BUG] [BUGGY] [FE] gsonJsonSyntaxException: 1970-01-01T01:00:00+01 testDateDeserializationISO8601 [CONTEXT] TimeZone timezone = null; char timezoneIndicator = date.charAt(offset); if (timezoneIndicator == 'Z') { timezone = TIMEZONE_UTC; offset += 1; } else if (timezoneIndicator == '+' || timezoneIndicator == '-') { String timezoneOffset = date.substring(offset);  [BUGGY] [BUGGY] offset += timezoneOffset.length(); if (\"+0000\".equals(timezoneOffset) ||\"+00:00\".equals(timezoneOffset)) { timezone = TIMEZONE_UTC; } else { String timezoneId =\"GMT\" + timezoneOffset; [CLASS] ISO8601Utils [METHOD] parse [RETURN_TYPE] Date String date ParsePosition pos [VARIABLES] TimeZone TIMEZONE_UTC timezone tz boolean hasT IndexOutOfBoundsException e Calendar calendar char c timezoneIndicator NumberFormatException e String UTC_ID act cleaned date input msg timezoneId timezoneOffset ParseException ex Exception fail int day endOffset fraction hour milliseconds minutes month offset parseEndOffset seconds year IllegalArgumentException e ParsePosition pos ", "output": "[PATCH] timezoneOffset = timezoneOffset.length() >= 5 ? timezoneOffset : timezoneOffset +\"00\"; ", "bugid": "365"}, {"instruction": "The following code contains a buggy line with the following test error: null  testNullSafeBugDeserialize . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   }", "input": "[BUG] [BUGGY] typeAdapter = typeAdapter.nullSafe(); [FE] null  testNullSafeBugDeserialize [CONTEXT] typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterClass)).construct(); } else if (TypeAdapterFactory.class.isAssignableFrom(value)) { Class<TypeAdapterFactory> typeAdapterFactory = (Class<TypeAdapterFactory>) value; typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterFactory)) .construct() .create(gson, fieldType); } else { throw new IllegalArgumentException(\"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\"); } [BUGGY] typeAdapter = typeAdapter.nullSafe(); [BUGGY] return typeAdapter; } [CLASS] JsonAdapterAnnotationTypeAdapterFactory [METHOD] getTypeAdapter [RETURN_TYPE] TypeAdapter ConstructorConstructor constructorConstructor Gson gson TypeToken<?> fieldType JsonAdapter annotation [VARIABLES] ConstructorConstructor constructorConstructor boolean TypeToken fieldType TypeAdapter typeAdapter Gson gson Class typeAdapterClass typeAdapterFactory value JsonAdapter annotation ", "output": "[PATCH] if (typeAdapter != null) { typeAdapter = typeAdapter.nullSafe(); } ", "bugid": "366"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<{\"part\":[\"42\"]}> but was:<{\"part\":[42]}> testPrimitiveFieldAnnotationTakesPrecedenceOverDefault . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  Gson gson = new Gson(); String json = gson.toJson(new GadgetWithPrimitivePart(42)); assertEquals(\"{\\\"part\\\":\\\"42\\\"}\", json); GadgetWithPrimitivePart gadget = gson.fromJson(json, GadgetWithPrimitivePart.class); assertEquals(42, gadget.part);", "input": "[BUG] [BUGGY] TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType()); [FE] ComparisonFailure: expected:<{\"part\":[\"42\"]}> but was:<{\"part\":[42]}> testPrimitiveFieldAnnotationTakesPrecedenceOverDefault [CONTEXT] } final boolean jsonAdapterPresent = mapped != null; if (mapped == null) mapped = context.getAdapter(fieldType); final TypeAdapter<?> typeAdapter = mapped; return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) { @SuppressWarnings({\"unchecked\",\"rawtypes\"}) @Override void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException { Object fieldValue = field.get(value); [BUGGY] TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType()); [BUGGY] t.write(writer, fieldValue); } @Override void read(JsonReader reader, Object value) throws IOException, IllegalAccessException { Object fieldValue = typeAdapter.read(reader); if (fieldValue != null || !isPrimitive) { field.set(value, fieldValue); } } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] createBoundField [RETURN_TYPE] ReflectiveTypeAdapterFactory$BoundField Gson context Field field String name TypeToken<?> fieldType boolean serialize boolean deserialize [VARIABLES] Gson context String $anonymous0 alternate name serializedName JsonAdapter annotation Excluder excluder JsonWriter writer FieldNamingStrategy fieldNamingPolicy ConstructorConstructor constructorConstructor Field field boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken fieldType ObjectConstructor constructor TypeAdapter mapped t typeAdapter JsonReader reader Object fieldValue value Map boundFields ", "output": "[PATCH] TypeAdapter t = jsonAdapterPresent ? typeAdapter : new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType()); ", "bugid": "367"}, {"instruction": "The following code contains a buggy line with the following test error: gsonJsonSyntaxException: Expecting number, got: STRING testNumberAsStringDeserialization . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   }", "input": "[BUG] [BUGGY] [FE] gsonJsonSyntaxException: Expecting number, got: STRING testNumberAsStringDeserialization [CONTEXT] public Number read(JsonReader in) throws IOException { JsonToken jsonToken = in.peek(); switch (jsonToken) { case NULL: in.nextNull(); return null; case NUMBER: [BUGGY] [BUGGY] return new LazilyParsedNumber(in.nextString()); default: throw new JsonSyntaxException(\"Expecting number, got:\" + jsonToken); } } [CLASS] TypeAdapters  [METHOD] read [RETURN_TYPE] Number JsonReader in [VARIABLES] TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY ATOMIC_INTEGER_ARRAY_FACTORY ATOMIC_INTEGER_FACTORY BIT_SET_FACTORY BOOLEAN_FACTORY BYTE_FACTORY CALENDAR_FACTORY CHARACTER_FACTORY CLASS_FACTORY CURRENCY_FACTORY ENUM_FACTORY INET_ADDRESS_FACTORY INTEGER_FACTORY JSON_ELEMENT_FACTORY LOCALE_FACTORY NUMBER_FACTORY SHORT_FACTORY STRING_BUFFER_FACTORY STRING_BUILDER_FACTORY STRING_FACTORY TIMESTAMP_FACTORY URI_FACTORY URL_FACTORY UUID_FACTORY boolean TypeAdapter ATOMIC_BOOLEAN ATOMIC_INTEGER ATOMIC_INTEGER_ARRAY BIG_DECIMAL BIG_INTEGER BIT_SET BOOLEAN BOOLEAN_AS_STRING BYTE CALENDAR CHARACTER CLASS CURRENCY DOUBLE FLOAT INET_ADDRESS INTEGER JSON_ELEMENT LOCALE LONG NUMBER SHORT STRING STRING_BUFFER STRING_BUILDER URI URL UUID JsonReader in JsonToken jsonToken String DAY_OF_MONTH HOUR_OF_DAY MINUTE MONTH SECOND YEAR alternate name stringValue Map constantToName nameToConstant ", "output": "[PATCH] case STRING: ", "bugid": "368"}, {"instruction": "The following code contains a buggy line with the following test error: ArrayIndexOutOfBoundsException: -1 testSkipValue_filledJsonObject . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  jsonObject.addProperty(\"s\", \"text\"); JsonTreeReader in = new JsonTreeReader(jsonObject); in.skipValue(); assertEquals(JsonToken.END_DOCUMENT, in.peek());  }", "input": "[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException: -1 testSkipValue_filledJsonObject [CONTEXT] @Override public void skipValue() throws IOException { if (peek() == JsonToken.NAME) { nextName(); pathNames[stackSize - 2] =\"null\"; } else { popStack(); [BUGGY] [BUGGY] pathNames[stackSize - 1] =\"null\"; } pathIndices[stackSize - 1]++; } [CLASS] JsonTreeReader 1 [METHOD] skipValue [RETURN_TYPE] void [VARIABLES] boolean Reader UNREADABLE_READER Object SENTINEL_CLOSED o result int[] pathIndices String[] pathNames Object[] stack int count offset result stackSize ", "output": "[PATCH] if (stackSize > 0) { } if (stackSize > 0) { } ", "bugid": "369"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<[-]0> but was:<[]0> testNegativeZero . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: \t reader.beginArray();\t assertEquals(NUMBER, reader.peek());\t assertEquals(\"-0\", reader.nextString());  }", "input": "[BUG] [BUGGY] [FE] ComparisonFailure: expected:<[-]0> but was:<[]0> testNegativeZero [CONTEXT] value = newValue; } else if (last == NUMBER_CHAR_DECIMAL) { last = NUMBER_CHAR_FRACTION_DIGIT; } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) { last = NUMBER_CHAR_EXP_DIGIT; } } }  [BUGGY] [BUGGY] if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) { peekedLong = negative ? value : -value; pos += i; return peeked = PEEKED_LONG; } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT) { peekedNumberLength = i; return peeked = PEEKED_NUMBER; } else { return PEEKED_NONE; } [CLASS] JsonReader 1 [METHOD] peekNumber [RETURN_TYPE] int [VARIABLES] boolean fitsInLong lenient negative char c Reader in int[] pathIndices stack String keyword keywordUpper peekedString String[] pathNames long MIN_INCOMPLETE_INTEGER newValue peekedLong value int NUMBER_CHAR_DECIMAL NUMBER_CHAR_DIGIT NUMBER_CHAR_EXP_DIGIT NUMBER_CHAR_EXP_E NUMBER_CHAR_EXP_SIGN NUMBER_CHAR_FRACTION_DIGIT NUMBER_CHAR_NONE NUMBER_CHAR_SIGN PEEKED_BEGIN_ARRAY PEEKED_BEGIN_OBJECT PEEKED_BUFFERED PEEKED_DOUBLE_QUOTED PEEKED_DOUBLE_QUOTED_NAME PEEKED_END_ARRAY PEEKED_END_OBJECT PEEKED_EOF PEEKED_FALSE PEEKED_LONG PEEKED_NONE PEEKED_NULL PEEKED_NUMBER PEEKED_SINGLE_QUOTED PEEKED_SINGLE_QUOTED_NAME PEEKED_TRUE PEEKED_UNQUOTED PEEKED_UNQUOTED_NAME c i l last length limit lineNumber lineStart p peekStack peeked peekedNumberLength peeking pos result stackSize char[] NON_EXECUTE_PREFIX buffer ", "output": "[PATCH] if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) { ", "bugid": "370"}, {"instruction": "The following code contains a buggy line with the following test error: IllegalArgumentException: Numeric values must be finite, but was NaN testNonFiniteDoublesWhenLenient . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  jsonWriter.setLenient(true); jsonWriter.beginArray(); jsonWriter.value(Double.NaN); jsonWriter.value(Double.NEGATIVE_INFINITY); jsonWriter.value(Double.POSITIVE_INFINITY);", "input": "[BUG] [BUGGY] if (Double.isNaN(value) || Double.isInfinite(value)) { [FE] IllegalArgumentException: Numeric values must be finite, but was NaN testNonFiniteDoublesWhenLenient [CONTEXT] public JsonWriter value(double value) throws IOException { writeDeferredName(); [BUGGY] if (Double.isNaN(value) || Double.isInfinite(value)) { [BUGGY] throw new IllegalArgumentException(\"Numeric values must be finite, but was\" + value); } beforeValue(); out.append(Double.toString(value)); return this; } [CLASS] JsonWriter [METHOD] value [RETURN_TYPE] JsonWriter double value [VARIABLES] boolean htmlSafe lenient serializeNulls value double value int[] newStack stack String[] HTML_SAFE_REPLACEMENT_CHARS REPLACEMENT_CHARS String closeBracket deferredName indent name openBracket separator value Writer out int context empty newTop nonempty stackSize topOfStack ", "output": "[PATCH] if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) { ", "bugid": "371"}, {"instruction": "The following code contains a buggy line with the following test error: gsonJsonParseException: The date should be a string value testUnexpectedToken . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  try {   DefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter(Date.class);   adapter.fromJson(\"{}\");   fail(\"Unexpected token should fail.\"); } catch (IllegalStateException expected) { }", "input": "[BUG] [BUGGY] if (in.peek() != JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\"); [FE] gsonJsonParseException: The date should be a string value testUnexpectedToken [CONTEXT] public Date read(JsonReader in) throws IOException { [BUGGY] if (in.peek() != JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\"); [BUGGY] } Date date = deserializeToDate(in.nextString()); if (dateType == Date.class) { return date; } else if (dateType == Timestamp.class) { return new Timestamp(date.getTime()); } else if (dateType == java.sql.Date.class) { return new java.sql.Date(date.getTime()); } else { [CLASS] DefaultDateTypeAdapter [METHOD] read [RETURN_TYPE] Date JsonReader in [VARIABLES] JsonReader in Class dateType String SIMPLE_NAME dateFormatAsString datePattern boolean Date date DateFormat enUsFormat localFormat ", "output": "[PATCH] if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; ", "bugid": "372"}, {"instruction": "The following code contains a buggy line with the following test error: Exception: Unexpected exception, expected<javalangIllegalArgumentException> but was<javalangArrayIndexOutOfBoundsException> testGetStringInconsistentRecord . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void testGetStringInconsistentRecord() {  header.put(\"fourth\", Integer.valueOf(4));  recordWithHeader.get(\"fourth\"); }", "input": "[BUG] [BUGGY] [FE] Exception: Unexpected exception, expected<javalangIllegalArgumentException> but was<javalangArrayIndexOutOfBoundsException> testGetStringInconsistentRecord [CONTEXT] public String get(final String name) { if (mapping == null) { throw new IllegalStateException(\"No header mapping was specified, the record values can't be accessed by name\"); } final Integer index = mapping.get(name); [BUGGY] [BUGGY] return index != null ? values[index.intValue()] : null; } [CLASS] CSVRecord [METHOD] get [RETURN_TYPE] String String name [VARIABLES] Integer index String[] EMPTY_STRING_ARRAY values String comment name boolean Map mapping long recordNumber serialVersionUID ", "output": "[PATCH] try { } catch (ArrayIndexOutOfBoundsException e) { throw new IllegalArgumentException( String.format(\"Index for header \\'%s\\' is %d but CSVRecord only has %d values!\", name, index.intValue(), values.length)); } ", "bugid": "373"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testEscapedMySqlNullValue . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   // MySQL uses \\N to symbolize null values. We have to restore this  final Lexer lexer = getLexer(\"character\\\\NEscaped\", formatWithEscaping);  assertThat(lexer.nextToken(new Token()), hasContent(\"character\\\\NEscaped\")); }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: testEscapedMySqlNullValue [CONTEXT] case CR: case LF: case FF: case TAB: case BACKSPACE: return c; case END_OF_STREAM: throw new IOException(\"EOF whilst processing escape sequence\"); default: [BUGGY] [BUGGY] return c; } } [CLASS] Lexer [METHOD] readEscape [RETURN_TYPE] int [VARIABLES] char DISABLED commmentStart delimiter escape quoteChar ExtendedBufferedReader in CSVFormat format boolean ignoreEmptyLines ignoreSurroundingSpaces int c ", "output": "[PATCH] if (isDelimiter(c) || isEscape(c) || isQuoteChar(c) || isCommentStart(c)) { } return END_OF_STREAM; ", "bugid": "374"}, {"instruction": "The following code contains a buggy line with the following test error: null  testNoHeaderMap . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void testNoHeaderMap() throws Exception {  final CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT);  Assert.assertNull(parser.getHeaderMap()); }", "input": "[BUG] [BUGGY] return new LinkedHashMap<String, Integer>(this.headerMap); [FE] null  testNoHeaderMap [CONTEXT] public Map<String, Integer> getHeaderMap() { [BUGGY] return new LinkedHashMap<String, Integer>(this.headerMap); [BUGGY] } [CLASS] CSVParser 1 [METHOD] getHeaderMap [RETURN_TYPE] Map [VARIABLES] Lexer lexer boolean CSVFormat format List record Token reusableToken CSVRecord current Map headerMap long recordNumber ", "output": "[PATCH] return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap); ", "bugid": "375"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testNullRecordSeparatorCsv106 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   final String formatStr = format.format(\"A\", \"B\");  assertNotNull(formatStr);  assertFalse(formatStr.endsWith(\"null\")); }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError testNullRecordSeparatorCsv106 [CONTEXT] public void println() throws IOException { final String recordSeparator = format.getRecordSeparator(); [BUGGY] [BUGGY] out.append(recordSeparator); newRecord = true; } [CLASS] CSVPrinter [METHOD] println [RETURN_TYPE] void [VARIABLES] CSVFormat format boolean newRecord quote String recordSeparator Appendable out ", "output": "[PATCH] if (recordSeparator != null) { } ", "bugid": "376"}, {"instruction": "The following code contains a buggy line with the following test error: ArrayIndexOutOfBoundsException: 2 testToMapWithShortRecord . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:     final CSVParser parser =  CSVParser.parse(\"a,b\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"));    final CSVRecord shortRec = parser.iterator().next();    shortRec.toMap(); }", "input": "[BUG] [BUGGY] [FE] ArrayIndexOutOfBoundsException: 2 testToMapWithShortRecord [CONTEXT] <M extends Map<String, String>> M putIn(final M map) { for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getValue().intValue(); [BUGGY] [BUGGY] map.put(entry.getKey(), values[col]); } return map; } [CLASS] CSVRecord [METHOD] putIn [RETURN_TYPE] <M final M map [VARIABLES] Entry entry boolean String[] EMPTY_STRING_ARRAY values String comment name Map mapping M map long recordNumber serialVersionUID int col ", "output": "[PATCH] if (col < values.length) { } ", "bugid": "377"}, {"instruction": "The following code contains a buggy line with the following test error: null  testToMapWithNoHeader . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:     final CSVParser parser =  CSVParser.parse(\"a,b\", CSVFormat.newFormat(','));    final CSVRecord shortRec = parser.iterator().next();    Map<String, String> map = shortRec.toMap();    assertNotNull(\"Map is not null.\", map);    assertTrue(\"Map is empty.\", map.isEmpty());", "input": "[BUG] [BUGGY] [FE] null  testToMapWithNoHeader [CONTEXT] <M extends Map<String, String>> M putIn(final M map) { [BUGGY] [BUGGY] for (final Entry<String, Integer> entry : mapping.entrySet()) { final int col = entry.getValue().intValue(); if (col < values.length) { map.put(entry.getKey(), values[col]); } } return map; } [CLASS] CSVRecord [METHOD] putIn [RETURN_TYPE] <M final M map [VARIABLES] Entry entry boolean String[] EMPTY_STRING_ARRAY values String comment name Map mapping M map long recordNumber serialVersionUID int col ", "output": "[PATCH] if (mapping == null) { return map; } ", "bugid": "378"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<[C1,C2,C3 testHeader . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   printer.printRecord(\"a\", \"b\", \"c\");  printer.printRecord(\"x\", \"y\", \"z\");  assertEquals(\"C1,C2,C3\\r\\na,b,c\\r\\nx,y,z\\r\\n\", sw.toString());  printer.close(); }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: expected:<[C1,C2,C3 testHeader [CONTEXT] public CSVPrinter(final Appendable out, final CSVFormat format) throws IOException { Assertions.notNull(out,\"out\"); Assertions.notNull(format,\"format\"); this.out = out; this.format = format; this.format.validate();  [BUGGY] [BUGGY] } public void close() throws IOException { if (out instanceof Closeable) { ((Closeable) out).close(); } } [CLASS] ", "output": "[PATCH] if (format.getHeader() != null) { this.printRecord((Object[]) format.getHeader()); } ", "bugid": "379"}, {"instruction": "The following code contains a buggy line with the following test error: null  testHeaderMissingWithNull . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void testHeaderMissingWithNull() throws Exception {  final Reader in = new StringReader(\"a,,c,,d\\n1,2,3,4\\nx,y,z,zz\");  CSVFormat.DEFAULT.withHeader().withNullString(\"\").withIgnoreEmptyHeaders(true).parse(in).iterator(); }", "input": "[BUG] [BUGGY] final boolean emptyHeader = header.trim().isEmpty(); [FE] null  testHeaderMissingWithNull [CONTEXT] this.nextRecord(); } headerRecord = formatHeader; } if (headerRecord != null) { for (int i = 0; i < headerRecord.length; i++) { final String header = headerRecord[i]; final boolean containsHeader = hdrMap.containsKey(header); [BUGGY] final boolean emptyHeader = header.trim().isEmpty(); [BUGGY] if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) { throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\"\\\" in\" + Arrays.toString(headerRecord)); } hdrMap.put(header, Integer.valueOf(i)); } } } return hdrMap; } [CLASS] CSVParser 1 [METHOD] initializeHeader [RETURN_TYPE] Map [VARIABLES] Lexer lexer boolean containsHeader emptyHeader CSVFormat format List record Token reusableToken CSVRecord current nextRecord rec String[] formatHeader headerRecord String header Map hdrMap headerMap long recordNumber int i ", "output": "[PATCH] final boolean emptyHeader = header == null || header.trim().isEmpty(); ", "bugid": "380"}, {"instruction": "The following code contains a buggy line with the following test error: IllegalArgumentException: The header contains a duplicate name:\"\" in [A, B, C, , ] testExcelHeaderCountLessThanData . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void testExcelHeaderCountLessThanData() throws Exception {  final String code = \"A,B,C,,\\r\\na,b,c,d,e\\r\\n\";  final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL.withHeader());  try {   for (CSVRecord record : parser.getRecords()) {", "input": "[BUG] [BUGGY] public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); [FE] IllegalArgumentException: The header contains a duplicate name:\"\" in [A, B, C, , ] testExcelHeaderCountLessThanData [CONTEXT] [BUGGY] public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false); [CLASS] CSVFormat [VARIABLES] ", "output": "[PATCH] public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true); ", "bugid": "381"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<[ testEscapeNull1 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    printer.print(\"\\\\\");  }  assertEquals(\"\\\\\", sw.toString()); }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: expected:<[ testEscapeNull1 [CONTEXT]  if (newRecord) { quote = true; } } else { char c = value.charAt(pos);  [BUGGY] [BUGGY] if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) { quote = true; } else if (c <= COMMENT) {  quote = true; } else { while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { [CLASS] CSVFormat Predefined [METHOD] printAndQuote [RETURN_TYPE] void Object object CharSequence value final int offset final int len Appendable out final boolean newRecord [VARIABLES] Character c commentMarker commentStart escape escapeCharacter quoteChar quoteCharacter Appendable out CharSequence value String[] header headerComments String format nullString recordSeparator long serialVersionUID int end len offset pos start boolean allowMissingColumnNames ignoreEmptyLines ignoreHeaderCase ignoreSurroundingSpaces newRecord quote skipHeaderRecord trailingDelimiter trim QuoteMode quoteMode quoteModePolicy char c delim delimChar delimiter escape quoteChar CSVFormat DEFAULT EXCEL INFORMIX_UNLOAD INFORMIX_UNLOAD_CSV MYSQL RFC4180 TDF format other Object object Predefined Default Excel InformixUnload InformixUnloadCsv MySQL RFC4180 TDF ", "output": "[PATCH] ", "bugid": "382"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<[ testDontQuoteEuroFirstChar . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.RFC4180)) {   printer.printRecord(EURO_CH, \"Deux\");   assertEquals(EURO_CH + \",Deux\" + recordSeparator, sw.toString());  } }", "input": "[BUG] [BUGGY] if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) { quote = true; } else if (c <= COMMENT) { [FE] AssertionFailedError: expected:<[ testDontQuoteEuroFirstChar [CONTEXT] if (newRecord) { quote = true; } } else { char c = value.charAt(pos); [BUGGY] if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) { quote = true; } else if (c <= COMMENT) { [BUGGY]  quote = true; } else { while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { [CLASS] CSVFormat Predefined [METHOD] printAndQuote [RETURN_TYPE] void Object object CharSequence value final int offset final int len Appendable out final boolean newRecord [VARIABLES] Character c commentMarker commentStart escape escapeCharacter quoteChar quoteCharacter Appendable out CharSequence value String[] header headerComments String format nullString recordSeparator long serialVersionUID int end len offset pos start boolean allowMissingColumnNames autoFlush ignoreEmptyLines ignoreHeaderCase ignoreSurroundingSpaces newRecord quote skipHeaderRecord trailingDelimiter trim QuoteMode quoteMode quoteModePolicy char c delim delimChar delimiter escape quoteChar CSVFormat DEFAULT EXCEL INFORMIX_UNLOAD INFORMIX_UNLOAD_CSV MYSQL POSTGRESQL_CSV POSTGRESQL_TEXT RFC4180 TDF format other Object object Predefined Default Excel InformixUnload InformixUnloadCsv MySQL PostgreSQLCsv PostgreSQLText RFC4180 TDF ", "output": "[PATCH] if (c <= COMMENT) { ", "bugid": "383"}, {"instruction": "The following code contains a buggy line with the following test error: commonsjxpathJXPathException: Cannot compare pointers that do not belong to the same tree: '' and '$var' testUnionOfVariableAndNode . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   context.getVariables().declareVariable(\"var\", \"varValue\");  int sz = 0;  for (Iterator ptrs = context.iteratePointers(\"$var | /MAIN/A\"); ptrs.hasNext(); sz++) {   ptrs.next();  }", "input": "[BUG] [BUGGY] throw new JXPathException(\"Cannot compare pointers that do not belong to the same tree: \\'\" + p1 +\"\\' and \\'\" + p2 +\"\\'\"); [FE] commonsjxpathJXPathException: Cannot compare pointers that do not belong to the same tree: '' and '$var' testUnionOfVariableAndNode [CONTEXT] } if (p1 == null && p2 == null) { return 0; } if (p1 != null && p1.equals(p2)) { return 0; } if (depth1 == 1) { [BUGGY] throw new JXPathException(\"Cannot compare pointers that do not belong to the same tree: '\" + p1 +\"' and '\" + p2 +\"'\"); [BUGGY] } int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1); if (r != 0) { return r; } return p1.parent.compareChildNodePointers(p1, p2); } [CLASS] NodePointer [METHOD] compareNodePointers [RETURN_TYPE] int NodePointer p1 int depth1 NodePointer p2 int depth2 [VARIABLES] Locale loc locale boolean attribute reverse NamespaceResolver namespaceResolver Object bean object rootNode value String UNKNOWN_NAMESPACE id key lang name namespace nodeNS nodePrefix prefix s1 s2 testNS testPrefix value NodePointer ivp p1 p2 parent pointer pointer1 pointer2 ptr startWith valuePointer int WHOLE_COLLECTION depth1 depth2 i index r ", "output": "[PATCH] return 0; ", "bugid": "384"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Evaluating <$nan > $nan> expected:<false> but was:<true> testNan . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: Evaluating <$nan > $nan> expected:<false> but was:<true> testNan [CONTEXT] if (left instanceof Iterator && right instanceof Iterator) { return findMatch((Iterator) left, (Iterator) right); } if (left instanceof Iterator) { return containsMatch((Iterator) left, right); } if (right instanceof Iterator) { return containsMatch((Iterator) right, left); } double ld = InfoSetUtil.doubleValue(left); [BUGGY] [BUGGY] double rd = InfoSetUtil.doubleValue(right); return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1); } [CLASS] CoreOperationRelationalExpression [METHOD] compute [RETURN_TYPE] boolean Object left Object right [VARIABLES] boolean double ld rd Object left right ", "output": "[PATCH] if (Double.isNaN(ld)) { return false; } if (Double.isNaN(rd)) { return false; } ", "bugid": "385"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Evaluating </idonotexist >= 0> expected:<false> but was:<true> testEmptyNodeSetOperations . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertXPathValue(context, \"/idonotexist < 0\", Boolean.FALSE, Boolean.class);  assertXPathValue(context, \"/idonotexist > 0\", Boolean.FALSE, Boolean.class);  assertXPathValue(context, \"/idonotexist >= 0\", Boolean.FALSE, Boolean.class);  assertXPathValue(context, \"/idonotexist <= 0\", Boolean.FALSE, Boolean.class);  assertXPathValue(context, \"$array[position() < 1] = 0\", Boolean.FALSE, Boolean.class);", "input": "[BUG] [BUGGY] return compute(args[0].computeValue(context), args[1].computeValue(context)) [FE] AssertionFailedError: Evaluating </idonotexist >= 0> expected:<false> but was:<true> testEmptyNodeSetOperations [CONTEXT] public final Object computeValue(EvalContext context) { [BUGGY] return compute(args[0].computeValue(context), args[1].computeValue(context)) [BUGGY] ? Boolean.TRUE : Boolean.FALSE; } [CLASS] CoreOperationRelationalExpression [METHOD] computeValue [RETURN_TYPE] Object EvalContext context [VARIABLES] boolean EvalContext context ", "output": "[PATCH] return compute(args[0].compute(context), args[1].compute(context)) ", "bugid": "386"}, {"instruction": "The following code contains a buggy line with the following test error: commonsjxpathJXPathNotFoundException: No value for xpath: /ElementA/B:ElementB testElementDOM . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  }", "input": "[BUG] [BUGGY] return equalStrings(namespaceURI, nodeNS); [FE] commonsjxpathJXPathNotFoundException: No value for xpath: /ElementA/B:ElementB testElementDOM [CONTEXT] if (wildcard || testName.getName() .equals(DOMNodePointer.getLocalName(node))) { String nodeNS = DOMNodePointer.getNamespaceURI(node); [BUGGY] return equalStrings(namespaceURI, nodeNS); [BUGGY] } [CLASS] DOMNodePointer [METHOD] testNode [RETURN_TYPE] boolean Node node NodeTest test [VARIABLES] boolean wildcard NodeNameTest nodeNameTest QName testName Node node String XMLNS_NAMESPACE_URI XML_NAMESPACE_URI defaultNamespace id namespaceURI nodeNS nodePI testPI testPrefix Map namespaces long serialVersionUID NodeTest test int nodeType ", "output": "[PATCH] return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node)); ", "bugid": "387"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Evaluating <map/b != map/a> expected:<true> but was:<false> testMapValueEquality . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] return ValueUtils.getLength(getBaseValue()); [FE] AssertionFailedError: Evaluating <map/b != map/a> expected:<true> but was:<false> testMapValueEquality [CONTEXT] public int getLength() { [BUGGY] return ValueUtils.getLength(getBaseValue()); [BUGGY] } [CLASS] PropertyPointer [METHOD] getLength [RETURN_TYPE] int [VARIABLES] Object UNINITIALIZED bean value int UNSPECIFIED_PROPERTY index propertyIndex boolean ", "output": "[PATCH] Object baseValue = getBaseValue(); return baseValue == null ? 1 : ValueUtils.getLength(baseValue); ", "bugid": "388"}, {"instruction": "The following code contains a buggy line with the following test error: null  testXYAutoRange1 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   XYSeriesCollection dataset = new XYSeriesCollection();  dataset.addSeries(series);  JFreeChart chart = ChartFactory.createScatterPlot(   \"Test\",   \"X\",", "input": "[BUG] [BUGGY] Collection c = r.getAnnotations(); Iterator i = c.iterator(); [FE] null  testXYAutoRange1 [CONTEXT] else { if (r != null) { result = Range.combine(result, r.findRangeBounds(d)); } else { result = Range.combine(result, DatasetUtilities.findRangeBounds(d)); } } [BUGGY] Collection c = r.getAnnotations(); Iterator i = c.iterator(); [BUGGY] while (i.hasNext()) { XYAnnotation a = (XYAnnotation) i.next(); if (a instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(a); } } } } [CLASS] XYPlot [METHOD] getDataRange [RETURN_TYPE] Range ValueAxis axis [VARIABLES] PlotOrientation orient orientation long serialVersionUID Paint[] quadrantPaint Point2D anchor origin quadrantOrigin ValueAxis axis Iterator i it iterator List annotations axisIndices includedAnnotations indices mappedAxes mappedDatasets result ticks AxisSpace fixedDomainAxisSpace fixedRangeAxisSpace space XYItemRenderer r Stroke DEFAULT_CROSSHAIR_STROKE DEFAULT_GRIDLINE_STROKE domainCrosshairStroke domainGridlineStroke domainMinorGridlineStroke domainZeroBaselineStroke gridStroke rangeCrosshairStroke rangeGridlineStroke rangeMinorGridlineStroke rangeZeroBaselineStroke stroke XYAnnotation a annotation double current cursor domainCrosshairValue end hvalue previous rangeCrosshairValue value vvalue x xmax xmin xx xxmax xxmin y ymax ymin yy yymax yymin LegendItemCollection fixedLegendItems XYAnnotationBoundsInfo xyabi Paint DEFAULT_CROSSHAIR_PAINT DEFAULT_GRIDLINE_PAINT bandPaint domainCrosshairPaint domainGridlinePaint domainMinorGridlinePaint domainTickBandPaint domainZeroBaselinePaint gridPaint paint rangeCrosshairPaint rangeGridlinePaint rangeMinorGridlinePaint rangeTickBandPaint rangeZeroBaselinePaint Range result int axisIndex count domainIndex firstItem i index item lastItem pass passCount rangeIndex rendererCount result series seriesCount upper weight x xAxisIndex y yAxisIndex DatasetRenderingOrder datasetRenderingOrder order boolean DEFAULT_CROSSHAIR_VISIBLE b1 b2 domainCrosshairLockedOnData domainCrosshairVisible domainGridlinesVisible domainMinorGridlinesVisible domainPannable domainZeroBaselineVisible fillBand foundData isDomainAxis notify paintLine rangeCrosshairLockedOnData rangeCrosshairVisible rangeGridlinesVisible rangeMinorGridlinesVisible rangePannable rangeZeroBaselineVisible removed selected somethingToDraw visible RectangleInsets axisOffset insets offset ObjectList datasets domainAxes domainAxisLocations rangeAxes rangeAxisLocations renderers Collection c ResourceBundle localizationResources XYDataset d SeriesRenderingOrder order seriesOrder seriesRenderingOrder Map axisStateMap backgroundDomainMarkers backgroundRangeMarkers datasetToDomainAxesMap datasetToRangeAxesMap foregroundDomainMarkers foregroundRangeMarkers ", "output": "[PATCH] if (r != null) { Collection c = r.getAnnotations(); Iterator i = c.iterator(); }", "bugid": "391"}, {"instruction": "The following code contains a buggy line with the following test error: IndexOutOfBoundsException: Index: -1, Size: 1 testBug1955483 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   XYSeries series = new XYSeries(\"Series\", true, true);  series.addOrUpdate(1.0, 1.0);  series.addOrUpdate(1.0, 2.0);  assertEquals(new Double(1.0), series.getY(0));  assertEquals(new Double(2.0), series.getY(1));", "input": "[BUG] [BUGGY] [FE] IndexOutOfBoundsException: Index: -1, Size: 1 testBug1955483 [CONTEXT] public XYDataItem addOrUpdate(Number x, Number y) { if (x == null) { throw new IllegalArgumentException(\"Null 'x' argument.\"); } [BUGGY] [BUGGY] XYDataItem overwritten = null; int index = indexOf(x); if (index >= 0 && !this.allowDuplicateXValues) { XYDataItem existing = (XYDataItem) this.data.get(index); try { overwritten = (XYDataItem) existing.clone(); } catch (CloneNotSupportedException e) { throw new SeriesException(\"Couldn't clone XYDataItem!\"); [CLASS] XYSeries [METHOD] addOrUpdate [RETURN_TYPE] XYDataItem Number x Number y [VARIABLES] boolean allowDuplicateXValues autoSort dataRemoved notify Number x y List data long serialVersionUID int end i index maximum maximumItemCount size start XYDataItem existing overwritten CloneNotSupportedException e ", "output": "[PATCH] if (this.allowDuplicateXValues) { add(x, y); return null; } ", "bugid": "393"}, {"instruction": "The following code contains a buggy line with the following test error: IndexOutOfBoundsException: Index: -1, Size: 1 testBug1955483 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   XYSeries series = new XYSeries(\"Series\", true, true);  series.addOrUpdate(1.0, 1.0);  series.addOrUpdate(1.0, 2.0);  assertEquals(new Double(1.0), series.getY(0));  assertEquals(new Double(2.0), series.getY(1));", "input": "[BUG] [BUGGY] if (index >= 0 && !this.allowDuplicateXValues) { [FE] IndexOutOfBoundsException: Index: -1, Size: 1 testBug1955483 [CONTEXT] public XYDataItem addOrUpdate(Number x, Number y) { if (x == null) { throw new IllegalArgumentException(\"Null 'x' argument.\"); } XYDataItem overwritten = null; int index = indexOf(x); [BUGGY] if (index >= 0 && !this.allowDuplicateXValues) { [BUGGY] XYDataItem existing = (XYDataItem) this.data.get(index); try { overwritten = (XYDataItem) existing.clone(); } catch (CloneNotSupportedException e) { throw new SeriesException(\"Couldn't clone XYDataItem!\"); } existing.setY(y); } else { [CLASS] XYSeries [METHOD] addOrUpdate [RETURN_TYPE] XYDataItem Number x Number y [VARIABLES] boolean allowDuplicateXValues autoSort dataRemoved notify Number x y List data long serialVersionUID int end i index maximum maximumItemCount size start XYDataItem existing overwritten CloneNotSupportedException e ", "output": "[PATCH] if (index >= 0) { ", "bugid": "394"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testDrawWithNullDataset . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    success = false;  }  assertTrue(success); }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError testDrawWithNullDataset [CONTEXT] public double getMaximumExplodePercent() { [BUGGY] [BUGGY] double result = 0.0; Iterator iterator = this.dataset.getKeys().iterator(); while (iterator.hasNext()) { Comparable key = (Comparable) iterator.next(); Number explode = (Number) this.explodePercentages.get(key); if (explode != null) { result = Math.max(result, explode.doubleValue()); } } return result; } [CLASS] PiePlot [METHOD] getMaximumExplodePercent [RETURN_TYPE] double [VARIABLES] PieURLGenerator legendLabelURLGenerator urlGenerator Stroke DEFAULT_LABEL_OUTLINE_STROKE baseSectionOutlineStroke labelLinkStroke labelOutlineStroke result stroke Comparable key PieSectionLabelGenerator labelGenerator legendLabelGenerator legendLabelToolTipGenerator Shape legendItemShape double DEFAULT_INTERIOR_GAP DEFAULT_MINIMUM_ARC_ANGLE_TO_DRAW DEFAULT_START_ANGLE MAX_INTERIOR_GAP angle interiorGap labelGap labelLinkMargin maximumLabelWidth minimumArcAngleToDraw offset percent result shadowXOffset shadowYOffset startAngle AbstractPieLabelDistributor labelDistributor Paint DEFAULT_LABEL_BACKGROUND_PAINT DEFAULT_LABEL_OUTLINE_PAINT DEFAULT_LABEL_PAINT DEFAULT_LABEL_SHADOW_PAINT baseSectionOutlinePaint baseSectionPaint labelBackgroundPaint labelLinkPaint labelOutlinePaint labelPaint labelShadowPaint paint result shadowPaint Rotation direction long serialVersionUID Font DEFAULT_LABEL_FONT labelFont int index pieIndex section boolean DEBUG_DRAW_INTERIOR DEBUG_DRAW_LINK_AREA DEBUG_DRAW_PIE_AREA autoPopulate circular flag ignoreNullValues ignoreZeroValues labelLinksVisible notify sectionOutlinesVisible simpleLabels visible PieToolTipGenerator toolTipGenerator Number explode PieDataset dataset existing PaintMap sectionOutlinePaintMap sectionPaintMap Iterator iterator RectangleInsets labelPadding simpleLabelOffset ResourceBundle localizationResources Map explodePercentages StrokeMap sectionOutlineStrokeMap ", "output": "[PATCH] if (this.dataset == null) { return 0.0; } ", "bugid": "395"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testDrawWithNullDataset . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    success = false;  }  assertTrue(success); }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError testDrawWithNullDataset [CONTEXT] public PiePlotState initialise(Graphics2D g2, Rectangle2D plotArea, PiePlot plot, Integer index, PlotRenderingInfo info) { PiePlotState state = new PiePlotState(info); state.setPassesRequired(2); [BUGGY] state.setTotal(DatasetUtilities.calculatePieDatasetTotal( plot.getDataset())); [BUGGY] state.setLatestAngle(plot.getStartAngle()); return state; } [CLASS] PiePlot [METHOD] initialise [RETURN_TYPE] PiePlotState Graphics2D g2 Rectangle2D plotArea PiePlot plot Integer index PlotRenderingInfo info [VARIABLES] PieSectionLabelGenerator generator labelGenerator legendLabelGenerator legendLabelToolTipGenerator Shape legendItemShape shape long serialVersionUID Font DEFAULT_LABEL_FONT font labelFont PiePlotState state StrokeMap sectionOutlineStrokeMap PieURLGenerator generator legendLabelURLGenerator urlGenerator Stroke DEFAULT_LABEL_OUTLINE_STROKE baseSectionOutlineStroke labelLinkStroke labelOutlineStroke result stroke PlotRenderingInfo info double DEFAULT_INTERIOR_GAP DEFAULT_MINIMUM_ARC_ANGLE_TO_DRAW DEFAULT_START_ANGLE MAX_INTERIOR_GAP angle gap interiorGap labelGap labelLinkMargin margin maximumLabelWidth minimumArcAngleToDraw offset percent result shadowXOffset shadowYOffset startAngle width AbstractPieLabelDistributor distributor labelDistributor Rectangle2D plotArea Paint DEFAULT_LABEL_BACKGROUND_PAINT DEFAULT_LABEL_OUTLINE_PAINT DEFAULT_LABEL_PAINT DEFAULT_LABEL_SHADOW_PAINT baseSectionOutlinePaint baseSectionPaint labelBackgroundPaint labelLinkPaint labelOutlinePaint labelPaint labelShadowPaint paint result shadowPaint Rotation direction int index pieIndex section Graphics2D g2 Integer index boolean DEBUG_DRAW_INTERIOR DEBUG_DRAW_LINK_AREA DEBUG_DRAW_PIE_AREA autoPopulate circular flag ignoreNullValues ignoreZeroValues labelLinksVisible notify sectionOutlinesVisible simple simpleLabels visible PieToolTipGenerator generator toolTipGenerator PieDataset dataset existing PaintMap sectionOutlinePaintMap sectionPaintMap RectangleInsets labelPadding offset padding simpleLabelOffset PiePlot plot ResourceBundle localizationResources Map explodePercentages ", "output": "[PATCH] if (this.dataset != null) { state.setTotal(DatasetUtilities.calculatePieDatasetTotal( plot.getDataset())); } ", "bugid": "396"}, {"instruction": "The following code contains a buggy line with the following test error: null  testGetCategoryIndex . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  \t  = new DefaultIntervalCategoryDataset(new double[0][0],  \t  \t\tnew double[0][0]); \tassertEquals(-1, empty.getCategoryIndex(\"ABC\")); }", "input": "[BUG] [BUGGY] this.seriesKeys = null; this.categoryKeys = null; [FE] null  testGetCategoryIndex [CONTEXT] this.categoryKeys = categoryKeys; } else { String prefix = resources.getString(\"categories.default-prefix\") +\"\"; this.categoryKeys = generateKeys(categoryCount, prefix); } } else { [BUGGY] this.seriesKeys = null; this.categoryKeys = null; [BUGGY] } [CLASS] DefaultIntervalCategoryDataset [METHOD] <init> [RETURN_TYPE] Number[][]) Comparable[] seriesKeys Comparable[] categoryKeys Number[][] starts Number[][] ends [VARIABLES] Number[][] endData ends startData starts ResourceBundle resources String baseName errMsg prefix boolean int categoryCount seriesCount Comparable[] categoryKeys seriesKeys ", "output": "[PATCH] this.seriesKeys = new Comparable[0]; this.categoryKeys = new Comparable[0]; ", "bugid": "397"}, {"instruction": "The following code contains a buggy line with the following test error: null  testGetCategoryIndex . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  \t  = new DefaultIntervalCategoryDataset(new double[0][0],  \t  \t\tnew double[0][0]); \tassertEquals(-1, empty.getCategoryIndex(\"ABC\")); }", "input": "[BUG] [BUGGY] if (categoryKeys.length != this.startData[0].length) { [FE] null  testGetCategoryIndex [CONTEXT] public void setCategoryKeys(Comparable[] categoryKeys) { if (categoryKeys == null) { throw new IllegalArgumentException(\"Null 'categoryKeys' argument.\"); } [BUGGY] if (categoryKeys.length != this.startData[0].length) { [BUGGY] throw new IllegalArgumentException(\"The number of categories does not match the data.\"); } for (int i = 0; i < categoryKeys.length; i++) { if (categoryKeys[i] == null) { throw new IllegalArgumentException(\"DefaultIntervalCategoryDataset.setCategoryKeys():\" +\"null category not permitted.\"); } } [CLASS] DefaultIntervalCategoryDataset [METHOD] setCategoryKeys [RETURN_TYPE] void Comparable[] categoryKeys [VARIABLES] Number[][] endData ends startData starts boolean int i Comparable[] categoryKeys seriesKeys ", "output": "[PATCH] if (categoryKeys.length != getCategoryCount()) { ", "bugid": "398"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testGetRangeAxisIndex . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    pass = true;  }  assertTrue(pass); }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError testGetRangeAxisIndex [CONTEXT] public int getDomainAxisIndex(CategoryAxis axis) { [BUGGY] [BUGGY] return this.domainAxes.indexOf(axis); } [CLASS] CategoryPlot [METHOD] getDomainAxisIndex [RETURN_TYPE] int CategoryAxis axis [VARIABLES] Stroke DEFAULT_CROSSHAIR_STROKE DEFAULT_GRIDLINE_STROKE domainGridlineStroke rangeCrosshairStroke rangeGridlineStroke PlotOrientation orientation double anchorValue rangeCrosshairValue LegendItemCollection fixedLegendItems SortOrder columnRenderingOrder rowRenderingOrder Paint DEFAULT_CROSSHAIR_PAINT DEFAULT_GRIDLINE_PAINT domainGridlinePaint rangeCrosshairPaint rangeGridlinePaint long serialVersionUID Font DEFAULT_VALUE_LABEL_FONT int i index weight DatasetRenderingOrder renderingOrder CategoryAnchor domainGridlinePosition boolean DEFAULT_CROSSHAIR_VISIBLE DEFAULT_DOMAIN_GRIDLINES_VISIBLE DEFAULT_RANGE_GRIDLINES_VISIBLE domainGridlinesVisible drawSharedDomainAxis notify rangeCrosshairLockedOnData rangeCrosshairVisible rangeGridlinesVisible CategoryAxis axis RectangleInsets axisOffset offset ObjectList datasetToDomainAxisMap datasetToRangeAxisMap datasets domainAxes domainAxisLocations rangeAxes rangeAxisLocations renderers ResourceBundle localizationResources List annotations AxisSpace fixedDomainAxisSpace fixedRangeAxisSpace Map backgroundDomainMarkers backgroundRangeMarkers foregroundDomainMarkers foregroundRangeMarkers ", "output": "[PATCH] if (axis == null) { throw new IllegalArgumentException(\"Null 'axis' argument.\"); } ", "bugid": "399"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testGetRangeAxisIndex . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    pass = true;  }  assertTrue(pass); }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError testGetRangeAxisIndex [CONTEXT] public int getRangeAxisIndex(ValueAxis axis) { [BUGGY] [BUGGY] int result = this.rangeAxes.indexOf(axis); if (result < 0) { Plot parent = getParent(); if (parent instanceof CategoryPlot) { CategoryPlot p = (CategoryPlot) parent; result = p.getRangeAxisIndex(axis); } } return result; } [CLASS] CategoryPlot [METHOD] getRangeAxisIndex [RETURN_TYPE] int ValueAxis axis [VARIABLES] Stroke DEFAULT_CROSSHAIR_STROKE DEFAULT_GRIDLINE_STROKE domainGridlineStroke rangeCrosshairStroke rangeGridlineStroke PlotOrientation orientation double anchorValue rangeCrosshairValue LegendItemCollection fixedLegendItems Plot parent SortOrder columnRenderingOrder rowRenderingOrder Paint DEFAULT_CROSSHAIR_PAINT DEFAULT_GRIDLINE_PAINT domainGridlinePaint rangeCrosshairPaint rangeGridlinePaint long serialVersionUID Font DEFAULT_VALUE_LABEL_FONT int i index result weight CategoryPlot p DatasetRenderingOrder renderingOrder CategoryAnchor domainGridlinePosition boolean DEFAULT_CROSSHAIR_VISIBLE DEFAULT_DOMAIN_GRIDLINES_VISIBLE DEFAULT_RANGE_GRIDLINES_VISIBLE domainGridlinesVisible drawSharedDomainAxis notify rangeCrosshairLockedOnData rangeCrosshairVisible rangeGridlinesVisible ValueAxis axis RectangleInsets axisOffset offset ObjectList datasetToDomainAxisMap datasetToRangeAxisMap datasets domainAxes domainAxisLocations rangeAxes rangeAxisLocations renderers ResourceBundle localizationResources List annotations AxisSpace fixedDomainAxisSpace fixedRangeAxisSpace Map backgroundDomainMarkers backgroundRangeMarkers foregroundDomainMarkers foregroundRangeMarkers ", "output": "[PATCH] if (axis == null) { throw new IllegalArgumentException(\"Null 'axis' argument.\"); } ", "bugid": "400"}, {"instruction": "The following code contains a buggy line with the following test error: null  testRemoveRangeMarker . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void testRemoveRangeMarker() { \tCategoryPlot plot = new CategoryPlot(); \tassertFalse(plot.removeRangeMarker(new ValueMarker(0.5))); }", "input": "[BUG] [BUGGY] [FE] null  testRemoveRangeMarker [CONTEXT] boolean notify) { ArrayList markers; if (layer == Layer.FOREGROUND) { markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer( index)); } else { markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } [BUGGY] [BUGGY] boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); } return removed; } [CLASS] CategoryPlot [METHOD] removeDomainMarker [RETURN_TYPE] boolean int index Marker marker Layer layer boolean notify [VARIABLES] Stroke DEFAULT_CROSSHAIR_STROKE DEFAULT_GRIDLINE_STROKE domainGridlineStroke rangeCrosshairStroke rangeGridlineStroke stroke PlotOrientation orientation double anchorValue java2D percent range rangeCrosshairValue scaledRange value LegendItemCollection fixedLegendItems items result ArrayList markers SortOrder columnRenderingOrder order rowRenderingOrder Paint DEFAULT_CROSSHAIR_PAINT DEFAULT_GRIDLINE_PAINT domainGridlinePaint paint rangeCrosshairPaint rangeGridlinePaint Marker marker Layer layer long serialVersionUID Font DEFAULT_VALUE_LABEL_FONT int axisIndex count datasetIndex i index result seriesCount weight x y DatasetRenderingOrder order renderingOrder CategoryAnchor domainGridlinePosition position boolean DEFAULT_CROSSHAIR_VISIBLE DEFAULT_DOMAIN_GRIDLINES_VISIBLE DEFAULT_RANGE_GRIDLINES_VISIBLE domainGridlinesVisible drawSharedDomainAxis notify rangeCrosshairLockedOnData rangeCrosshairVisible rangeGridlinesVisible removed visible RectangleInsets axisOffset offset ObjectList datasetToDomainAxisMap datasetToRangeAxisMap datasets domainAxes domainAxisLocations rangeAxes rangeAxisLocations renderers ResourceBundle localizationResources List annotations AxisSpace fixedDomainAxisSpace fixedRangeAxisSpace Map backgroundDomainMarkers backgroundRangeMarkers foregroundDomainMarkers foregroundRangeMarkers ", "output": "[PATCH] if (markers == null) { return false; } ", "bugid": "401"}, {"instruction": "The following code contains a buggy line with the following test error: null  testRemoveRangeMarker . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void testRemoveRangeMarker() { \tCategoryPlot plot = new CategoryPlot(); \tassertFalse(plot.removeRangeMarker(new ValueMarker(0.5))); }", "input": "[BUG] [BUGGY] [FE] null  testRemoveRangeMarker [CONTEXT] } ArrayList markers; if (layer == Layer.FOREGROUND) { markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer( index)); } else { markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } [BUGGY] [BUGGY] boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); } return removed; } [CLASS] CategoryPlot [METHOD] removeRangeMarker [RETURN_TYPE] boolean int index Marker marker Layer layer boolean notify [VARIABLES] Stroke DEFAULT_CROSSHAIR_STROKE DEFAULT_GRIDLINE_STROKE domainGridlineStroke rangeCrosshairStroke rangeGridlineStroke stroke PlotOrientation orientation double anchorValue java2D percent range rangeCrosshairValue scaledRange value LegendItemCollection fixedLegendItems items result ArrayList markers SortOrder columnRenderingOrder order rowRenderingOrder Paint DEFAULT_CROSSHAIR_PAINT DEFAULT_GRIDLINE_PAINT domainGridlinePaint paint rangeCrosshairPaint rangeGridlinePaint Marker marker Layer layer long serialVersionUID Font DEFAULT_VALUE_LABEL_FONT int axisIndex count datasetIndex i index result seriesCount weight x y DatasetRenderingOrder order renderingOrder CategoryAnchor domainGridlinePosition position boolean DEFAULT_CROSSHAIR_VISIBLE DEFAULT_DOMAIN_GRIDLINES_VISIBLE DEFAULT_RANGE_GRIDLINES_VISIBLE domainGridlinesVisible drawSharedDomainAxis notify rangeCrosshairLockedOnData rangeCrosshairVisible rangeGridlinesVisible removed visible RectangleInsets axisOffset offset ObjectList datasetToDomainAxisMap datasetToRangeAxisMap datasets domainAxes domainAxisLocations rangeAxes rangeAxisLocations renderers ResourceBundle localizationResources List annotations AxisSpace fixedDomainAxisSpace fixedRangeAxisSpace Map backgroundDomainMarkers backgroundRangeMarkers foregroundDomainMarkers foregroundRangeMarkers ", "output": "[PATCH] if (markers == null) { return false; } ", "bugid": "402"}, {"instruction": "The following code contains a buggy line with the following test error: null  testRemoveRangeMarker . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void testRemoveRangeMarker() { \tCategoryPlot plot = new CategoryPlot(); \tassertFalse(plot.removeRangeMarker(new ValueMarker(0.5))); }", "input": "[BUG] [BUGGY] [FE] null  testRemoveRangeMarker [CONTEXT] boolean notify) { ArrayList markers; if (layer == Layer.FOREGROUND) { markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer( index)); } else { markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } [BUGGY] [BUGGY] boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); } return removed; } [CLASS] XYPlot [METHOD] removeDomainMarker [RETURN_TYPE] boolean int index Marker marker Layer layer boolean notify [VARIABLES] Stroke DEFAULT_CROSSHAIR_STROKE DEFAULT_GRIDLINE_STROKE domainCrosshairStroke domainGridlineStroke domainZeroBaselineStroke rangeCrosshairStroke rangeGridlineStroke rangeZeroBaselineStroke stroke PlotOrientation orientation double domainCrosshairValue rangeCrosshairValue LegendItemCollection fixedLegendItems ArrayList markers Paint DEFAULT_CROSSHAIR_PAINT DEFAULT_GRIDLINE_PAINT domainCrosshairPaint domainGridlinePaint domainTickBandPaint domainZeroBaselinePaint paint rangeCrosshairPaint rangeGridlinePaint rangeTickBandPaint rangeZeroBaselinePaint Marker marker Layer layer long serialVersionUID int axisIndex i index result weight DatasetRenderingOrder datasetRenderingOrder order boolean DEFAULT_CROSSHAIR_VISIBLE domainCrosshairLockedOnData domainCrosshairVisible domainGridlinesVisible domainZeroBaselineVisible notify rangeCrosshairLockedOnData rangeCrosshairVisible rangeGridlinesVisible rangeZeroBaselineVisible removed visible Paint[] quadrantPaint Point2D origin quadrantOrigin RectangleInsets axisOffset offset ObjectList datasets domainAxes domainAxisLocations rangeAxes rangeAxisLocations renderers ResourceBundle localizationResources List annotations AxisSpace fixedDomainAxisSpace fixedRangeAxisSpace SeriesRenderingOrder order seriesRenderingOrder Map backgroundDomainMarkers backgroundRangeMarkers datasetToDomainAxisMap datasetToRangeAxisMap foregroundDomainMarkers foregroundRangeMarkers ", "output": "[PATCH] if (markers == null) { return false; } ", "bugid": "403"}, {"instruction": "The following code contains a buggy line with the following test error: null  testRemoveRangeMarker . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void testRemoveRangeMarker() { \tCategoryPlot plot = new CategoryPlot(); \tassertFalse(plot.removeRangeMarker(new ValueMarker(0.5))); }", "input": "[BUG] [BUGGY] [FE] null  testRemoveRangeMarker [CONTEXT] } ArrayList markers; if (layer == Layer.FOREGROUND) { markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer( index)); } else { markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); } [BUGGY] [BUGGY] boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); } return removed; } [CLASS] XYPlot [METHOD] removeRangeMarker [RETURN_TYPE] boolean int index Marker marker Layer layer boolean notify [VARIABLES] Stroke DEFAULT_CROSSHAIR_STROKE DEFAULT_GRIDLINE_STROKE domainCrosshairStroke domainGridlineStroke domainZeroBaselineStroke rangeCrosshairStroke rangeGridlineStroke rangeZeroBaselineStroke stroke PlotOrientation orientation double domainCrosshairValue rangeCrosshairValue LegendItemCollection fixedLegendItems ArrayList markers Paint DEFAULT_CROSSHAIR_PAINT DEFAULT_GRIDLINE_PAINT domainCrosshairPaint domainGridlinePaint domainTickBandPaint domainZeroBaselinePaint paint rangeCrosshairPaint rangeGridlinePaint rangeTickBandPaint rangeZeroBaselinePaint Marker marker Layer layer long serialVersionUID int axisIndex i index result weight DatasetRenderingOrder datasetRenderingOrder order boolean DEFAULT_CROSSHAIR_VISIBLE domainCrosshairLockedOnData domainCrosshairVisible domainGridlinesVisible domainZeroBaselineVisible notify rangeCrosshairLockedOnData rangeCrosshairVisible rangeGridlinesVisible rangeZeroBaselineVisible removed visible Paint[] quadrantPaint Point2D origin quadrantOrigin RectangleInsets axisOffset offset ObjectList datasets domainAxes domainAxisLocations rangeAxes rangeAxisLocations renderers ResourceBundle localizationResources List annotations AxisSpace fixedDomainAxisSpace fixedRangeAxisSpace SeriesRenderingOrder order seriesRenderingOrder Map backgroundDomainMarkers backgroundRangeMarkers datasetToDomainAxisMap datasetToRangeAxisMap foregroundDomainMarkers foregroundRangeMarkers ", "output": "[PATCH] if (markers == null) { return false; } ", "bugid": "404"}, {"instruction": "The following code contains a buggy line with the following test error: commonsmath3fractionFractionConversionException: illegal state: Overflow trying to convert 05 to fraction (2,499,999,794/4,999,999,587) testDigitLimitConstructor . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:     // MATH-996  assertFraction(1, 2, new BigFraction(0.5000000001, 10)); }", "input": "[BUG] [BUGGY] [FE] commonsmath3fractionFractionConversionException: illegal state: Overflow trying to convert 05 to fraction (2,499,999,794/4,999,999,587) testDigitLimitConstructor [CONTEXT] boolean stop = false; do { ++n; final double r1 = 1.0 / (r0 - a0); final long a1 = (long) FastMath.floor(r1); p2 = (a1 * p1) + p0; q2 = (a1 * q1) + q0; if ((p2 > overflow) || (q2 > overflow)) {  [BUGGY] [BUGGY] throw new FractionConversionException(value, p2, q2); } final double convergent = (double) p2 / (double) q2; if ((n < maxIterations) && (FastMath.abs(convergent - value) > epsilon) && (q2 < maxDenominator)) { p0 = p1; p1 = p2; q0 = q1; q1 = q2; [CLASS] BigFraction [METHOD] <init> [RETURN_TYPE] BigFraction(double,double,int,int) final double value final double epsilon final int maxDenominator int maxIterations [VARIABLES] BigInteger ONE_HUNDRED den denominator gcd num numerator boolean stop BigFraction FOUR_FIFTHS MINUS_ONE ONE ONE_FIFTH ONE_HALF ONE_QUARTER ONE_THIRD THREE_FIFTHS THREE_QUARTERS TWO TWO_FIFTHS TWO_QUARTERS TWO_THIRDS ZERO long a0 a1 bits exponent m overflow p0 p1 p2 q0 q1 q2 serialVersionUID sign double convergent epsilon r0 r1 value int maxDenominator maxIterations n ", "output": "[PATCH] if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) { break; } ", "bugid": "405"}, {"instruction": "The following code contains a buggy line with the following test error: commonsmath3fractionFractionConversionException: illegal state: Overflow trying to convert 05 to fraction (2,499,999,794/4,999,999,587) testDigitLimitConstructor . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:     // MATH-996  assertFraction(1, 2, new BigFraction(0.5000000001, 10)); }", "input": "[BUG] [BUGGY] [FE] commonsmath3fractionFractionConversionException: illegal state: Overflow trying to convert 05 to fraction (2,499,999,794/4,999,999,587) testDigitLimitConstructor [CONTEXT] do { ++n; double r1 = 1.0 / (r0 - a0); long a1 = (long)FastMath.floor(r1); p2 = (a1 * p1) + p0; q2 = (a1 * q1) + q0; if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {  [BUGGY] [BUGGY] throw new FractionConversionException(value, p2, q2); } double convergent = (double)p2 / (double)q2; if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) { p0 = p1; p1 = p2; q0 = q1; q1 = q2; a0 = a1; r0 = r1; [CLASS] Fraction [METHOD] <init> [RETURN_TYPE] Fraction(double,double,int,int) double value double epsilon int maxDenominator int maxIterations [VARIABLES] Fraction FOUR_FIFTHS MINUS_ONE ONE ONE_FIFTH ONE_HALF ONE_QUARTER ONE_THIRD THREE_FIFTHS THREE_QUARTERS TWO TWO_FIFTHS TWO_QUARTERS TWO_THIRDS ZERO boolean stop double DEFAULT_EPSILON convergent epsilon r0 r1 value long a0 a1 overflow p0 p1 p2 q0 q1 q2 serialVersionUID int denominator maxDenominator maxIterations n numerator ", "output": "[PATCH] if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) { break; } ", "bugid": "406"}, {"instruction": "The following code contains a buggy line with the following test error: null  testIntersectionNotIntersecting . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(1.5, 1, 1));  SubLine sub2 = new SubLine(new Vector3D(2, 3, 0), new Vector3D(2, 3, 0.5));  Assert.assertNull(sub1.intersection(sub2, true));  Assert.assertNull(sub1.intersection(sub2, false)); }", "input": "[BUG] [BUGGY] [FE] null  testIntersectionNotIntersecting [CONTEXT] public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) { Vector3D v1D = line.intersection(subLine.line); Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D)); [BUGGY] [BUGGY] Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D)); if (includeEndPoints) { return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null; } else { return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null; } } [CLASS] SubLine [METHOD] intersection [RETURN_TYPE] Vector3D SubLine subLine final boolean includeEndPoints [VARIABLES] Line line SubLine subLine IntervalsSet remainingRegion boolean includeEndPoints Vector3D v1D Location loc1 loc2 ", "output": "[PATCH] if (v2D == null) { return null; } ", "bugid": "407"}, {"instruction": "The following code contains a buggy line with the following test error: null  testIntersectionNotIntersecting . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(1.5, 1, 1));  SubLine sub2 = new SubLine(new Vector3D(2, 3, 0), new Vector3D(2, 3, 0.5));  Assert.assertNull(sub1.intersection(sub2, true));  Assert.assertNull(sub1.intersection(sub2, false)); }", "input": "[BUG] [BUGGY] [FE] null  testIntersectionNotIntersecting [CONTEXT] public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) { Line line1 = (Line) getHyperplane(); Line line2 = (Line) subLine.getHyperplane(); Vector2D v2D = line1.intersection(line2); [BUGGY] [BUGGY] Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D)); Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D)); if (includeEndPoints) { return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null; } else { return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null; [CLASS] SubLine [METHOD] intersection [RETURN_TYPE] Vector2D SubLine subLine final boolean includeEndPoints [VARIABLES] Line line1 line2 SubLine subLine boolean includeEndPoints Vector2D v2D Location loc1 loc2 ", "output": "[PATCH] if (v2D == null) { return null; } ", "bugid": "408"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<-10> but was:<10> testMath904 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   final double x = -1;  final double y = (5 + 1e-15) * 1e15;  Assert.assertEquals(Math.pow(x, y),   FastMath.pow(x, y), 0);  Assert.assertEquals(Math.pow(x, -y),", "input": "[BUG] [BUGGY] if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) { [FE] AssertionFailedError: expected:<-10> but was:<10> testMath904 [CONTEXT] if (x * x < 1.0) { return Double.POSITIVE_INFINITY; } else { return 0.0; } } if (x < 0) { [BUGGY] if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) { [BUGGY] return pow(-x, y); } if (y == (long) y) { return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y); } else { return Double.NaN; } } [CLASS] FastMath ExpIntTable ExpFracTable lnMant CodyWaite [METHOD] pow [RETURN_TYPE] double double x double y [VARIABLES] boolean RECOMPUTE_TABLES_AT_RUNTIME negate negative double[] CBRTTWO COSINE_TABLE_A COSINE_TABLE_B EIGHTHS EXP_FRAC_TABLE_A EXP_FRAC_TABLE_B EXP_INT_TABLE_A EXP_INT_TABLE_B SINE_TABLE_A SINE_TABLE_B TANGENT_TABLE_A TANGENT_TABLE_B hiPrec hiPrecOut lnCoef_i lnCoef_last lnm lns long[] PI_O_4_BITS RECIP_2PI double E F_11_12 F_13_14 F_15_16 F_1_11 F_1_13 F_1_15 F_1_17 F_1_2 F_1_3 F_1_4 F_1_5 F_1_7 F_1_9 F_3_4 F_5_6 F_7_8 F_9_10 LN_2_A LN_2_B LOG_MAX_VALUE PI TWO_POWER_52 a a2 aa ab absAsinh absAtanh b base baseA baseB c d da daa dab db denom denomb denomr epsilon extra finalRemA finalRemB fracPartA fracPartB fx1 intPartA intPartB lna lnb lnza lnzb lores na nb numer ra ratio ratioa ratiob rb recip recipa recipb remA remB result rln10a rln10b t temp tempA tempB tempC tmp tmp1 tmp2 x xa xb xpa xpb y ya yaa yab yb z za zb double[][] LN_HI_PREC_COEF LN_MANT LN_QUICK_COEF int EXP_FRAC_TABLE_LEN EXP_INT_TABLE_LEN EXP_INT_TABLE_MAX_INDEX LN_MANT_LEN SINE_TABLE_LEN exp finalK i intFrac intVal k long HEX_40000000 MASK_30BITS bits xl yi ", "output": "[PATCH] if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) { ", "bugid": "409"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<false> but was:<true> testIsSupportLowerBoundInclusive . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: None", "input": "[BUG] [BUGGY] return true; [FE] AssertionFailedError: expected:<false> but was:<true> testIsSupportLowerBoundInclusive [CONTEXT] public boolean isSupportLowerBoundInclusive() { [BUGGY] return true; [BUGGY] } [CLASS] FDistribution [METHOD] isSupportLowerBoundInclusive [RETURN_TYPE] boolean [VARIABLES] boolean numericalVarianceIsCalculated double DEFAULT_INVERSE_ABSOLUTE_ACCURACY denomDFMinusTwo denominatorDF denominatorDegreesOfFreedom inverseCumAccuracy logm logn lognxm logx m mhalf n nhalf numeratorDF numeratorDegreesOfFreedom numericalVariance ret solverAbsoluteAccuracy x long serialVersionUID ", "output": "[PATCH] return false; ", "bugid": "410"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<false> but was:<true> testIsSupportLowerBoundInclusive . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: None", "input": "[BUG] [BUGGY] return false; [FE] AssertionFailedError: expected:<false> but was:<true> testIsSupportLowerBoundInclusive [CONTEXT] public boolean isSupportUpperBoundInclusive() { [BUGGY] return false; [BUGGY] } [CLASS] UniformRealDistribution [METHOD] isSupportUpperBoundInclusive [RETURN_TYPE] boolean [VARIABLES] double DEFAULT_INVERSE_ABSOLUTE_ACCURACY inverseCumAccuracy lower solverAbsoluteAccuracy ul upper x long serialVersionUID boolean ", "output": "[PATCH] return true; ", "bugid": "411"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Best point not reported testMath855 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   // System.out.println(\"exp=\" + expected + \" f=\" + f.value(expected));  Assert.assertTrue(\"Best point not reported\", f.value(sol) <= f.value(expected)); }", "input": "[BUG] [BUGGY] return current; [FE] AssertionFailedError: Best point not reported testMath855 [CONTEXT] if (!isMinim) { fu = -fu; } previous = current; current = new UnivariatePointValuePair(u, isMinim ? fu : -fu); if (checker != null) { if (checker.converged(iter, previous, current)) { [BUGGY] return current; [BUGGY] } } if (fu <= fx) { if (u < x) { b = x; } else { a = x; } [CLASS] BrentOptimizer [METHOD] doOptimize [RETURN_TYPE] UnivariatePointValuePair [VARIABLES] ConvergenceChecker checker UnivariatePointValuePair current previous boolean isMinim stop double GOLDEN_SECTION MIN_RELATIVE_TOLERANCE a abs absoluteThreshold b d e fu fv fw fx hi lo m mid p q r rel relativeThreshold tol1 tol2 u v w x int iter ", "output": "[PATCH] return best(current, previous, isMinim); ", "bugid": "412"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Best point not reported testMath855 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   // System.out.println(\"exp=\" + expected + \" f=\" + f.value(expected));  Assert.assertTrue(\"Best point not reported\", f.value(sol) <= f.value(expected)); }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: Best point not reported testMath855 [CONTEXT] w = u; fw = fu; } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) { v = u; fv = fu; } } } else { [BUGGY] [BUGGY] return current; } [CLASS] BrentOptimizer [METHOD] doOptimize [RETURN_TYPE] UnivariatePointValuePair [VARIABLES] ConvergenceChecker checker UnivariatePointValuePair current previous boolean isMinim stop double GOLDEN_SECTION MIN_RELATIVE_TOLERANCE a abs absoluteThreshold b d e fu fv fw fx hi lo m mid p q r rel relativeThreshold tol1 tol2 u v w x int iter ", "output": "[PATCH] return best(current, previous, isMinim); ", "bugid": "413"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: an exception should have been thrown testIntegerOverflow . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   checkIntegerOverflow(0.75000000001455192);  checkIntegerOverflow(1.0e10);  checkIntegerOverflow(-1.0e10);  checkIntegerOverflow(-43979.60679604749); }", "input": "[BUG] [BUGGY] if (a0 > overflow) { [FE] AssertionFailedError: an exception should have been thrown testIntegerOverflow [CONTEXT] { long overflow = Integer.MAX_VALUE; double r0 = value; long a0 = (long)FastMath.floor(r0); [BUGGY] if (a0 > overflow) { [BUGGY] throw new FractionConversionException(value, a0, 1l); }  if (FastMath.abs(a0 - value) < epsilon) { this.numerator = (int) a0; this.denominator = 1; return; } [CLASS] Fraction [METHOD] <init> [RETURN_TYPE] Fraction(double,double,int,int) double value double epsilon int maxDenominator int maxIterations [VARIABLES] Fraction FOUR_FIFTHS MINUS_ONE ONE ONE_FIFTH ONE_HALF ONE_QUARTER ONE_THIRD THREE_FIFTHS THREE_QUARTERS TWO TWO_FIFTHS TWO_QUARTERS TWO_THIRDS ZERO boolean stop long a0 a1 overflow p0 p1 p2 q0 q1 q2 serialVersionUID int denominator maxDenominator maxIterations n numerator double convergent epsilon r0 r1 value ", "output": "[PATCH] if (FastMath.abs(a0) > overflow) { ", "bugid": "414"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: an exception should have been thrown testIntegerOverflow . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   checkIntegerOverflow(0.75000000001455192);  checkIntegerOverflow(1.0e10);  checkIntegerOverflow(-1.0e10);  checkIntegerOverflow(-43979.60679604749); }", "input": "[BUG] [BUGGY] if ((p2 > overflow) || (q2 > overflow)) { [FE] AssertionFailedError: an exception should have been thrown testIntegerOverflow [CONTEXT] long q2 = 1; int n = 0; boolean stop = false; do { ++n; double r1 = 1.0 / (r0 - a0); long a1 = (long)FastMath.floor(r1); p2 = (a1 * p1) + p0; q2 = (a1 * q1) + q0; [BUGGY] if ((p2 > overflow) || (q2 > overflow)) { [BUGGY] throw new FractionConversionException(value, p2, q2); } double convergent = (double)p2 / (double)q2; if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) { p0 = p1; p1 = p2; q0 = q1; q1 = q2; a0 = a1; [CLASS] Fraction [METHOD] <init> [RETURN_TYPE] Fraction(double,double,int,int) double value double epsilon int maxDenominator int maxIterations [VARIABLES] Fraction FOUR_FIFTHS MINUS_ONE ONE ONE_FIFTH ONE_HALF ONE_QUARTER ONE_THIRD THREE_FIFTHS THREE_QUARTERS TWO TWO_FIFTHS TWO_QUARTERS TWO_THIRDS ZERO boolean stop long a0 a1 overflow p0 p1 p2 q0 q1 q2 serialVersionUID int denominator maxDenominator maxIterations n numerator double convergent epsilon r0 r1 value ", "output": "[PATCH] if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) { ", "bugid": "415"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Expected exception: orgapachecommonsmath3exceptionOutOfRangeException testChromosomeListConstructorTooLow . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: None", "input": "[BUG] [BUGGY] this.elitismRate = elitismRate; [FE] AssertionFailedError: Expected exception: orgapachecommonsmath3exceptionOutOfRangeException testChromosomeListConstructorTooLow [CONTEXT] public ElitisticListPopulation(final List<Chromosome> chromosomes, final int populationLimit, final double elitismRate) { super(chromosomes, populationLimit); [BUGGY] this.elitismRate = elitismRate; [BUGGY] } [CLASS] ElitisticListPopulation [METHOD] <init> [RETURN_TYPE] List,int,double) Chromosome> chromosomes final int populationLimit final double elitismRate [VARIABLES] List chromosomes boolean double elitismRate int populationLimit ", "output": "[PATCH] setElitismRate(elitismRate); ", "bugid": "416"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Expected exception: orgapachecommonsmath3exceptionOutOfRangeException testChromosomeListConstructorTooLow . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: None", "input": "[BUG] [BUGGY] this.elitismRate = elitismRate; [FE] AssertionFailedError: Expected exception: orgapachecommonsmath3exceptionOutOfRangeException testChromosomeListConstructorTooLow [CONTEXT] public ElitisticListPopulation(final int populationLimit, final double elitismRate) { super(populationLimit); [BUGGY] this.elitismRate = elitismRate; [BUGGY] } [CLASS] ElitisticListPopulation [METHOD] <init> [RETURN_TYPE] ElitisticListPopulation(int,double) final int populationLimit final double elitismRate [VARIABLES] double elitismRate int populationLimit boolean ", "output": "[PATCH] setElitismRate(elitismRate); ", "bugid": "417"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testAtanI . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  }", "input": "[BUG] [BUGGY] return isZero ? NaN : INF; [FE] AssertionFailedError testAtanI [CONTEXT]  if (isNaN || divisor.isNaN) { return NaN; } if (divisor.isZero) { [BUGGY] return isZero ? NaN : INF; [BUGGY] } if (divisor.isInfinite() && !isInfinite()) { return ZERO; } [CLASS] Complex [METHOD] divide [RETURN_TYPE] Complex Complex divisor [VARIABLES] Complex I INF NaN ONE ZERO addend divisor ", "output": "[PATCH] return NaN; ", "bugid": "418"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testAtanI . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  }", "input": "[BUG] [BUGGY] return isZero ? NaN : INF; [FE] AssertionFailedError testAtanI [CONTEXT]  if (isNaN || Double.isNaN(divisor)) { return NaN; } if (divisor == 0d) { [BUGGY] return isZero ? NaN : INF; [BUGGY] } if (Double.isInfinite(divisor)) { return !isInfinite() ? ZERO : NaN; } [CLASS] Complex [METHOD] divide [RETURN_TYPE] Complex double divisor [VARIABLES]  Complex I INF NaN ONE ZERO addend divisor ", "output": "[PATCH] return NaN; ", "bugid": "419"}, {"instruction": "The following code contains a buggy line with the following test error: commonsmathMathRuntimeException$6: map has been modified while iterating testConcurrentModification . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   RealVector w;  w = u.ebeMultiply(v1);  w = u.ebeMultiply(v2);", "input": "[BUG] [BUGGY] Iterator iter = res.entries.iterator(); [FE] commonsmathMathRuntimeException$6: map has been modified while iterating testConcurrentModification [CONTEXT] public OpenMapRealVector ebeDivide(RealVector v) { checkVectorDimensions(v.getDimension()); OpenMapRealVector res = new OpenMapRealVector(this); [BUGGY] Iterator iter = res.entries.iterator(); [BUGGY] while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key())); } return res; } [CLASS] OpenMapRealVector OpenMapEntry OpenMapSparseIterator [METHOD] ebeDivide [RETURN_TYPE] OpenMapRealVector RealVector v [VARIABLES] Entry current boolean double DEFAULT_ZERO_TOLERANCE d epsilon value RealVector v Iterator iter OpenMapRealVector res OpenIntToDoubleHashMap entries larger randomAccess long serialVersionUID int dimension expectedSize i key resize virtualSize ", "output": "[PATCH] Iterator iter = entries.iterator(); ", "bugid": "420"}, {"instruction": "The following code contains a buggy line with the following test error: commonsmathMathRuntimeException$6: map has been modified while iterating testConcurrentModification . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   RealVector w;  w = u.ebeMultiply(v1);  w = u.ebeMultiply(v2);", "input": "[BUG] [BUGGY] Iterator iter = res.entries.iterator(); [FE] commonsmathMathRuntimeException$6: map has been modified while iterating testConcurrentModification [CONTEXT] public OpenMapRealVector ebeDivide(double[] v) { checkVectorDimensions(v.length); OpenMapRealVector res = new OpenMapRealVector(this); [BUGGY] Iterator iter = res.entries.iterator(); [BUGGY] while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() / v[iter.key()]); } return res; } [CLASS] OpenMapRealVector OpenMapEntry OpenMapSparseIterator [METHOD] ebeDivide [RETURN_TYPE] OpenMapRealVector double[] v [VARIABLES] Entry current boolean double[] v double DEFAULT_ZERO_TOLERANCE d epsilon value Iterator iter OpenMapRealVector res OpenIntToDoubleHashMap entries larger randomAccess long serialVersionUID int dimension expectedSize i key resize virtualSize ", "output": "[PATCH] Iterator iter = entries.iterator(); ", "bugid": "421"}, {"instruction": "The following code contains a buggy line with the following test error: commonsmathMathRuntimeException$6: map has been modified while iterating testConcurrentModification . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   RealVector w;  w = u.ebeMultiply(v1);  w = u.ebeMultiply(v2);", "input": "[BUG] [BUGGY] Iterator iter = res.entries.iterator(); [FE] commonsmathMathRuntimeException$6: map has been modified while iterating testConcurrentModification [CONTEXT] public OpenMapRealVector ebeMultiply(RealVector v) { checkVectorDimensions(v.getDimension()); OpenMapRealVector res = new OpenMapRealVector(this); [BUGGY] Iterator iter = res.entries.iterator(); [BUGGY] while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key())); } return res; } [CLASS] OpenMapRealVector OpenMapEntry OpenMapSparseIterator [METHOD] ebeMultiply [RETURN_TYPE] OpenMapRealVector RealVector v [VARIABLES] Entry current boolean double DEFAULT_ZERO_TOLERANCE d epsilon value RealVector v Iterator iter OpenMapRealVector res OpenIntToDoubleHashMap entries larger randomAccess long serialVersionUID int dimension expectedSize i key resize virtualSize ", "output": "[PATCH] Iterator iter = entries.iterator(); ", "bugid": "422"}, {"instruction": "The following code contains a buggy line with the following test error: commonsmathMathRuntimeException$6: map has been modified while iterating testConcurrentModification . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   RealVector w;  w = u.ebeMultiply(v1);  w = u.ebeMultiply(v2);", "input": "[BUG] [BUGGY] Iterator iter = res.entries.iterator(); [FE] commonsmathMathRuntimeException$6: map has been modified while iterating testConcurrentModification [CONTEXT] public OpenMapRealVector ebeMultiply(double[] v) { checkVectorDimensions(v.length); OpenMapRealVector res = new OpenMapRealVector(this); [BUGGY] Iterator iter = res.entries.iterator(); [BUGGY] while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() * v[iter.key()]); } return res; } [CLASS] OpenMapRealVector OpenMapEntry OpenMapSparseIterator [METHOD] ebeMultiply [RETURN_TYPE] OpenMapRealVector double[] v [VARIABLES] Entry current boolean double[] v double DEFAULT_ZERO_TOLERANCE d epsilon value Iterator iter OpenMapRealVector res OpenIntToDoubleHashMap entries larger randomAccess long serialVersionUID int dimension expectedSize i key resize virtualSize ", "output": "[PATCH] Iterator iter = entries.iterator(); ", "bugid": "423"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<-027195612846834> but was:<-027194301946870036> testQuinticMin . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertEquals(-0.27195612846834, minimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2), 1.0e-13);  assertEquals(-0.27195612846834, minimizer.getResult(), 1.0e-13);  assertEquals(-0.04433426954946, minimizer.getFunctionValue(), 1.0e-13);", "input": "[BUG] [BUGGY] return optimizer.getFunctionValue(); [FE] AssertionFailedError: expected:<-027195612846834> but was:<-027194301946870036> testQuinticMin [CONTEXT] public double getFunctionValue() { [BUGGY] return optimizer.getFunctionValue(); [BUGGY] } [CLASS] MultiStartUnivariateRealOptimizer [METHOD] getFunctionValue [RETURN_TYPE] double [VARIABLES] UnivariateRealOptimizer optimizer boolean double[] optima optimaValues long serialVersionUID int maxEvaluations maxIterations starts totalEvaluations totalIterations RandomGenerator generator ", "output": "[PATCH] return optimaValues[0]; ", "bugid": "424"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<-027195612846834> but was:<-027194301946870036> testQuinticMin . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertEquals(-0.27195612846834, minimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2), 1.0e-13);  assertEquals(-0.27195612846834, minimizer.getResult(), 1.0e-13);  assertEquals(-0.04433426954946, minimizer.getFunctionValue(), 1.0e-13);", "input": "[BUG] [BUGGY] return optimizer.getResult(); [FE] AssertionFailedError: expected:<-027195612846834> but was:<-027194301946870036> testQuinticMin [CONTEXT] public double getResult() { [BUGGY] return optimizer.getResult(); [BUGGY] } [CLASS] MultiStartUnivariateRealOptimizer [METHOD] getResult [RETURN_TYPE] double [VARIABLES] UnivariateRealOptimizer optimizer boolean double[] optima optimaValues long serialVersionUID int maxEvaluations maxIterations starts totalEvaluations totalIterations RandomGenerator generator ", "output": "[PATCH] return optima[0]; ", "bugid": "425"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<3141592653589793> but was:<12246467991473532E-16> testRootEndpoints . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void testRootEndpoints() throws Exception {  UnivariateRealFunction f = new SinFunction();  UnivariateRealSolver solver = new BrentSolver();  // endpoint is root", "input": "[BUG] [BUGGY] setResult(yMin, 0); [FE] AssertionFailedError: expected:<3141592653589793> but was:<12246467991473532E-16> testRootEndpoints [CONTEXT] double yInitial = f.value(initial); if (Math.abs(yInitial) <= functionValueAccuracy) { setResult(initial, 0); return result; } double yMin = f.value(min); if (Math.abs(yMin) <= functionValueAccuracy) { [BUGGY] setResult(yMin, 0); [BUGGY] return result; } if (yInitial * yMin < 0) { return solve(f, min, yMin, initial, yInitial, min, yMin); } double yMax = f.value(max); [CLASS] BrentSolver [METHOD] solve [RETURN_TYPE] double UnivariateRealFunction f final double min final double max final double initial [VARIABLES] UnivariateRealFunction f String NON_BRACKETING_MESSAGE boolean long serialVersionUID double initial max min yInitial yMax yMin ", "output": "[PATCH] setResult(min, 0); ", "bugid": "426"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<3141592653589793> but was:<12246467991473532E-16> testRootEndpoints . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void testRootEndpoints() throws Exception {  UnivariateRealFunction f = new SinFunction();  UnivariateRealSolver solver = new BrentSolver();  // endpoint is root", "input": "[BUG] [BUGGY] setResult(yMax, 0); [FE] AssertionFailedError: expected:<3141592653589793> but was:<12246467991473532E-16> testRootEndpoints [CONTEXT] } if (yInitial * yMin < 0) { return solve(f, min, yMin, initial, yInitial, min, yMin); } double yMax = f.value(max); if (Math.abs(yMax) <= functionValueAccuracy) { [BUGGY] setResult(yMax, 0); [BUGGY] return result; } if (yInitial * yMax < 0) { return solve(f, initial, yInitial, max, yMax, initial, yInitial); } if (yMin * yMax > 0) { throw MathRuntimeException.createIllegalArgumentException( [CLASS] BrentSolver [METHOD] solve [RETURN_TYPE] double UnivariateRealFunction f final double min final double max final double initial [VARIABLES] UnivariateRealFunction f String NON_BRACKETING_MESSAGE boolean long serialVersionUID double initial max min yInitial yMax yMin ", "output": "[PATCH] setResult(max, 0); ", "bugid": "427"}, {"instruction": "The following code contains a buggy line with the following test error: ArrayIndexOutOfBoundsException: 2 testMath209 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:     { new BigDecimal(5), new BigDecimal(6) }  }, false);  BigDecimal[] b = a.operate(new BigDecimal[] { new BigDecimal(1), new BigDecimal(1) });  assertEquals(a.getRowDimension(), b.length);  assertEquals( 3.0, b[0].doubleValue(), 1.0e-12);", "input": "[BUG] [BUGGY] final BigDecimal[] out = new BigDecimal[v.length]; [FE] ArrayIndexOutOfBoundsException: 2 testMath209 [CONTEXT]  final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); [BUGGY] final BigDecimal[] out = new BigDecimal[v.length]; [BUGGY] for (int row = 0; row < nRows; row++) {  [CLASS] BigMatrixImpl [METHOD] operate [RETURN_TYPE] BigDecimal[] BigDecimal[] v [VARIABLES] boolean int[] permutation selectedColumns selectedRows BigDecimal[] out v  int col nRows nSum ncols parity r roundingMode row rowCount column columnCount columnDimension endColumn endRow i j nCols  rowDimension scale startColumn startRow ", "output": "[PATCH] final BigDecimal[] out = new BigDecimal[nRows]; ", "bugid": "428"}, {"instruction": "The following code contains a buggy line with the following test error: ArrayIndexOutOfBoundsException: 2 testMath209 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:     { new BigDecimal(5), new BigDecimal(6) }  }, false);  BigDecimal[] b = a.operate(new BigDecimal[] { new BigDecimal(1), new BigDecimal(1) });  assertEquals(a.getRowDimension(), b.length);  assertEquals( 3.0, b[0].doubleValue(), 1.0e-12);", "input": "[BUG] [BUGGY] final double[] out = new double[v.length]; [FE] ArrayIndexOutOfBoundsException: 2 testMath209 [CONTEXT]  [BUGGY] final double[] out = new double[v.length]; [BUGGY] for (int row = 0; row < nRows; row++) {  [CLASS] RealMatrixImpl [METHOD] operate [RETURN_TYPE] double[] double[] v [VARIABLES] boolean double[] dataRow out v double TOO_SMALL d det maxColSum sum trace double[][] d data lu out outData subMatrix subMatrixData int[] permutation selectedColumns selectedRows  int col nRows nSum ncols column columnCount columnDimension endColumn endRow i j nCols   ", "output": "[PATCH] final double[] out = new double[nRows]; ", "bugid": "429"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expecting ArithmeticException testGcd . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    // gcd(Integer.MIN_VALUE, 0) > Integer.MAX_VALUE   MathUtils.gcd(Integer.MIN_VALUE, 0);   fail(\"expecting ArithmeticException\");  } catch (ArithmeticException expected) {   // expected", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: expecting ArithmeticException testGcd [CONTEXT] public static int gcd(final int p, final int q) { int u = p; int v = q; if ((u == 0) || (v == 0)) { [BUGGY] [BUGGY] return (Math.abs(u) + Math.abs(v)); } if (u > 0) { u = -u; } if (v > 0) { [CLASS] MathUtils [METHOD] gcd [RETURN_TYPE] int final int p final int q [VARIABLES] short NS PS ZS boolean long[] factorials double EPSILON SAFE_MIN TWO_PI eps logSum result x y byte NB PB ZB int k p q t u v ", "output": "[PATCH] if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) { throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q }); } ", "bugid": "430"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expecting ArithmeticException testGcd . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    // gcd(Integer.MIN_VALUE, 0) > Integer.MAX_VALUE   MathUtils.gcd(Integer.MIN_VALUE, 0);   fail(\"expecting ArithmeticException\");  } catch (ArithmeticException expected) {   // expected", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: expecting ArithmeticException testGcd [CONTEXT] public static int lcm(int a, int b) { if (a==0 || b==0){ return 0; } int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b)); [BUGGY] [BUGGY] return lcm; } [CLASS] MathUtils [METHOD] lcm [RETURN_TYPE] int int a int b [VARIABLES] short NS PS ZS x boolean long[] factorials double EPSILON SAFE_MIN TWO_PI eps logSum result value x y byte NB PB ZB x int a b lcm ", "output": "[PATCH] if (lcm == Integer.MIN_VALUE){ throw new ArithmeticException(\"overflow: lcm is 2^31\"); } ", "bugid": "431"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expecting ArithmeticException testGcd . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    // gcd(Integer.MIN_VALUE, 0) > Integer.MAX_VALUE   MathUtils.gcd(Integer.MIN_VALUE, 0);   fail(\"expecting ArithmeticException\");  } catch (ArithmeticException expected) {   // expected", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: expecting ArithmeticException testGcd [CONTEXT] public static int gcd(final int p, final int q) { int u = p; int v = q; if ((u == 0) || (v == 0)) { [BUGGY] [BUGGY] return (Math.abs(u) + Math.abs(v)); } if (u > 0) { u = -u; } if (v > 0) { [CLASS] MathUtils [METHOD] gcd [RETURN_TYPE] int final int p final int q [VARIABLES] short NS PS ZS boolean long[] factorials double EPSILON SAFE_MIN TWO_PI eps logSum result x y byte NB PB ZB int k p q t u v ", "output": "[PATCH] if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) { throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q }); } ", "bugid": "432"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expecting ArithmeticException testGcd . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    // gcd(Integer.MIN_VALUE, 0) > Integer.MAX_VALUE   MathUtils.gcd(Integer.MIN_VALUE, 0);   fail(\"expecting ArithmeticException\");  } catch (ArithmeticException expected) {   // expected", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: expecting ArithmeticException testGcd [CONTEXT] public static int lcm(int a, int b) { if (a==0 || b==0){ return 0; } int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b)); [BUGGY] [BUGGY] return lcm; } [CLASS] MathUtils [METHOD] lcm [RETURN_TYPE] int int a int b [VARIABLES] short NS PS ZS x boolean long[] factorials double EPSILON SAFE_MIN TWO_PI eps logSum result value x y byte NB PB ZB x int a b lcm ", "output": "[PATCH] if (lcm == Integer.MIN_VALUE){ throw new ArithmeticException(\"overflow: lcm is 2^31\"); } ", "bugid": "433"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: invalid minus in improper fraction testParseProperInvalidMinus . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   try {   Fraction c = properFormat.parse(source);   fail(\"invalid minus in improper fraction.\");  } catch (ParseException ex) {   // expected", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: invalid minus in improper fraction testParseProperInvalidMinus [CONTEXT] Number num = getNumeratorFormat().parse(source, pos); if (num == null) {  pos.setIndex(initialIndex); return null; } [BUGGY] [BUGGY]  int startIndex = pos.getIndex(); char c = parseNextCharacter(source, pos); switch (c) { case 0 :  return new Fraction(num.intValue(), 1); case '/' : [CLASS] ", "output": "[PATCH] if (num.intValue() < 0) { pos.setIndex(initialIndex); return null; } ", "bugid": "434"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: invalid minus in improper fraction testParseProperInvalidMinus . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   try {   Fraction c = properFormat.parse(source);   fail(\"invalid minus in improper fraction.\");  } catch (ParseException ex) {   // expected", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: invalid minus in improper fraction testParseProperInvalidMinus [CONTEXT] Number den = getDenominatorFormat().parse(source, pos); if (den == null) {  pos.setIndex(initialIndex); return null; } [BUGGY] [BUGGY] int w = whole.intValue(); int n = num.intValue(); int d = den.intValue(); return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d); } [CLASS] ProperFractionFormat [METHOD] parse [RETURN_TYPE] Fraction String source ParsePosition pos [VARIABLES] boolean Number den num whole char c Fraction ret String source long serialVersionUID int d initialIndex n startIndex w NumberFormat denominatorFormat format numeratorFormat wholeFormat ParsePosition pos ", "output": "[PATCH] if (den.intValue() < 0) { pos.setIndex(initialIndex); return null; } ", "bugid": "435"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Expected NumberFormatException testCreateNumber . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   try {   NumberUtils.createNumber(\"--1.1E-700F\");   fail(\"Expected NumberFormatException\");  } catch (NumberFormatException nfe) {   // expected", "input": "[BUG] [BUGGY] if (str.startsWith(\"--\")) { return null; } [FE] AssertionFailedError: Expected NumberFormatException testCreateNumber [CONTEXT] public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } [BUGGY] if (str.startsWith(\"--\")) { return null; } [BUGGY] if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) { int hexDigits = str.length() - 2; if (str.startsWith(\"-\")) { hexDigits--; } if (hexDigits > 8) { return createLong(str); } [CLASS] NumberUtils [METHOD] createNumber [RETURN_TYPE] Number String str [VARIABLES] Integer INTEGER_MINUS_ONE INTEGER_ONE INTEGER_ZERO Float FLOAT_MINUS_ONE FLOAT_ONE FLOAT_ZERO f boolean allZeros Byte BYTE_MINUS_ONE BYTE_ONE BYTE_ZERO Long LONG_MINUS_ONE LONG_ONE LONG_ZERO char lastChar NumberFormatException e nfe String dec exp mant numeric str Double DOUBLE_MINUS_ONE DOUBLE_ONE DOUBLE_ZERO d Short SHORT_MINUS_ONE SHORT_ONE SHORT_ZERO int decPos expPos hexDigits ", "output": "[PATCH] ", "bugid": "436"}, {"instruction": "The following code contains a buggy line with the following test error: null  testJoin_ArrayChar . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertEquals(\"/\", StringUtils.join(MIXED_ARRAY_LIST, '/', 0, MIXED_ARRAY_LIST.length-1));  assertEquals(\"foo\", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 1));  assertEquals(\"null\", StringUtils.join(NULL_TO_STRING_LIST,'/', 0, 1));  assertEquals(\"foo/2\", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 2));  assertEquals(\"2\", StringUtils.join(MIXED_TYPE_LIST, '/', 1, 2));", "input": "[BUG] [BUGGY] StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); [FE] null  testJoin_ArrayChar [CONTEXT] public static String join(Object[] array, char separator, int startIndex, int endIndex) { if (array == null) { return null; } int noOfItems = (endIndex - startIndex); if (noOfItems <= 0) { return EMPTY; } [BUGGY] StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1); [BUGGY] for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); } if (array[i] != null) { buf.append(array[i]); } } return buf.toString(); [CLASS] StringUtils [METHOD] join [RETURN_TYPE] String Object[] array char separator int startIndex int endIndex [VARIABLES] Pattern WHITESPACE_BLOCK java6Pattern sunPattern boolean camelCase chFound java6Available lastIndex lastMatch match preserveAllTokens sunAvailable StringBuilder buf char separator Object java6NormalizerFormNFD String EMPTY close input invalidChars open result searchChars separator separatorChars str stripChars tag ts validChars Method java6NormalizeMethod sunDecomposeMethod int INDEX_NOT_FOUND PAD_LIMIT beg closeLen csLast csLen csLength currentType end endIndex endLimit found i index j len max newTokenStart noOfItems numberOfSubstrings openLen ordinal pos ret searchChar searchLast searchLen searchLength separatorLength sizePlus1 start startIndex startPos strLen strsLen sz tmp tokenStart type Object[] array ", "output": "[PATCH] StringBuilder buf = new StringBuilder(noOfItems * 16); ", "bugid": "437"}, {"instruction": "The following code contains a buggy line with the following test error: null  testJoin_ArrayChar . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertEquals(\"/\", StringUtils.join(MIXED_ARRAY_LIST, '/', 0, MIXED_ARRAY_LIST.length-1));  assertEquals(\"foo\", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 1));  assertEquals(\"null\", StringUtils.join(NULL_TO_STRING_LIST,'/', 0, 1));  assertEquals(\"foo/2\", StringUtils.join(MIXED_TYPE_LIST, '/', 0, 2));  assertEquals(\"2\", StringUtils.join(MIXED_TYPE_LIST, '/', 1, 2));", "input": "[BUG] [BUGGY] StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length()); [FE] null  testJoin_ArrayChar [CONTEXT] separator = EMPTY; }  int noOfItems = (endIndex - startIndex); if (noOfItems <= 0) { return EMPTY; } [BUGGY] StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length()); [BUGGY] for (int i = startIndex; i < endIndex; i++) { if (i > startIndex) { buf.append(separator); } if (array[i] != null) { buf.append(array[i]); } } return buf.toString(); [CLASS] StringUtils [METHOD] join [RETURN_TYPE] String Object[] array String separator int startIndex int endIndex [VARIABLES] Pattern WHITESPACE_BLOCK java6Pattern sunPattern boolean camelCase chFound java6Available lastIndex lastMatch match preserveAllTokens sunAvailable StringBuilder buf Object java6NormalizerFormNFD String EMPTY close input invalidChars open result searchChars separator separatorChars str stripChars tag ts validChars Method java6NormalizeMethod sunDecomposeMethod int INDEX_NOT_FOUND PAD_LIMIT beg closeLen csLast csLen csLength currentType end endIndex endLimit found i index j len max newTokenStart noOfItems numberOfSubstrings openLen ordinal pos ret searchChar searchLast searchLen searchLength separatorLength sizePlus1 start startIndex startPos strLen strsLen sz tmp tokenStart type Object[] array ", "output": "[PATCH] StringBuilder buf = new StringBuilder(noOfItems * 16); ", "bugid": "438"}, {"instruction": "The following code contains a buggy line with the following test error: StringIndexOutOfBoundsException: String index out of range: 4 testCreateNumber . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   // LANG-638  assertFalse(\"createNumber(String) succeeded\", checkCreateNumber(\"1eE\")); }", "input": "[BUG] [BUGGY] if (expPos < decPos) { [FE] StringIndexOutOfBoundsException: String index out of range: 4 testCreateNumber [CONTEXT] char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { [BUGGY] if (expPos < decPos) { [BUGGY] throw new NumberFormatException(str +\" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); [CLASS] NumberUtils [METHOD] createNumber [RETURN_TYPE] Number String str [VARIABLES] Integer INTEGER_MINUS_ONE INTEGER_ONE INTEGER_ZERO Float FLOAT_MINUS_ONE FLOAT_ONE FLOAT_ZERO f boolean allZeros Byte BYTE_MINUS_ONE BYTE_ONE BYTE_ZERO Long LONG_MINUS_ONE LONG_ONE LONG_ZERO char lastChar NumberFormatException e nfe String dec exp mant numeric str Double DOUBLE_MINUS_ONE DOUBLE_ONE DOUBLE_ZERO d Short SHORT_MINUS_ONE SHORT_ONE SHORT_ZERO int decPos expPos ", "output": "[PATCH] if (expPos < decPos || expPos > str.length()) { ", "bugid": "439"}, {"instruction": "The following code contains a buggy line with the following test error: StringIndexOutOfBoundsException: String index out of range: 4 testCreateNumber . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   // LANG-638  assertFalse(\"createNumber(String) succeeded\", checkCreateNumber(\"1eE\")); }", "input": "[BUG] [BUGGY] [FE] StringIndexOutOfBoundsException: String index out of range: 4 testCreateNumber [CONTEXT] if (expPos < decPos) { throw new NumberFormatException(str +\" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { [BUGGY] [BUGGY] mant = str.substring(0, expPos); } else { mant = str; } dec = null; } [CLASS] NumberUtils [METHOD] createNumber [RETURN_TYPE] Number String str [VARIABLES] Integer INTEGER_MINUS_ONE INTEGER_ONE INTEGER_ZERO Float FLOAT_MINUS_ONE FLOAT_ONE FLOAT_ZERO f boolean allZeros Byte BYTE_MINUS_ONE BYTE_ONE BYTE_ZERO Long LONG_MINUS_ONE LONG_ONE LONG_ZERO char lastChar NumberFormatException e nfe String dec exp mant numeric str Double DOUBLE_MINUS_ONE DOUBLE_ONE DOUBLE_ZERO d Short SHORT_MINUS_ONE SHORT_ONE SHORT_ZERO int decPos expPos ", "output": "[PATCH] if (expPos > str.length()) { throw new NumberFormatException(str +\" is not a valid number.\"); } ", "bugid": "440"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Expected: <null> but was: {} testObjectCycle . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   String expected = toBaseString(a) + \"[\" + toBaseString(b) + \"[\" + toBaseString(a) + \"]]\";  assertEquals(expected, a.toString());  validateNullToStringStyleRegistry(); }", "input": "[BUG] [BUGGY] return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap(); [FE] AssertionFailedError: Expected: <null> but was: {} testObjectCycle [CONTEXT] static Map<Object, Object> getRegistry() { [BUGGY] return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap(); [BUGGY] } [CLASS] ToStringStyle DefaultToStringStyle NoFieldNameToStringStyle ShortPrefixToStringStyle SimpleToStringStyle MultiLineToStringStyle [METHOD] getRegistry [RETURN_TYPE] Map [VARIABLES] ToStringStyle DEFAULT_STYLE MULTI_LINE_STYLE NO_FIELD_NAMES_STYLE SHORT_PREFIX_STYLE SIMPLE_STYLE boolean arrayContentDetail defaultFullDetail fieldSeparatorAtEnd fieldSeparatorAtStart useClassName useFieldNames useIdentityHashCode useShortClassName String arrayEnd arraySeparator arrayStart contentEnd contentStart fieldNameValueSeparator fieldSeparator nullText sizeEndText sizeStartText summaryObjectEndText summaryObjectStartText ThreadLocal REGISTRY long serialVersionUID ", "output": "[PATCH] return REGISTRY.get(); ", "bugid": "441"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Expected: <null> but was: {} testObjectCycle . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   String expected = toBaseString(a) + \"[\" + toBaseString(b) + \"[\" + toBaseString(a) + \"]]\";  assertEquals(expected, a.toString());  validateNullToStringStyleRegistry(); }", "input": "[BUG] [BUGGY] return m.containsKey(value); [FE] AssertionFailedError: Expected: <null> but was: {} testObjectCycle [CONTEXT] static boolean isRegistered(Object value) { Map<Object, Object> m = getRegistry(); [BUGGY] return m.containsKey(value); [BUGGY] } [CLASS] ToStringStyle DefaultToStringStyle NoFieldNameToStringStyle ShortPrefixToStringStyle SimpleToStringStyle MultiLineToStringStyle [METHOD] isRegistered [RETURN_TYPE] boolean Object value [VARIABLES] boolean arrayContentDetail defaultFullDetail fieldSeparatorAtEnd fieldSeparatorAtStart useClassName useFieldNames useIdentityHashCode useShortClassName ThreadLocal REGISTRY ToStringStyle DEFAULT_STYLE MULTI_LINE_STYLE NO_FIELD_NAMES_STYLE SHORT_PREFIX_STYLE SIMPLE_STYLE Object value String arrayEnd arraySeparator arrayStart contentEnd contentStart fieldNameValueSeparator fieldSeparator nullText sizeEndText sizeStartText summaryObjectEndText summaryObjectStartText Map m long serialVersionUID ", "output": "[PATCH] return m != null && m.containsKey(value); ", "bugid": "442"}, {"instruction": "The following code contains a buggy line with the following test error: ClassCastException: [LjavalangObject; cannot be cast to [LjavalangString; testLANG571 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   try {   @SuppressWarnings(\"unused\")   String[] sa = ArrayUtils.add(stringArray, aString);   fail(\"Should have caused IllegalArgumentException\");  } catch (IllegalArgumentException iae){", "input": "[BUG] [BUGGY] type = Object.class; [FE] ClassCastException: [LjavalangObject; cannot be cast to [LjavalangString; testLANG571 [CONTEXT] public static <T> T[] add(T[] array, T element) { Class<?> type; if (array != null){ type = array.getClass(); } else if (element != null) { type = element.getClass(); } else { [BUGGY] type = Object.class; [BUGGY] } @SuppressWarnings(\"unchecked\") T[] newArray = (T[]) copyArrayGrow1(array, type); newArray[newArray.length - 1] = element; return newArray; } [CLASS] ArrayUtils [METHOD] add [RETURN_TYPE] <T> T[] array T element [VARIABLES] Class[] EMPTY_CLASS_ARRAY long[] EMPTY_LONG_ARRAY array array1 array2 joinedArray result subarray short[] EMPTY_SHORT_ARRAY array array1 array2 joinedArray result subarray Character[] EMPTY_CHARACTER_OBJECT_ARRAY array result Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY array result int[] EMPTY_INT_ARRAY array array1 array2 joinedArray result subarray String[] EMPTY_STRING_ARRAY Integer[] EMPTY_INTEGER_OBJECT_ARRAY array result int INDEX_NOT_FOUND endIndexExclusive i j newSize startIndex startIndexInclusive tmp valueForNull valueToFind float[] EMPTY_FLOAT_ARRAY array array1 array2 joinedArray result subarray char[] EMPTY_CHAR_ARRAY array array1 array2 joinedArray result subarray Short[] EMPTY_SHORT_OBJECT_ARRAY array result byte[] EMPTY_BYTE_ARRAY array array1 array2 joinedArray result subarray Double[] EMPTY_DOUBLE_OBJECT_ARRAY array result boolean double[] EMPTY_DOUBLE_ARRAY array array1 array2 joinedArray result subarray T element Byte[] EMPTY_BYTE_OBJECT_ARRAY array result Float[] EMPTY_FLOAT_OBJECT_ARRAY array result T[] array newArray Class type boolean[] EMPTY_BOOLEAN_ARRAY array array1 array2 joinedArray result subarray Object[] EMPTY_OBJECT_ARRAY array array1 array2 entry Long[] EMPTY_LONG_OBJECT_ARRAY array result ", "output": "[PATCH] throw new IllegalArgumentException(\"Arguments cannot both be null\"); ", "bugid": "443"}, {"instruction": "The following code contains a buggy line with the following test error: ClassCastException: [LjavalangObject; cannot be cast to [LjavalangString; testLANG571 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   try {   @SuppressWarnings(\"unused\")   String[] sa = ArrayUtils.add(stringArray, aString);   fail(\"Should have caused IllegalArgumentException\");  } catch (IllegalArgumentException iae){", "input": "[BUG] [BUGGY] return (T[]) new Object[] { null }; [FE] ClassCastException: [LjavalangObject; cannot be cast to [LjavalangString; testLANG571 [CONTEXT] public static <T> T[] add(T[] array, int index, T element) { Class<?> clss = null; if (array != null) { clss = array.getClass().getComponentType(); } else if (element != null) { clss = element.getClass(); } else { [BUGGY] return (T[]) new Object[] { null }; [BUGGY] } @SuppressWarnings(\"unchecked\") final T[] newArray = (T[]) add(array, index, element, clss); return newArray; } [CLASS] ArrayUtils [METHOD] add [RETURN_TYPE] <T> T[] array int index T element [VARIABLES] Class[] EMPTY_CLASS_ARRAY long[] EMPTY_LONG_ARRAY array array1 array2 joinedArray newArray result subarray short[] EMPTY_SHORT_ARRAY array array1 array2 joinedArray newArray result subarray Character[] EMPTY_CHARACTER_OBJECT_ARRAY array result Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY array result int[] EMPTY_INT_ARRAY array array1 array2 joinedArray newArray result subarray String[] EMPTY_STRING_ARRAY Integer[] EMPTY_INTEGER_OBJECT_ARRAY array result int INDEX_NOT_FOUND arrayLength element endIndexExclusive i index j newSize startIndex startIndexInclusive tmp valueForNull valueToFind float[] EMPTY_FLOAT_ARRAY array array1 array2 joinedArray newArray result subarray char[] EMPTY_CHAR_ARRAY array array1 array2 joinedArray newArray result subarray Short[] EMPTY_SHORT_OBJECT_ARRAY array result byte[] EMPTY_BYTE_ARRAY array array1 array2 joinedArray newArray result subarray Double[] EMPTY_DOUBLE_OBJECT_ARRAY array result boolean double[] EMPTY_DOUBLE_ARRAY array array1 array2 joinedArray newArray result subarray T element Byte[] EMPTY_BYTE_OBJECT_ARRAY array result Float[] EMPTY_FLOAT_OBJECT_ARRAY array result T[] array newArray Class clss boolean[] EMPTY_BOOLEAN_ARRAY array array1 array2 joinedArray newArray result subarray Object[] EMPTY_OBJECT_ARRAY array array1 array2 entry Long[] EMPTY_LONG_OBJECT_ARRAY array result ", "output": "[PATCH] throw new IllegalArgumentException(\"Array and element cannot both be null\"); ", "bugid": "444"}, {"instruction": "The following code contains a buggy line with the following test error: null  testLang412Left . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void testLang412Left() {  StrBuilder sb = new StrBuilder();  sb.appendFixedWidthPadLeft(null, 10, '*');  assertEquals( \"Failed to invoke appendFixedWidthPadLeft correctly\", \"**********\", sb.toString()); }", "input": "[BUG] [BUGGY] [FE] null  testLang412Left [CONTEXT] public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); [BUGGY] [BUGGY] int strLen = str.length(); if (strLen >= width) { str.getChars(strLen - width, strLen, buffer, size); } else { int padLen = width - strLen; for (int i = 0; i < padLen; i++) { buffer[size + i] = padChar; } str.getChars(0, strLen, buffer, size + padLen); } size += width; [CLASS] StrBuilder StrBuilderTokenizer StrBuilderReader StrBuilderWriter [METHOD] appendFixedWidthPadLeft [RETURN_TYPE] StrBuilder Object obj int width char padChar [VARIABLES] boolean char padChar Object obj String newLine nullText separator str int CAPACITY capacity destinationIndex endIndex i index initialCapacity len length loopIndex mark newEnd oldEnd padLen pos size startIndex strLen value width long serialVersionUID value char[] buffer chars destination old ", "output": "[PATCH] if (str == null) { str =\"\"; } ", "bugid": "445"}, {"instruction": "The following code contains a buggy line with the following test error: null  testLang412Left . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void testLang412Left() {  StrBuilder sb = new StrBuilder();  sb.appendFixedWidthPadLeft(null, 10, '*');  assertEquals( \"Failed to invoke appendFixedWidthPadLeft correctly\", \"**********\", sb.toString()); }", "input": "[BUG] [BUGGY] [FE] null  testLang412Left [CONTEXT] public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); [BUGGY] [BUGGY] int strLen = str.length(); if (strLen >= width) { str.getChars(0, width, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; [CLASS] StrBuilder StrBuilderTokenizer StrBuilderReader StrBuilderWriter [METHOD] appendFixedWidthPadRight [RETURN_TYPE] StrBuilder Object obj int width char padChar [VARIABLES] boolean char padChar Object obj String newLine nullText separator str int CAPACITY capacity destinationIndex endIndex i index initialCapacity len length loopIndex mark newEnd oldEnd padLen pos size startIndex strLen value width long serialVersionUID value char[] buffer chars destination old ", "output": "[PATCH] if (str == null) { str =\"\"; } ", "bugid": "446"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: The contains(char) method is looking beyond the end of the string testLang295 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   StrBuilder sb = new StrBuilder(\"onetwothree\");  sb.deleteFirst(\"three\");  assertFalse( \"The contains(char) method is looking beyond the end of the string\", sb.contains('h'));  assertEquals( \"The indexOf(char) method is looking beyond the end of the string\", -1, sb.indexOf('h')); }", "input": "[BUG] [BUGGY] for (int i = 0; i < thisBuf.length; i++) { [FE] AssertionFailedError: The contains(char) method is looking beyond the end of the string testLang295 [CONTEXT] public boolean contains(char ch) { char[] thisBuf = buffer; [BUGGY] for (int i = 0; i < thisBuf.length; i++) { [BUGGY] if (thisBuf[i] == ch) { return true; } } return false; } [CLASS] StrBuilder StrBuilderTokenizer StrBuilderReader StrBuilderWriter [METHOD] contains [RETURN_TYPE] boolean char ch [VARIABLES] char ch String insertStr newLine nullText replaceStr searchStr separator str boolean int CAPACITY capacity destinationIndex endIndex from half i index initialCapacity insertLen leftIdx len length mark newEnd newSize offset oldEnd padLen pos removeLen replaceCount replaceLen rightIdx searchLen size start startIndex strLen to value width long serialVersionUID value char[] buf buffer chars destination old thisBuf ", "output": "[PATCH] for (int i = 0; i < this.size; i++) { ", "bugid": "447"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testLang295 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   StrBuilder sb = new StrBuilder(\"onetwothree\");  sb.deleteFirst(\"three\");  assertFalse( \"The contains(char) method is looking beyond the end of the string\", sb.contains('h'));  assertEquals( \"The indexOf(char) method is looking beyond the end of the string\", -1, sb.indexOf('h')); }", "input": "[BUG] [BUGGY] for (int i = startIndex; i < thisBuf.length; i++) { [FE] AssertionFailedError testLang295 [CONTEXT] public int indexOf(char ch, int startIndex) { startIndex = (startIndex < 0 ? 0 : startIndex); if (startIndex >= size) { return -1; } char[] thisBuf = buffer; [BUGGY] for (int i = startIndex; i < thisBuf.length; i++) { [BUGGY] if (thisBuf[i] == ch) { return i; } } return -1; } [CLASS] StrBuilder [METHOD] indexOf [RETURN_TYPE] int char ch int startIndex [VARIABLES] char ch String insertStr newLine nullText replaceStr searchStr separator str boolean int searchLen size start startIndex strLen to value width long serialVersionUID value char[] buf buffer chars destination old thisBuf ", "output": "[PATCH] for (int i = startIndex; i < size; i++) { ", "bugid": "448"}, {"instruction": "The following code contains a buggy line with the following test error: commonscliUnrecognizedOptionException: Unrecognized option: -o test . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   String[] args = new String[] {\"-t\", \"-something\" };  CommandLine commandLine;  commandLine = parser.parse( options, args );  assertEquals(\"-something\", commandLine.getOptionValue( 't')); }", "input": "[BUG] [BUGGY] tokens.add(\"-\" + ch); [FE] commonscliUnrecognizedOptionException: Unrecognized option: -o test [CONTEXT] else if (stopAtNonOption) { process(token.substring(i)); } else { [BUGGY] tokens.add(\"-\" + ch); [BUGGY] } [CLASS] PosixParser [METHOD] burstToken [RETURN_TYPE] void String token boolean stopAtNonOption [VARIABLES] ArrayList tokens Options options Option currentOption boolean eatTheRest hasOption stopAtNonOption String ch token int i tokenLength ", "output": "[PATCH] tokens.add(token); break; ", "bugid": "449"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: number flag n expected:<45> but was:<45> testSimplePattern . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  assertEquals(\"class flag f\", java.util.Calendar.class, line.getOptionObject(\"f\")); assertEquals(\"class flag f\", java.util.Calendar.class, line.getOptionObject('f')); assertEquals(\"number flag n\", new Double(4.5), line.getOptionObject(\"n\")); assertEquals(\"number flag n\", new Double(4.5), line.getOptionObject('n')); assertEquals(\"url flag t\", new java.net.URL(\"http://jakarta.apache.org/\"), line.getOptionObject(\"t\"));", "input": "[BUG] [BUGGY] return NumberUtils.createNumber(str); [FE] AssertionFailedError: number flag n expected:<45> but was:<45> testSimplePattern [CONTEXT] public static Number createNumber(String str) { try { [BUGGY] return NumberUtils.createNumber(str); [BUGGY] } catch (NumberFormatException nfe) { System.err.println(nfe.getMessage()); } return null; } [CLASS] TypeHandler [METHOD] createNumber [RETURN_TYPE] Number String str [VARIABLES] boolean NumberFormatException nfe String str ", "output": "[PATCH] if( str != null ) { if( str.indexOf('.') != -1 ) { return Double.valueOf(str); } else { return Long.valueOf(str); } } ", "bugid": "450"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<foo> but was:<null> testGetParsedOptionValue . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:     assertEquals(123, ((Number) cmd.getParsedOptionValue(\"i\")).intValue());  assertEquals(\"foo\", cmd.getParsedOptionValue(\"f\")); }", "input": "[BUG] [BUGGY] private Class type; [FE] AssertionFailedError: expected:<foo> but was:<null> testGetParsedOptionValue [CONTEXT] [BUGGY] private Class type; [CLASS] Option [VARIABLES] ", "output": "[PATCH] private Class type = String.class; ", "bugid": "451"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<foo> but was:<null> testGetParsedOptionValue . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:     assertEquals(123, ((Number) cmd.getParsedOptionValue(\"i\")).intValue());  assertEquals(\"foo\", cmd.getParsedOptionValue(\"f\")); }", "input": "[BUG] [BUGGY] type = null; [FE] AssertionFailedError: expected:<foo> but was:<null> testGetParsedOptionValue [CONTEXT] private static void reset() { description = null; argName = null; longopt = null; [BUGGY] type = null; [BUGGY] required = false; numberOfArgs = Option.UNINITIALIZED; optionalArg = false; valuesep = (char) 0; } [CLASS] OptionBuilder [METHOD] reset [RETURN_TYPE] void [VARIABLES] boolean optionalArg required OptionBuilder instance char valuesep Class type String argName description longopt int numberOfArgs ", "output": "[PATCH] type = String.class; ", "bugid": "452"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Expected exception: orgapachecommonscliParseException testCreateValueInteger_failure . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: None", "input": "[BUG] [BUGGY] return null; [FE] AssertionFailedError: Expected exception: orgapachecommonscliParseException testCreateValueInteger_failure [CONTEXT] else if (PatternOptionBuilder.URL_VALUE == clazz) { return (T) createURL(str); } else { [BUGGY] return null; [BUGGY] } [CLASS] TypeHandler [METHOD] createValue [RETURN_TYPE] <T> String str Class<T> clazz [VARIABLES] boolean Class clazz String str ", "output": "[PATCH] throw new ParseException(\"Unable to handle the class:\" + clazz); ", "bugid": "453"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: unexpected warning(s) : JSC_IMPLEMENTS_NON_INTERFACE can only implement interfaces at [testcode] line 2 : 29, JSC_IMPLEMENTS_NON_INTERFACE can only implement interfaces at [testcode] line 3 : 26 expected:<1> but was:<2> testImplementsExtendsLoop . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] if (detectImplicitPrototypeCycle()) { [FE] AssertionFailedError: unexpected warning(s) : JSC_IMPLEMENTS_NON_INTERFACE can only implement interfaces at [testcode] line 2 : 29, JSC_IMPLEMENTS_NON_INTERFACE can only implement interfaces at [testcode] line 3 : 26 expected:<1> but was:<2> testImplementsExtendsLoop [CONTEXT] JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) { boolean resolved = resolveViaRegistry(t, enclosing); [BUGGY] if (detectImplicitPrototypeCycle()) { [BUGGY] handleTypeCycle(t); } if (resolved) { super.resolveInternal(t, enclosing); finishPropertyContinuations(); return registry.isLastGeneration() ? getReferencedType() : this; } [CLASS] NamedType PropertyContinuation [METHOD] resolveInternal [RETURN_TYPE] JSType ErrorReporter t JSType> enclosing [VARIABLES] ErrorReporter t JSType type boolean forAnnotations inferred resolved Node propertyNode StaticScope enclosing List propertyContinuations String propertyName reference sourceName long serialVersionUID int charno lineno Predicate validator ", "output": "[PATCH] if (detectInheritanceCycle()) { ", "bugid": "454"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: unexpected warning(s) : JSC_IMPLEMENTS_NON_INTERFACE can only implement interfaces at [testcode] line 2 : 29, JSC_IMPLEMENTS_NON_INTERFACE can only implement interfaces at [testcode] line 3 : 26 expected:<1> but was:<2> testImplementsExtendsLoop . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] if (detectImplicitPrototypeCycle()) { [FE] AssertionFailedError: unexpected warning(s) : JSC_IMPLEMENTS_NON_INTERFACE can only implement interfaces at [testcode] line 2 : 29, JSC_IMPLEMENTS_NON_INTERFACE can only implement interfaces at [testcode] line 3 : 26 expected:<1> but was:<2> testImplementsExtendsLoop [CONTEXT] } if (resolved) { super.resolveInternal(t, enclosing); finishPropertyContinuations(); return registry.isLastGeneration() ? getReferencedType() : this; } resolveViaProperties(t, enclosing); [BUGGY] if (detectImplicitPrototypeCycle()) { [BUGGY] handleTypeCycle(t); } super.resolveInternal(t, enclosing); if (isResolved()) { finishPropertyContinuations(); } return registry.isLastGeneration() ? getReferencedType() : this; } [CLASS] NamedType PropertyContinuation [METHOD] resolveInternal [RETURN_TYPE] JSType ErrorReporter t JSType> enclosing [VARIABLES] ErrorReporter t JSType type boolean forAnnotations inferred resolved Node propertyNode StaticScope enclosing List propertyContinuations String propertyName reference sourceName long serialVersionUID int charno lineno Predicate validator ", "output": "[PATCH] if (detectInheritanceCycle()) { ", "bugid": "455"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testIssue820 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  // Don't redeclare function parameters, this is incompatible with // strict mode. testSame(\"function f(a){ var b=1; a=2; var c; }\");  }", "input": "[BUG] [BUGGY] return var != null && var.getScope() == s &&!blacklistedVars.contains(var); [FE] AssertionFailedError: testIssue820 [CONTEXT] Node assign = n.getFirstChild(); Node lhs = assign.getFirstChild(); if (!lhs.isName()) { return false; } Var var = s.getVar(lhs.getString()); [BUGGY] return var != null && var.getScope() == s &&!blacklistedVars.contains(var); [BUGGY] } [CLASS] CollapseVariableDeclarations Collapse GatherCollapses [METHOD] canBeRedeclared [RETURN_TYPE] boolean Node n Scope s [VARIABLES] AbstractCompiler compiler Set blacklistedVars nodesToCollapse boolean Scope s Var var Node assign child endNode externs lhs n parent root startNode varNode List collapses ", "output": "[PATCH] && !isNamedParameter(var) ", "bugid": "456"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<5> but was:<4> testParseSourceMetaMap . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  generator.appendIndexMapTo(mapContents, \"out.js\", sections); check(inputs, output.toString(), mapContents.toString(),   new SourceMapSupplier() {  @Override", "input": "[BUG] [BUGGY] .setLineNumber(entry.getSourceLine()) .setColumnPosition(entry.getSourceColumn()); [FE] AssertionFailedError: expected:<5> but was:<4> testParseSourceMetaMap [CONTEXT] private OriginalMapping getOriginalMappingForEntry(Entry entry) { if (entry.getSourceFileId() == UNMAPPED) { return null; } else { Builder x = OriginalMapping.newBuilder() .setOriginalFile(sources[entry.getSourceFileId()]) [BUGGY] .setLineNumber(entry.getSourceLine()) .setColumnPosition(entry.getSourceColumn()); [BUGGY] if (entry.getNameId() != UNMAPPED) { x.setIdentifier(names[entry.getNameId()]); } return x.build(); } } [CLASS] SourceMapConsumerV3 DefaultSourceMapSupplier MappingBuilder StringCharIterator UnmappedEntry UnnamedEntry NamedEntry [METHOD] getOriginalMappingForEntry [RETURN_TYPE] OriginalMapping Entry entry [VARIABLES] StringCharIterator content Entry entry boolean Builder x ArrayList entries lines result String[] names result sources String content contents file lineMap mapSectionContents originalFile url Map reverseSourceMapping sourceLineToCollectionMap int MAX_ENTRY_VALUES UNMAPPED column compare count current end entry entryValues i index len length line lineCount lineNumber mid name previousCol previousNameId previousSrcColumn previousSrcId previousSrcLine srcColumn srcFile srcLine start target version ", "output": "[PATCH] .setLineNumber(entry.getSourceLine() + 1) .setColumnPosition(entry.getSourceColumn() + 1); ", "bugid": "457"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testInline19b . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] if (declarationRoot.getType() == Token.FUNCTION) { [FE] AssertionFailedError: testInline19b [CONTEXT] Preconditions.checkState( declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer)); Preconditions.checkState(t.inGlobalScope()); renamer = rootRenamer; } else { renamer = nameStack.peek().forChildScope(); } [BUGGY] if (declarationRoot.getType() == Token.FUNCTION) { [BUGGY] for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) { String name = c.getString(); renamer.addDeclaredName(name); } Node functionBody = declarationRoot.getLastChild(); findDeclaredNames(functionBody, null, renamer); }else if (declarationRoot.getType() != Token.FUNCTION) { findDeclaredNames(declarationRoot, null, renamer); [CLASS] MakeDeclaredNamesUnique ContextualRenameInverter ContextualRenamer InlineRenamer BoilerplateRenamer [METHOD] enterScope [RETURN_TYPE] void NodeTraversal t [VARIABLES] Renamer renamer rootRenamer AbstractCompiler compiler Set referencedNames boolean global removeConstness NodeTraversal t Node c declarationRoot functionBody Multiset nameUsage Supplier uniqueIdSupplier String ARGUMENTS UNIQUE_ID_SEPARATOR idPrefix name Deque nameStack referenceStack Map declarations nameMap ", "output": "[PATCH] if ((long) x == x && !isNegativeZero(x)) {", "bugid": "458"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testInlineFunctions31 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   public void testInlineFunctions31() { // Don't introduce a duplicate label in the same scope test(\"function foo(){ lab:{4;} }\" +  \"lab:{foo();}\",  \"lab:{{JSCompiler_inline_label_0:{4}}}\");", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: testInlineFunctions31 [CONTEXT] private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) { Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier(); NodeTraversal.traverse( compiler, fnNode, new MakeDeclaredNamesUnique( new InlineRenamer( idSupplier,\"inline_\", isCallInLoop))); [BUGGY] [BUGGY] } static class LabelNameSupplier implements Supplier<String> { final Supplier<String> idSupplier; LabelNameSupplier(Supplier<String> idSupplier) { this.idSupplier = idSupplier; } @Override public String get() { [CLASS] ", "output": "[PATCH] new RenameLabels(compiler, new LabelNameSupplier(idSupplier), false).process(null, fnNode); ", "bugid": "458"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testIEString . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: testIEString [CONTEXT] static Double getStringNumberValue(String rawJsString) { [BUGGY] [BUGGY] String s = trimJsWhiteSpace(rawJsString); if (s.length() == 0) { return 0.0; } if (s.length() > 2 && s.charAt(0) == '0' && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) { [CLASS] NodeUtil NumbericResultPredicate BooleanResultPredicate MayBeStringResultPredicate VarCollector MatchNameNode MatchNodeType MatchDeclaration MatchNotFunction MatchShallowStatement [METHOD] getStringNumberValue [RETURN_TYPE] Double String rawJsString [VARIABLES] BooleanResultPredicate BOOLEAN_RESULT_PREDICATE Set BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS CONSTRUCTORS_WITHOUT_SIDE_EFFECTS OBJECT_METHODS_WITHOUT_SIDEEFFECTS REGEXP_METHODS STRING_REGEXP_METHODS NumbericResultPredicate NUMBERIC_RESULT_PREDICATE boolean MayBeStringResultPredicate MAY_BE_STRING_PREDICATE NumberFormatException e String JSC_PROPERTY_NAME_FN childValue name rawJsString s value Map vars int nextSkipSlot nextSlot type ", "output": "[PATCH] if (rawJsString.contains(\"\\u000b\")) { return null; } ", "bugid": "459"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testIEString . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   }", "input": "[BUG] [BUGGY] return TernaryValue.TRUE; [FE] AssertionFailedError: testIEString [CONTEXT] static TernaryValue isStrWhiteSpaceChar(int c) { switch (c) { case '\\u000B': [BUGGY] return TernaryValue.TRUE; [BUGGY] case ' ': case '\\n': case '\\r': case '\\t': case '\\u00A0': case '\\u000C': case '\\u2028': case '\\u2029': case '\\uFEFF': return TernaryValue.TRUE; [CLASS] NodeUtil NumbericResultPredicate BooleanResultPredicate MayBeStringResultPredicate VarCollector MatchNameNode MatchNodeType MatchDeclaration MatchNotFunction MatchShallowStatement [METHOD] isStrWhiteSpaceChar [RETURN_TYPE] TernaryValue int c [VARIABLES] BooleanResultPredicate BOOLEAN_RESULT_PREDICATE Set BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS CONSTRUCTORS_WITHOUT_SIDE_EFFECTS OBJECT_METHODS_WITHOUT_SIDEEFFECTS REGEXP_METHODS STRING_REGEXP_METHODS NumbericResultPredicate NUMBERIC_RESULT_PREDICATE boolean MayBeStringResultPredicate MAY_BE_STRING_PREDICATE String JSC_PROPERTY_NAME_FN childValue name rawJsString s value Map vars int c end nextSkipSlot nextSlot start type ", "output": "[PATCH] return TernaryValue.UNKNOWN;  ", "bugid": "460"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Unexpected error(s): JSC_DIVIDE_BY_0_ERROR Divide by 0 at testcode line 1 : 8 expected:<0> but was:<1> testFoldArithmetic . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  fold(\"z = x * y\", \"z = x * y\"); fold(\"x = y * 5\", \"x = y * 5\"); fold(\"x = 1 / 0\", \"x = 1 / 0\"); fold(\"x = 3 % 2\", \"x = 1\"); fold(\"x = 3 % -2\", \"x = 1\");", "input": "[BUG] [BUGGY] error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\",\"Divide by 0\"), right); [FE] AssertionFailedError: Unexpected error(s): JSC_DIVIDE_BY_0_ERROR Divide by 0 at testcode line 1 : 8 expected:<0> but was:<1> testFoldArithmetic [CONTEXT] result = lval + rval; break; case Token.SUB: result = lval - rval; break; case Token.MUL: result = lval * rval; break; case Token.MOD: if (rval == 0) { [BUGGY] error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\",\"Divide by 0\"), right); [BUGGY] return null; } result = lval % rval; break; case Token.DIV: if (rval == 0) { error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\",\"Divide by 0\"), right); return null; } result = lval / rval; [CLASS] PeepholeFoldConstants [METHOD] performArithmeticOp [RETURN_TYPE] Node int opType Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left newNumber right Double lValObj rValObj int opType ", "output": "[PATCH] [Delete]", "bugid": "461"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Unexpected error(s): JSC_DIVIDE_BY_0_ERROR Divide by 0 at testcode line 1 : 8 expected:<0> but was:<1> testFoldArithmetic . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  fold(\"z = x * y\", \"z = x * y\"); fold(\"x = y * 5\", \"x = y * 5\"); fold(\"x = 1 / 0\", \"x = 1 / 0\"); fold(\"x = 3 % 2\", \"x = 1\"); fold(\"x = 3 % -2\", \"x = 1\");", "input": "[BUG] [BUGGY] error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\",\"Divide by 0\"), right); [FE] AssertionFailedError: Unexpected error(s): JSC_DIVIDE_BY_0_ERROR Divide by 0 at testcode line 1 : 8 expected:<0> but was:<1> testFoldArithmetic [CONTEXT] break; case Token.MOD: if (rval == 0) { error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\",\"Divide by 0\"), right); return null; } result = lval % rval; break; case Token.DIV: if (rval == 0) { [BUGGY] error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\",\"Divide by 0\"), right); [BUGGY] return null; } result = lval / rval; break; default: throw new Error(\"Unexpected arithmetic operator\"); }  [CLASS] PeepholeFoldConstants [METHOD] performArithmeticOp [RETURN_TYPE] Node int opType Node left Node right [VARIABLES] Locale ROOT_LOCALE boolean DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE FRACTIONAL_BITWISE_OPERAND INDEX_OUT_OF_BOUNDS_ERROR INVALID_GETELEM_INDEX_ERROR NEGATING_A_NON_NUMBER_ERROR SHIFT_AMOUNT_OUT_OF_BOUNDS double MAX_FOLD_NUMBER lval negNum numValue result rval val value Node left newNumber right Double lValObj rValObj int opType ", "output": "[PATCH] [Delete]", "bugid": "462"}, {"instruction": "The following code contains a buggy line with the following test error: RuntimeException: INTERNAL COMPILER ERROR testIssue . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   public void testIssue() { super.allowExternsChanges(true); test(\"var a,b,c; var a,b\", \"a(), b()\", \"a(), b()\", null, null);  }", "input": "[BUG] [BUGGY] .traverse(root); [FE] RuntimeException: INTERNAL COMPILER ERROR testIssue [CONTEXT] public void process(Node externs, Node root) { new NodeTraversal( compiler, new NormalizeStatements(compiler, assertOnChange)) [BUGGY] .traverse(root); [BUGGY] if (MAKE_LOCAL_NAMES_UNIQUE) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); NodeTraversal t = new NodeTraversal(compiler, renamer); t.traverseRoots(externs, root); } [CLASS] Normalize PropagateConstantAnnotationsOverVars VerifyConstants NormalizeStatements DuplicateDeclarationHandler ScopeTicklingCallback [METHOD] process [RETURN_TYPE] void Node externs Node root [VARIABLES] AbstractCompiler compiler boolean CONVERT_WHILE_TO_FOR MAKE_LOCAL_NAMES_UNIQUE assertOnChange checkUserDeclarations forbidChanges Set hasOkDuplicateDeclaration NodeTraversal t DiagnosticType CATCH_BLOCK_VAR_ERROR Node externs root MakeDeclaredNamesUnique renamer Map constantMap ", "output": "[PATCH] .traverseRoots(externs, root); ", "bugid": "463"}, {"instruction": "The following code contains a buggy line with the following test error: RuntimeException: INTERNAL COMPILER ERROR testIssue . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   public void testIssue() { super.allowExternsChanges(true); test(\"var a,b,c; var a,b\", \"a(), b()\", \"a(), b()\", null, null);  }", "input": "[BUG] [BUGGY] [FE] RuntimeException: INTERNAL COMPILER ERROR testIssue [CONTEXT]  if (compiler.getCodingConvention().isConstant(varName)) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } getSynthesizedExternsRoot().addChildToBack( new Node(Token.VAR, nameNode)); varsToDeclareInExterns.remove(varName); [BUGGY] [BUGGY] } [CLASS] VarCheck NameRefInExternsCheck [METHOD] createSynthesizedExternVar [RETURN_TYPE] void String varName [VARIABLES] CompilerInput currInput synthesizedExternsInput varInput AbstractCompiler compiler Set varsToDeclareInExterns boolean sanityCheck strictExternCheck DiagnosticType INVALID_FUNCTION_DECL MISSING_MODULE_DEP_ERROR NAME_REFERENCE_IN_EXTERNS_ERROR STRICT_MODULE_DEP_ERROR UNDEFINED_EXTERN_VAR_ERROR UNDEFINED_VAR_ERROR VIOLATED_MODULE_DEP_ERROR Node externs n nameNode parent root synthesizedExternsRoot String varName ", "output": "[PATCH] compiler.reportCodeChange(); ", "bugid": "464"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testIsBooleanResult . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\"))); assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\"))); assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\"))); assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));", "input": "[BUG] [BUGGY] [FE] AssertionFailedError testIsBooleanResult [CONTEXT] case Token.LT: case Token.GT: case Token.LE: case Token.GE: case Token.IN: case Token.INSTANCEOF: case Token.NOT: [BUGGY] [BUGGY] return true; default: return false; } } [CLASS] NodeUtil NumbericResultPredicate BooleanResultPredicate MayBeStringResultPredicate VarCollector MatchNameNode MatchNodeType MatchDeclaration MatchNotFunction MatchShallowStatement [METHOD] isBooleanResultHelper [RETURN_TYPE] boolean Node n [VARIABLES] BooleanResultPredicate BOOLEAN_RESULT_PREDICATE Set BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS CONSTRUCTORS_WITHOUT_SIDE_EFFECTS OBJECT_METHODS_WITHOUT_SIDEEFFECTS REGEXP_METHODS STRING_REGEXP_METHODS defines emptySet knownConstants NumbericResultPredicate NUMBERIC_RESULT_PREDICATE boolean MayBeStringResultPredicate MAY_BE_STRING_PREDICATE Node n String JSC_PROPERTY_NAME_FN childValue name namespaceName rawJsString s value Map vars int c end nextSkipSlot nextSlot start type ", "output": "[PATCH] case Token.DELPROP: ", "bugid": "465"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError testIsBooleanResult . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  assertFalse(NodeUtil.isBooleanResult(getNode(\"NaN\"))); assertFalse(NodeUtil.isBooleanResult(getNode(\"undefined\"))); assertFalse(NodeUtil.isBooleanResult(getNode(\"void 0\"))); assertFalse(NodeUtil.isBooleanResult(getNode(\"a << b\")));", "input": "[BUG] [BUGGY] [FE] AssertionFailedError testIsBooleanResult [CONTEXT] || locals.apply(value); case Token.NEW: return newHasLocalResult(value) || locals.apply(value); case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT: case Token.OBJECTLIT: return true; [BUGGY] [BUGGY] case Token.IN: return true; default:  if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) { return true; [CLASS] NodeUtil NumbericResultPredicate BooleanResultPredicate MayBeStringResultPredicate VarCollector MatchNameNode MatchNodeType MatchDeclaration MatchNotFunction MatchShallowStatement [METHOD] evaluatesToLocalValue [RETURN_TYPE] boolean Node value Node> locals [VARIABLES] BooleanResultPredicate BOOLEAN_RESULT_PREDICATE Set BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS CONSTRUCTORS_WITHOUT_SIDE_EFFECTS OBJECT_METHODS_WITHOUT_SIDEEFFECTS REGEXP_METHODS STRING_REGEXP_METHODS defines emptySet knownConstants NumbericResultPredicate NUMBERIC_RESULT_PREDICATE boolean MayBeStringResultPredicate MAY_BE_STRING_PREDICATE Node value String JSC_PROPERTY_NAME_FN childValue lhsString methodName name namespaceName originalName part propName qNameStr rawJsString res s sourceName value Map vars int c charno end endPos index len lineno memberIndex nextSkipSlot nextSlot operator prototypeIdx start startPos total type Predicate locals ", "output": "[PATCH] case Token.DELPROP: ", "bugid": "466"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testAddPropertyToChildOfUncollapsibleFunctionInLocalScope . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: testAddPropertyToChildOfUncollapsibleFunctionInLocalScope [CONTEXT] private void updateSimpleDeclaration(String alias, Name refName, Ref ref) { Node rvalue = ref.node.getNext(); Node parent = ref.node.getParent(); Node gramps = parent.getParent(); Node greatGramps = gramps.getParent(); Node greatGreatGramps = greatGramps.getParent(); [BUGGY] [BUGGY] Node nameNode = NodeUtil.newName( compiler.getCodingConvention(), alias, gramps.getFirstChild(), refName.fullName()); NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode); if (gramps.getType() == Token.EXPR_RESULT) {  [CLASS] CollapseProperties 1 [METHOD] updateSimpleDeclaration [RETURN_TYPE] void String alias Name refName Ref ref [VARIABLES] AbstractCompiler compiler Ref ref boolean canCollapseChildNames collapsePropertiesOnExternTypes initialized inlineAliases isObjKey isQName DiagnosticType NAMESPACE_REDEFINED_WARNING UNSAFE_NAMESPACE_WARNING UNSAFE_THIS Node current currentParent gramps greatGramps greatGreatGramps nameNode parent rvalue stubVar varNode List globalNames refs String alias Map nameMap Name refName ", "output": "[PATCH] if (rvalue != null && rvalue.getType() == Token.FUNCTION) { checkForHosedThisReferences(rvalue, refName.docInfo, refName); } ", "bugid": "467"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testAddPropertyToChildOfUncollapsibleFunctionInLocalScope . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: testAddPropertyToChildOfUncollapsibleFunctionInLocalScope [CONTEXT] return true; }  if (parent != null && parent.shouldKeepKeys()) { return false; }  [BUGGY] [BUGGY] if (type != Type.FUNCTION && aliasingGets > 0) { return false; } return (parent == null || parent.canCollapseUnannotatedChildNames()); } [CLASS] GlobalNamespace NodeFilter BuildGlobalNamespace Name Type Ref Type [METHOD] canCollapseUnannotatedChildNames [RETURN_TYPE] boolean [VARIABLES] Set newNodes Node anc current externsRoot gramps greatGramps lvalue n name node parent prev root rvalue second third valueNode String key name parentName prefix sourceName topVarName JSDocInfo docInfo info int aliasingGets callGets firstDotIndex globalSets i localSets numLevelsToRemove totalGets valueNodeType Predicate nodeFilter Name n nameObj node parent AbstractCompiler compiler Type ALIASING_GET CALL_GET DIRECT_GET FUNCTION OBJECTLIT OTHER PROTOTYPE_GET SET_FROM_GLOBAL SET_FROM_LOCAL t type Ref declaration get maybeNewDecl original ref set twin boolean generated hasClassOrEnumDescendant inExterns isClassOrEnum isPropAssign isSet Scope externsScope s scope JSModule module List globalNames props refs Map nameMap ", "output": "[PATCH] if (aliasingGets > 0) { ", "bugid": "468"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: unexpected warnings(s): testBackwardsTypedefUse8 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  // Tehnically, this isn't quite right, because the JS runtime // will coerce null -> the global object. But we'll punt on that for now. testTypes(  \"/** @param {!Array} x */ function g(x) {}\" +  \"/** @this {goog.MyTypedef} */ function f() { g(this); }\" +", "input": "[BUG] [BUGGY] if (!type.isSubtype( [FE] AssertionFailedError: unexpected warnings(s): testBackwardsTypedefUse8 [CONTEXT] public boolean apply(JSType type) {  [BUGGY] if (!type.isSubtype( [BUGGY] typeRegistry.getNativeType(OBJECT_TYPE))) { reportWarning(THIS_TYPE_NON_OBJECT, type.toString()); return false; } return true; } [CLASS] FunctionTypeBuilder ExtendedTypeValidator ImplementedTypeValidator ThisTypeValidator [METHOD] apply [RETURN_TYPE] boolean JSType type [VARIABLES] ObjectType baseType objectType thisType AbstractCompiler compiler JSTypeRegistry typeRegistry JSType returnType type boolean isConstructor isInterface returnTypeInferred Scope scope DiagnosticType EXTENDS_NON_OBJECT EXTENDS_WITHOUT_TYPEDEF IMPLEMENTS_WITHOUT_CONSTRUCTOR INEXISTANT_PARAM OPTIONAL_ARG_AT_END RESOLVED_TAG_EMPTY TEMPLATE_TYPE_DUPLICATED TEMPLATE_TYPE_EXPECTED THIS_TYPE_NON_OBJECT TYPE_REDEFINITION VAR_ARGS_MUST_BE_LAST CodingConvention codingConvention Node errorRoot parametersNode sourceNode List implementedInterfaces String fnName sourceName templateTypeName ", "output": "[PATCH] if (!type.restrictByNotNullOrUndefined().isSubtype( ", "bugid": "469"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: unexpected warnings(s): testBackwardsTypedefUse8 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  // Tehnically, this isn't quite right, because the JS runtime // will coerce null -> the global object. But we'll punt on that for now. testTypes(  \"/** @param {!Array} x */ function g(x) {}\" +  \"/** @this {goog.MyTypedef} */ function f() { g(this); }\" +", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: unexpected warnings(s): testBackwardsTypedefUse8 [CONTEXT]   JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope); [BUGGY] [BUGGY] if (maybeTypeOfThis instanceof ObjectType) { typeOfThis = (ObjectType) maybeTypeOfThis; } boolean changed = false; ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder(); for (ObjectType iface : implementedInterfaces) { ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope); resolvedInterfaces.add(resolvedIface); changed |= (resolvedIface != iface); [CLASS] FunctionType Kind [METHOD] resolveInternal [RETURN_TYPE] JSType ErrorReporter t JSType> scope [VARIABLES] JSType maybeTypeOfThis FunctionPrototypeType prototype Node lastParam n newParamsNode p params source thisTypeNode StaticScope scope Builder resolvedInterfaces ArrowType arrowType call String name property propertyName templateTypeName long serialVersionUID int i ObjectType baseType iface instance instanceType maybeSuperInstanceType newTypeOfThis objType resolvedIface type typeOfThis ErrorReporter t boolean changed Kind CONSTRUCTOR INTERFACE ORDINARY kind List implementedInterfaces subTypes ", "output": "[PATCH] if (maybeTypeOfThis != null) { maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined(); } ", "bugid": "470"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Unexpected error(s): JSC_USELESS_CODE Suspicious code This code lacks side-effects Is there a bug? at testcode line 1 expected:<0> but was:<1> testJSDocComments . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   }", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: Unexpected error(s): JSC_USELESS_CODE Suspicious code This code lacks side-effects Is there a bug? at testcode line 1 expected:<0> but was:<1> testJSDocComments [CONTEXT] boolean canCollapseUnannotatedChildNames() { if (type == Type.OTHER || globalSets != 1 || localSets != 0) { return false; } [BUGGY] [BUGGY] if (isClassOrEnum) { return true; } return (type == Type.FUNCTION || aliasingGets == 0) && (parent == null || parent.canCollapseUnannotatedChildNames()); } [CLASS] GlobalNamespace NodeFilter BuildGlobalNamespace Name Type Ref Type [METHOD] canCollapseUnannotatedChildNames [RETURN_TYPE] boolean [VARIABLES] Set newNodes Node anc current externsRoot gramps greatGramps key lvalue n name node parent prev root rvalue second third valueNode walker String key name parentName prefix sourceName topVarName JSDocInfo docInfo info int aliasingGets callGets firstDotIndex globalSets i localSets numLevelsToRemove totalGets valueNodeType Predicate nodeFilter Name n nameObj node parent AbstractCompiler compiler Type ALIASING_GET CALL_GET DIRECT_GET FUNCTION OBJECTLIT OTHER PROTOTYPE_GET SET_FROM_GLOBAL SET_FROM_LOCAL t type Ref declaration get maybeNewDecl original ref set twin boolean generated hasClassOrEnumDescendant inExterns isClassOrEnum isPropAssign isSet Scope externsScope s scope JSModule module List globalNames props refs Map nameMap ", "output": "[PATCH] Preconditions.checkNotNull(declaration); if (declaration.getTwin() != null) { return false; } ", "bugid": "471"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Unexpected error(s): JSC_USELESS_CODE Suspicious code This code lacks side-effects Is there a bug? at testcode line 1 expected:<0> but was:<1> testJSDocComments . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   }", "input": "[BUG] [BUGGY] if (parseDocumentation) { populated = true; } [FE] AssertionFailedError: Unexpected error(s): JSC_USELESS_CODE Suspicious code This code lacks side-effects Is there a bug? at testcode line 1 expected:<0> but was:<1> testJSDocComments [CONTEXT] public boolean recordBlockDescription(String description) { [BUGGY] if (parseDocumentation) { populated = true; } [BUGGY] return currentInfo.documentBlock(description); } [CLASS] JSDocInfoBuilder [METHOD] recordBlockDescription [RETURN_TYPE] boolean String description [VARIABLES] boolean hasLC parseDocumentation populated Marker currentMarker marker String description JSDocInfo built currentInfo info ", "output": "[PATCH] populated = true;", "bugid": "472"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testBug4944818 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] boolean hasSideEffects = false; if (block.hasChildren()) { Preconditions.checkState(block.hasOneChild()); Node stmt = block.getFirstChild(); if (stmt.isReturn()) { hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler); } } [FE] AssertionFailedError: testBug4944818 [CONTEXT] Node callNode, Node fnNode) { if (!isDirectCallNodeReplacementPossible(fnNode)) { return CanInlineResult.NO; } Node block = fnNode.getLastChild(); [BUGGY] boolean hasSideEffects = false; if (block.hasChildren()) { Preconditions.checkState(block.hasOneChild()); Node stmt = block.getFirstChild(); if (stmt.isReturn()) { hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler); } } [BUGGY] Node cArg = callNode.getFirstChild().getNext(); [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] canInlineReferenceDirectly [RETURN_TYPE] FunctionInjector$CanInlineResult Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions fnContainsVars forbidTemps hasArgs hasSideEffects isCallInLoop needsDefaultReturnResult referencesArguments referencesThis Set allNamesToAlias knownConstants namesToAlias needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block cArg callNode callParentNode expressionRoot fnCaller fnCallerBody fnNode fnParam grandParent greatGrandParent inlineResult n newBlock newExpression parent returnNode safeReturnNode srcLocation stmt thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST ", "output": "[PATCH] [Delete] ", "bugid": "473"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testBug4944818 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { return CanInlineResult.NO; } [FE] AssertionFailedError: testBug4944818 [CONTEXT] Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode)); } } Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); while (cArg != null || fnParam != null) { if (fnParam != null) { if (cArg != null) { [BUGGY] if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { return CanInlineResult.NO; } [BUGGY]  if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount( block, fnParam.getString()) > 1) { return CanInlineResult.NO; } [CLASS] FunctionInjector InliningMode Reference 1 CallSiteType 1 2 3 4 5 6 CanInlineResult 2 [METHOD] canInlineReferenceDirectly [RETURN_TYPE] FunctionInjector$CanInlineResult Node callNode Node fnNode [VARIABLES] CanInlineResult AFTER_PREPARATION NO YES AbstractCompiler compiler boolean allowDecomposition assumeMinimumCapture assumeStrictThis containsFunctions fnContainsVars forbidTemps hasArgs hasSideEffects isCallInLoop needsDefaultReturnResult referencesArguments referencesThis Set allNamesToAlias knownConstants namesToAlias needAliases InliningMode BLOCK DIRECT mode CallSiteType DECOMPOSABLE_EXPRESSION EXPRESSION SIMPLE_ASSIGNMENT SIMPLE_CALL UNSUPPORTED VAR_DECL_SIMPLE_ASSIGNMENT callSiteType Node block cArg callNode callParentNode expressionRoot fnCaller fnCallerBody fnNode fnParam grandParent greatGrandParent inlineResult n newBlock newExpression parent returnNode safeReturnNode srcLocation stmt thisValue JSModule module Supplier safeNameIdSupplier int COMMA_COST NAME_COST_ESTIMATE PAREN_COST ", "output": "[PATCH] [Delete]", "bugid": "474"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: testIssue925 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG] [BUGGY] [FE] AssertionFailedError: testIssue925 [CONTEXT] [BUGGY] [BUGGY] if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && !mayEffectMutableState(lhs)) { n.removeChild(cond); Node assignName = thenOp.removeFirstChild(); Node thenExpr = thenOp.removeFirstChild(); Node elseExpr = elseOp.getLastChild(); elseOp.removeChild(elseExpr); Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); Node assign = new Node(thenOp.getType(), assignName, hookNode) .srcref(thenOp); [CLASS] PeepholeSubstituteAlternateSyntax 1 2 3 FoldArrayAction [METHOD] tryMinimizeIf [RETURN_TYPE] Node Node n [VARIABLES] Pattern REGEXP_FLAGS_RE FoldArrayAction NOT_SAFE_TO_FOLD SAFE_TO_FOLD_WITHOUT_ARGS SAFE_TO_FOLD_WITH_ARGS boolean elseBranchIsExpressionBlock elseBranchIsVar late thenBranchIsExpressionBlock thenBranchIsVar ImmutableSet STANDARD_OBJECT_CONSTRUCTORS DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS Node and assign assignName cond elseAssign elseBranch elseExpr elseOp expr hookNode innerCond innerElseBranch innerIf innerThenBranch lhs maybeName1 maybeName2 n name1 name2 newExpr or parent returnNode thenAssign thenBranch thenExpr thenOp var CodeGenerator REGEXP_ESCAPER int AND_PRECEDENCE NOT_PRECEDENCE OR_PRECEDENCE STRING_SPLIT_OVERHEAD complementOperator Predicate DONT_TRAVERSE_FUNCTIONS_PREDICATE ", "output": "[PATCH] if ((!mayHaveSideEffects(cond) || (thenOp.isAssign() && thenOp.getFirstChild().isName()))) { ", "bugid": "475"}, {"instruction": "The following code contains a buggy line with the following test error: ArrayIndexOutOfBoundsException: 2 testCodec105 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   Base64InputStream in = new Base64InputStream(new Codec105ErrorInputStream(), true, 0, null);  for (int i = 0; i < 5; i++) {   in.read();  } }", "input": "[BUG] [BUGGY] void setInitialBuffer(byte[] out, int outPos, int outAvail) { if (out != null && out.length == outAvail) { buffer = out; pos = outPos; readPos = outPos; } } [FE] ArrayIndexOutOfBoundsException: 2 testCodec105 [CONTEXT] [BUGGY] void setInitialBuffer(byte[] out, int outPos, int outAvail) { if (out != null && out.length == outAvail) { buffer = out; pos = outPos; readPos = outPos; } } [CLASS] Base64 [METHOD] setInitialBuffer [RETURN_TYPE] void byte[] out int outPos int outAvail [VARIABLES] byte[] CHUNK_SEPARATOR DECODE_TABLE STANDARD_ENCODE_TABLE URL_SAFE_ENCODE_TABLE b buffer encodeTable lineSeparator out boolean eof urlSafe byte PAD int DEFAULT_BUFFER_RESIZE_FACTOR DEFAULT_BUFFER_SIZE MASK_6BITS MASK_8BITS MIME_CHUNK_SIZE PEM_CHUNK_SIZE bAvail bPos currentLinePos decodeSize encodeSize len lineLength modulus outAvail outPos pos readPos x ", "output": "[PATCH] [Delete] ", "bugid": "476"}, {"instruction": "The following code contains a buggy line with the following test error: ArrayIndexOutOfBoundsException: 2 testCodec105 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   Base64InputStream in = new Base64InputStream(new Codec105ErrorInputStream(), true, 0, null);  for (int i = 0; i < 5; i++) {   in.read();  } }", "input": "[BUG] [BUGGY] if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } [FE] ArrayIndexOutOfBoundsException: 2 testCodec105 [CONTEXT] readResults() call must return 0 if a large amount of the data being decoded was non-base64, so this while-loop enables proper interop with InputStreamReader for that scenario. ----- This is a fix for CODEC-101 while (readLen == 0) { if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); [BUGGY] if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } [BUGGY] if (doEncode) { base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); } } readLen = base64.readResults(b, offset, len); } [CLASS] Base64InputStream [METHOD] read [RETURN_TYPE] int byte[] b int offset int len [VARIABLES] byte[] b buf lineSeparator singleByte boolean doEncode Base64 base64 int c len offset readLen ", "output": "[PATCH] [Delete] ", "bugid": "477"}, {"instruction": "The following code contains a buggy line. The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and to provide the fix code.None", "input": "[BUG] [BUGGY] [CONTEXT] } ParameterizedType parameterizedType = (ParameterizedType) classType; TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters(); Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); for (int i = 0; i < actualTypeArguments.length; i++) { TypeVariable typeParameter = typeParameters[i]; Type actualTypeArgument = actualTypeArguments[i]; if (actualTypeArgument instanceof WildcardType) { contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument)); } else { [BUGGY] [BUGGY]contextualActualTypeParameters.put(typeParameter, actualTypeArgument); } } } [CLASS] GenericMetadataSupport FromClassGenericMetadataSupport FromParameterizedTypeGenericMetadataSupport ParameterizedReturnType TypeVariableReturnType NotGenericReturnTypeSupport TypeVarBoundedType WildCardBoundedType [METHOD] registerTypeVariablesOn [RETURN_TYPE] void Type classType [VARIABLES] ParameterizedType parameterizedType WildcardType wildcard Type actualTypeArgument classType boolean TypeVariable typeParameter typeVariable Type[] actualTypeArguments Class clazz currentExploredClass rawType returnType TypeVariable[] typeParameters Map contextualActualTypeParameters int i ", "output": "[PATCH] if (typeParameter != actualTypeArgument) { ", "bugid": "478"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError shouldInjectUsingPropertySetterIfAvailable . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  }", "input": "[BUG] [BUGGY] new FieldSetter(fieldInstance, field).set(matchingMock); [FE] AssertionFailedError shouldInjectUsingPropertySetterIfAvailable [CONTEXT] public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) { if(mocks.size() == 1) { final Object matchingMock = mocks.iterator().next(); return new OngoingInjecter() { public boolean thenInject() { try { [BUGGY] [BUGGY] new FieldSetter(fieldInstance, field).set(matchingMock); } catch (Exception e) { throw new MockitoException(\"Problems injecting dependency in\" + field.getName(), e); } return true; } }; } return new OngoingInjecter() { public boolean thenInject() { [CLASS] FinalMockCandidateFilter 1 2 [METHOD] filterCandidate [RETURN_TYPE] OngoingInjecter Object> mocks Field field Object fieldInstance [VARIABLES] Field field boolean Collection mocks Object fieldInstance matchingMock Exception e ", "output": "[PATCH] if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) { new FieldSetter(fieldInstance, field).set(matchingMock); } ", "bugid": "479"}, {"instruction": "The following code contains a buggy line with the following test error: null  should_return_empty_iterable . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  }", "input": "[BUG] [BUGGY] [FE] null  should_return_empty_iterable [CONTEXT] Object returnValueFor(Class<?> type) { if (Primitives.isPrimitiveOrWrapper(type)) { return Primitives.defaultValueForPrimitiveOrWrapper(type); } [BUGGY] [BUGGY] else if (type == Collection.class) { return new LinkedList<Object>(); } else if (type == Set.class) { return new HashSet<Object>(); } else if (type == HashSet.class) { return new HashSet<Object>(); } else if (type == SortedSet.class) { return new TreeSet<Object>(); } else if (type == TreeSet.class) { return new TreeSet<Object>(); } else if (type == LinkedHashSet.class) { [CLASS] ReturnsEmptyValues [METHOD] returnValueFor [RETURN_TYPE] Object Class<?> type [VARIABLES] ObjectMethodsGuru methodsGuru Class type boolean MockUtil mockUtil long serialVersionUID ", "output": "[PATCH] if (type == Iterable.class) { return new ArrayList<Object>(0); } ", "bugid": "480"}, {"instruction": "The following code contains a buggy line with the following test error: RuntimeException shouldKnowIfObjectsAreEqual . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertTrue(areEqual(new Object[] {\"1\"}, new String[] {\"1\"}));\tObject badequals=new BadEquals();\tassertTrue(areEqual(badequals,badequals));  assertFalse(areEqual(new Object[9], new Object[10]));", "input": "[BUG] [BUGGY] [FE] RuntimeException shouldKnowIfObjectsAreEqual [CONTEXT] public static boolean areEqual(Object o1, Object o2) { [BUGGY] [BUGGY] if (o1 == null || o2 == null) { return o1 == null && o2 == null; } else if (isArray(o1)) { return isArray(o2) && areArraysEqual(o1, o2); } else { return o1.equals(o2); } } [CLASS] Equality [METHOD] areEqual [RETURN_TYPE] boolean Object o1 Object o2 [VARIABLES] boolean Object o1 o2 ", "output": "[PATCH] if (o1 == o2 ) { return true; } ", "bugid": "481"}, {"instruction": "The following code contains a buggy line with the following test error: IllegalArgumentException: Illegal group reference: group index is missing testYahooArticle . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void testYahooArticle() throws IOException {  File in = getFile(\"/htmltests/yahoo-article-1.html\");  Document doc = Jsoup.parse(in, \"UTF-8\", \"http://news.yahoo.com/s/nm/20100831/bs_nm/us_gm_china\");  Element p = doc.select(\"p:contains(Volt will be sold in the United States\").first();  assertEquals(\"In July, GM said its electric Chevrolet Volt will be sold in the United States at $41,000 -- $8,000 more than its nearest competitor, the Nissan Leaf.\", p.text());", "input": "[BUG] [BUGGY] m.appendReplacement(accum, m.group(0)); [FE] IllegalArgumentException: Illegal group reference: group index is missing testYahooArticle [CONTEXT] } catch (NumberFormatException e) { } } else { String name = m.group(1); if (full.containsKey(name)) charval = full.get(name); } if (charval != -1 || charval > 0xFFFF) { String c = Character.toString((char) charval); m.appendReplacement(accum, c); } else { [BUGGY] m.appendReplacement(accum, m.group(0)); [BUGGY] } } m.appendTail(accum); return accum.toString(); } [CLASS] Entities EscapeMode [METHOD] unescape [RETURN_TYPE] String String string [VARIABLES] Pattern unescapePattern StringBuffer accum boolean Matcher m EscapeMode base escapeMode extended Object[][] baseArray fullArray NumberFormatException e String c name num string Map baseByVal full fullByVal map int base charval ", "output": "[PATCH] m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); ", "bugid": "482"}, {"instruction": "The following code contains a buggy line with the following test error: IndexOutOfBoundsException: Index: 0, Size: 0 handlesDodgyXmlDecl . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void handlesDodgyXmlDecl() {  String xml = \"<?xml version='1.0'><val>One</val>\";  Document doc = Jsoup.parse(xml, \"\", Parser.xmlParser());  assertEquals(\"One\", doc.select(\"val\").text()); }", "input": "[BUG] [BUGGY] [FE] IndexOutOfBoundsException: Index: 0, Size: 0 handlesDodgyXmlDecl [CONTEXT] void insert(Token.Comment commentToken) { Comment comment = new Comment(commentToken.getData()); Node insert = comment; if (commentToken.bogus) { String data = comment.getData(); if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) { Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) +\">\", baseUri, Parser.xmlParser()); [BUGGY] [BUGGY] Element el = doc.child(0); insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith(\"!\")); insert.attributes().addAll(el.attributes()); } } insertNode(insert); } [CLASS] XmlTreeBuilder [METHOD] insert [RETURN_TYPE] void Comment commentToken [VARIABLES] Comment comment commentToken boolean Node insert Element el String data Document doc ", "output": "[PATCH] if (doc.childNodeSize() > 0) { ", "bugid": "483"}, {"instruction": "The following code contains a buggy line with the following test error: null  testNullObjectId . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   // Ok, so missing Object Id is ok, but so is null.    Identifiable value = MAPPER.readValue    (aposToQuotes(\"{'value':3, 'next':null, 'id':null}\"), Identifiable.class);  assertNotNull(value);", "input": "[BUG] [BUGGY] [FE] null  testNullObjectId [CONTEXT] {  [BUGGY] [BUGGY] final ObjectIdGenerator.IdKey key = gen.key(id); if (_objectIds == null) { _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey,ReadableObjectId>(); } else { ReadableObjectId entry = _objectIds.get(key); if (entry != null) { return entry; } } [CLASS] DefaultDeserializationContext Impl [METHOD] findObjectId [RETURN_TYPE] ReadableObjectId Object id ObjectIdGenerator<?> gen ObjectIdResolver resolverType [VARIABLES] ObjectIdGenerator gen ReadableObjectId entry boolean IdKey key List _objectIdResolvers Object id ObjectIdResolver res resolver resolverType long serialVersionUID LinkedHashMap _objectIds ", "output": "[PATCH] if (id == null) { return null; } ", "bugid": "484"}, {"instruction": "The following code contains a buggy line with the following test error: null  testNullObjectId . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   // Ok, so missing Object Id is ok, but so is null.    Identifiable value = MAPPER.readValue    (aposToQuotes(\"{'value':3, 'next':null, 'id':null}\"), Identifiable.class);  assertNotNull(value);", "input": "[BUG] [BUGGY] [FE] null  testNullObjectId [CONTEXT] DeserializationContext ctxt, Object instance) throws IOException { Object id = _valueDeserializer.deserialize(jp, ctxt);  [BUGGY] [BUGGY] ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver); roid.bindItem(instance); SettableBeanProperty idProp = _objectIdReader.idProperty; if (idProp != null) { return idProp.setAndReturn(instance, id); } return instance; } [CLASS] ObjectIdValueProperty [METHOD] deserializeSetAndReturn [RETURN_TYPE] Object JsonParser jp DeserializationContext ctxt Object instance [VARIABLES] ReadableObjectId roid boolean SettableBeanProperty idProp ObjectIdReader _objectIdReader objectIdReader DeserializationContext ctxt Object id instance long serialVersionUID JsonParser jp ", "output": "[PATCH] if (id == null) { return null; } ", "bugid": "485"}, {"instruction": "The following code contains a buggy line with the following test error: JsonMappingException testcharSequenceKeyMap . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:  public void testcharSequenceKeyMap() throws Exception {  String JSON = aposToQuotes(\"{'a':'b'}\");  Map<CharSequence,String> result = MAPPER.readValue(JSON, new TypeReference<Map<CharSequence,String>>() { });  assertNotNull(result);  assertEquals(1, result.size());", "input": "[BUG] [BUGGY] if (raw == String.class || raw == Object.class) { [FE] JsonMappingException testcharSequenceKeyMap [CONTEXT] if (raw == String.class || raw == Object.class) { return StringKD.forType(raw); } else if (raw == UUID.class) { ", "output": "[PATCH] if (raw == String.class || raw == Object.class || raw == CharSequence.class) { ", "bugid": "486"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Expected an exception with one of substrings ([smaller than original]): got one with message\"Trying to release buffer not owned by the context\" testAllocations . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    ctxt.allocReadIOBuffer();  } catch (IllegalStateException e) {   verifyException(e, \"second time\");  }  // Also: can't succeed with different buffer", "input": "[BUG] [BUGGY] if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); } [FE] AssertionFailedError: Expected an exception with one of substrings ([smaller than original]): got one with message\"Trying to release buffer not owned by the context\" testAllocations [CONTEXT] protected final void _verifyRelease(byte[] toRelease, byte[] src) { [BUGGY] if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); } [BUGGY] } [CLASS] IOContext [METHOD] _verifyRelease [RETURN_TYPE] void byte[] toRelease byte[] src [VARIABLES] byte[] _base64Buffer _readIOBuffer _writeEncodingBuffer buf src toRelease boolean _managedResource managedResource JsonEncoding _encoding enc BufferRecycler _bufferRecycler br Object _sourceRef buffer sourceRef char[] _concatCBuffer _nameCopyBuffer _tokenCBuffer buf ", "output": "[PATCH] if ((toRelease != src) && (toRelease.length < src.length)) { throw wrongBuf(); } ", "bugid": "487"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: Expected an exception with one of substrings ([smaller than original]): got one with message\"Trying to release buffer not owned by the context\" testAllocations . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:    ctxt.allocReadIOBuffer();  } catch (IllegalStateException e) {   verifyException(e, \"second time\");  }  // Also: can't succeed with different buffer", "input": "[BUG] [BUGGY] if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); } [FE] AssertionFailedError: Expected an exception with one of substrings ([smaller than original]): got one with message\"Trying to release buffer not owned by the context\" testAllocations [CONTEXT] protected final void _verifyRelease(char[] toRelease, char[] src) { [BUGGY] if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); } [BUGGY] } [CLASS] IOContext [METHOD] _verifyRelease [RETURN_TYPE] void char[] toRelease char[] src [VARIABLES] byte[] _base64Buffer _readIOBuffer _writeEncodingBuffer buf src toRelease boolean _managedResource managedResource JsonEncoding _encoding enc BufferRecycler _bufferRecycler br Object _sourceRef buffer sourceRef char[] _concatCBuffer _nameCopyBuffer _tokenCBuffer buf src toRelease ", "output": "[PATCH] if ((toRelease != src) && (toRelease.length < src.length)) { throw wrongBuf(); } ", "bugid": "488"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<1> but was:<3> testGetMaxMiddleIndex . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertEquals(1, s.getMaxMiddleIndex());  s.add(new SimpleTimePeriod(150L, 200L), 4.0);  assertEquals(1, s.getMaxMiddleIndex()); }", "input": "[BUG] [BUGGY] long s = getDataItem(this.minMiddleIndex).getPeriod().getStart().getTime(); [FE] AssertionFailedError: expected:<1> but was:<3> testGetMaxMiddleIndex [CONTEXT] long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { [BUGGY] long s = getDataItem(this.minMiddleIndex).getPeriod().getStart().getTime(); [BUGGY] long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd().getTime(); long maxMiddle = s + (e - s) / 2;  [CLASS] TimePeriodValues [METHOD] updateBounds [RETURN_TYPE] void TimePeriod period int index [VARIABLES] serialVersionUID start int index maxEndIndex maxMiddleIndex maxStartIndex minEndIndex minMiddleIndex minStartIndex TimePeriod period ", "output": "[PATCH] long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart().getTime(); ", "bugid": "489"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: expected:<1> but was:<3> testGetMaxMiddleIndex . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   assertEquals(1, s.getMaxMiddleIndex());  s.add(new SimpleTimePeriod(150L, 200L), 4.0);  assertEquals(1, s.getMaxMiddleIndex()); }", "input": "[BUG] [BUGGY] long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd().getTime(); [FE] AssertionFailedError: expected:<1> but was:<3> testGetMaxMiddleIndex [CONTEXT]  if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart().getTime(); [BUGGY] long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd().getTime(); [BUGGY] long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; [CLASS] TimePeriodValues [METHOD] updateBounds [RETURN_TYPE] void TimePeriod period int index [VARIABLES] serialVersionUID start int index maxEndIndex maxMiddleIndex maxStartIndex minEndIndex minMiddleIndex minStartIndex TimePeriod period ", "output": "[PATCH] long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd() .getTime(); ", "bugid": "490"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<{[]}> but was:<{[\"a\":null]}> testEmpty1256 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   String json = mapper.writeValueAsString(new Issue1256Bean());  assertEquals(\"{}\", json); }", "input": "[BUG] [BUGGY] if (declaredType.isReferenceType()) { [FE] ComparisonFailure: expected:<{[]}> but was:<{[\"a\":null]}> testEmpty1256 [CONTEXT] if (valueToSuppress.getClass().isArray()) { valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress); } } break; case NON_ABSENT:  suppressNulls = true;  [BUGGY] if (declaredType.isReferenceType()) { [BUGGY] valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; } break; case NON_EMPTY:  suppressNulls = true;  valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; break; case NON_NULL: [CLASS]  PropertyBuilder [METHOD] buildWriter [RETURN_TYPE] BeanPropertyWriter  SerializerProvider prov BeanPropertyDefinition propDef JavaType declaredType JsonSerializer<?> ser TypeSerializer typeSer TypeSerializer contentTypeSer AnnotatedMember am boolean defaultUseStaticTyping [VARIABLES] SerializationConfig _config config BeanDescription _beanDesc beanDesc AnnotationIntrospector _annotationIntrospector AnnotatedMember am Include inclusion JsonSerializer ser NameTransformer unwrapper JavaType actualType  declaredType serializationType boolean defaultUseStaticTyping suppressNulls Value _defaultInclusion inclV BeanPropertyDefinition propDef TypeSerializer contentTypeSer typeSer Object NO_DEFAULT_MARKER _defaultBean serDef valueToSuppress SerializerProvider prov BeanPropertyWriter bpw  ", "output": "[PATCH] if (actualType.isReferenceType()) { ", "bugid": "491"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: expected:<{[]}> but was:<{[\"a\":null]}> testEmpty1256 . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   String json = mapper.writeValueAsString(new Issue1256Bean());  assertEquals(\"{}\", json); }", "input": "[BUG] [BUGGY] if (declaredType.isContainerType() [FE] ComparisonFailure: expected:<{[]}> but was:<{[\"a\":null]}> testEmpty1256 [CONTEXT] suppressNulls = true;  valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; break; case NON_NULL: suppressNulls = true;  case ALWAYS: default:  [BUGGY] if (declaredType.isContainerType() [BUGGY] && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) { valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; } break; } BeanPropertyWriter bpw = new BeanPropertyWriter(propDef, am, _beanDesc.getClassAnnotations(), declaredType, ser, typeSer, serializationType, suppressNulls, valueToSuppress); [CLASS]  PropertyBuilder [METHOD] buildWriter [RETURN_TYPE] BeanPropertyWriter  SerializerProvider prov BeanPropertyDefinition propDef JavaType declaredType JsonSerializer<?> ser TypeSerializer typeSer TypeSerializer contentTypeSer AnnotatedMember am boolean defaultUseStaticTyping [VARIABLES] SerializationConfig _config config BeanDescription _beanDesc beanDesc AnnotationIntrospector _annotationIntrospector AnnotatedMember am Include inclusion JsonSerializer ser NameTransformer unwrapper JavaType actualType  declaredType serializationType boolean defaultUseStaticTyping suppressNulls Value _defaultInclusion inclV BeanPropertyDefinition propDef TypeSerializer contentTypeSer typeSer Object NO_DEFAULT_MARKER _defaultBean serDef valueToSuppress SerializerProvider prov BeanPropertyWriter bpw  ", "output": "[PATCH] if (actualType.isContainerType() ", "bugid": "492"}, {"instruction": "The following code contains a buggy line with the following test error: NumberFormatException:  shouldReadBigGid . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   TarArchiveInputStream tis =   new TarArchiveInputStream(bis);  t = tis.getNextTarEntry();  assertEquals(4294967294l, t.getLongGroupId());  tis.close();", "input": "[BUG] [BUGGY] currEntry.setGroupId(Integer.parseInt(val)); [FE] NumberFormatException:  shouldReadBigGid [CONTEXT] for (Entry<String, String> ent : headers.entrySet()){ String key = ent.getKey(); String val = ent.getValue(); if (\"path\".equals(key)){ currEntry.setName(val); } else if (\"linkpath\".equals(key)){ currEntry.setLinkName(val); } else if (\"gid\".equals(key)){ [BUGGY] currEntry.setGroupId(Integer.parseInt(val)); [BUGGY] } else if (\"gname\".equals(key)){ currEntry.setGroupName(val); } else if (\"uid\".equals(key)){ currEntry.setUserId(Integer.parseInt(val)); } else if (\"uname\".equals(key)){ currEntry.setUserName(val); } else if (\"size\".equals(key)){ currEntry.setSize(Long.parseLong(val)); } else if (\"mtime\".equals(key)){ currEntry.setModTime((long) (Double.parseDouble(val) * 1000)); [CLASS]  TarArchiveInputStream [METHOD] applyPaxHeadersToCurrentEntry [RETURN_TYPE] void  String> headers [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest Entry ent boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  ", "output": "[PATCH] currEntry.setGroupId(Long.parseLong(val)); ", "bugid": "493"}, {"instruction": "The following code contains a buggy line with the following test error: NumberFormatException:  shouldReadBigGid . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   TarArchiveInputStream tis =   new TarArchiveInputStream(bis);  t = tis.getNextTarEntry();  assertEquals(4294967294l, t.getLongGroupId());  tis.close();", "input": "[BUG] [BUGGY] currEntry.setUserId(Integer.parseInt(val)); [FE] NumberFormatException:  shouldReadBigGid [CONTEXT] String val = ent.getValue(); if (\"path\".equals(key)){ currEntry.setName(val); } else if (\"linkpath\".equals(key)){ currEntry.setLinkName(val); } else if (\"gid\".equals(key)){ currEntry.setGroupId(Integer.parseInt(val)); } else if (\"gname\".equals(key)){ currEntry.setGroupName(val); } else if (\"uid\".equals(key)){ [BUGGY] currEntry.setUserId(Integer.parseInt(val)); [BUGGY] } else if (\"uname\".equals(key)){ currEntry.setUserName(val); } else if (\"size\".equals(key)){ currEntry.setSize(Long.parseLong(val)); } else if (\"mtime\".equals(key)){ currEntry.setModTime((long) (Double.parseDouble(val) * 1000)); } else if (\"SCHILY.devminor\".equals(key)){ currEntry.setDevMinor(Integer.parseInt(val)); } else if (\"SCHILY.devmajor\".equals(key)){ currEntry.setDevMajor(Integer.parseInt(val)); [CLASS]  TarArchiveInputStream [METHOD] applyPaxHeadersToCurrentEntry [RETURN_TYPE] void  String> headers [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest Entry ent boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  ", "output": "[PATCH] currEntry.setUserId(Long.parseLong(val)); ", "bugid": "494"}, {"instruction": "The following code contains a buggy line with the following test error: null  testPerformClusterAnalysisDegenerate . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:     new EuclideanIntegerPoint(new int[] { 1959, 325100 }),    new EuclideanIntegerPoint(new int[] { 1960, 373200 }), };  List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points), 1, 1);  assertEquals(1, clusters.size());  assertEquals(2, (clusters.get(0).getPoints().size()));", "input": "[BUG] [BUGGY] int sum = 0;  [FE] null  testPerformClusterAnalysisDegenerate [CONTEXT] public static double distance(int[] p1, int[] p2) { [BUGGY] int sum = 0; [BUGGY] for (int i = 0; i < p1.length; i++) { final int dp = p1[i] - p2[i]; sum += dp * dp; } return Math.sqrt(sum); } [CLASS] MathUtils [METHOD] distance [RETURN_TYPE] double int[] p1 int[] p2 [VARIABLES] boolean long[] FACTORIALS double EPSILON SAFE_MIN TWO_PI a base center d direction dp eps fraction logSum normalizedSum result sign sum unscaled value x y byte NB PB ZB x short NS PS ZS x int[] p1 p2 int NAN_GAP a b dp e i j k k2p lcm len maxUlps n p q result roundingMethod scale scaleFactor sum t u v x y long SGN_MASK a b bits d e exponent k k2p m mantissa newBits rest result ret s sign x xInt yInt ", "output": "[PATCH] double sum = 0; ", "bugid": "495"}, {"instruction": "The following code contains a buggy line with the following test error: null  testPerformClusterAnalysisDegenerate . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:     new EuclideanIntegerPoint(new int[] { 1959, 325100 }),    new EuclideanIntegerPoint(new int[] { 1960, 373200 }), };  List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points), 1, 1);  assertEquals(1, clusters.size());  assertEquals(2, (clusters.get(0).getPoints().size()));", "input": "[BUG] [BUGGY] final int dp = p1[i] - p2[i]; [FE] null  testPerformClusterAnalysisDegenerate [CONTEXT] public static double distance(int[] p1, int[] p2) { int sum = 0; for (int i = 0; i < p1.length; i++) { [BUGGY] final int dp = p1[i] - p2[i]; [BUGGY] sum += dp * dp; } return Math.sqrt(sum); } [CLASS] MathUtils [METHOD] distance [RETURN_TYPE] double int[] p1 int[] p2 [VARIABLES] boolean long[] FACTORIALS double EPSILON SAFE_MIN TWO_PI a base center d direction dp eps fraction logSum normalizedSum result sign sum unscaled value x y byte NB PB ZB x short NS PS ZS x int[] p1 p2 int NAN_GAP a b dp e i j k k2p lcm len maxUlps n p q result roundingMethod scale scaleFactor sum t u v x y long SGN_MASK a b bits d e exponent k k2p m mantissa newBits rest result ret s sign x xInt yInt ", "output": "[PATCH] final double dp = p1[i] - p2[i]; ", "bugid": "496"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: compare values  expected:<60> but was:<1280> testBasicFunctions . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   ArrayRealVector v2 = new ArrayRealVector(vec2);  ArrayRealVector v5 = new ArrayRealVector(vec5);  ArrayRealVector v_null = new ArrayRealVector(vec_null);  RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2);", "input": "[BUG] [BUGGY] max += Math.max(max, Math.abs(a)); [FE] AssertionFailedError: compare values  expected:<60> but was:<1280> testBasicFunctions [CONTEXT] public double getLInfNorm() { double max = 0; for (double a : data) { [BUGGY] max += Math.max(max, Math.abs(a)); [BUGGY] } return max; } [CLASS]  ArrayRealVector [METHOD] getLInfNorm [RETURN_TYPE] double  [VARIABLES] RealVectorFormat DEFAULT_FORMAT String NON_FITTING_POSITION_AND_SIZE_MESSAGE boolean double[] d data out v v1 v2 long serialVersionUID double a max  ", "output": "[PATCH] max = Math.max(max, Math.abs(a)); ", "bugid": "497"}, {"instruction": "The following code contains a buggy line with the following test error: AssertionFailedError: compare values  expected:<60> but was:<1280> testBasicFunctions . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here:   ArrayRealVector v2 = new ArrayRealVector(vec2);  ArrayRealVector v5 = new ArrayRealVector(vec5);  ArrayRealVector v_null = new ArrayRealVector(vec_null);  RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2);", "input": "[BUG] [BUGGY] public double getLInfNorm() { double max = 0; Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); max += iter.value(); } return max; } [FE] AssertionFailedError: compare values  expected:<60> but was:<1280> testBasicFunctions [CONTEXT] [BUGGY] public double getLInfNorm() { double max = 0; Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); max += iter.value(); } return max; } [CLASS]  OpenMapRealVector OpenMapEntry OpenMapSparseIterator [METHOD] getLInfNorm [RETURN_TYPE] double  [VARIABLES] Entry current boolean double DEFAULT_ZERO_TOLERANCE d delta epsilon max res value Iterator iter OpenIntToDoubleHashMap entries larger randomAccess long serialVersionUID int dimension end expectedSize i index key n resize virtualSize  ", "output": "[PATCH] [Delete] ", "bugid": "498"}, {"instruction": "The following code contains a buggy line with the following test error:  AssertionFailedError:  expected:<2>  but  was:<1>  testTypeRedefinition  . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG]  [BUGGY]  if  ((leftType.isConstructor()  ||  leftType.isEnumType())  &&  (rightType.isConstructor()  ||  rightType.isEnumType()))  {  registerMismatch(rightType,  leftType,  null);  }  else  {  [FE]  AssertionFailedError:  expected:<2>  but  was:<1>  testTypeRedefinition  [CONTEXT]  JSType  leftType,  Node  owner,  String  propName)  {    if  (!leftType.isNoType()  &&  !rightType.canAssignTo(leftType))  {  [BUGGY]  if  ((leftType.isConstructor()  ||  leftType.isEnumType())  &&  (rightType.isConstructor()  ||  rightType.isEnumType()))  {  registerMismatch(rightType,  leftType,  null);  }  else  {  [BUGGY]        JSType  ownerType  =  getJSType(owner);  if  (ownerType.isFunctionPrototypeType())  {  FunctionType  ownerFn  =  ownerType.toObjectType().getOwnerFunction();  if  (ownerFn.isInterface()  &&  rightType.isFunctionType()  &&  leftType.isFunctionType())  {  [CLASS]    TypeValidator  TypeMismatch  [METHOD]  expectCanAssignToPropertyOf  [RETURN_TYPE]  boolean    NodeTraversal  t  Node  n  JSType  rightType  JSType  leftType  Node  owner  String  propName  [VARIABLES]  AbstractCompiler  compiler  JSTypeRegistry  typeRegistry  JSType  a  allValueTypes  alt  anyObjectType  b  caseType  expectedType  indexType  leftType  nullOrUndefined  objType  ownerType  rightType  switchType  type  typeA  typeB  boolean  report  shouldReport  NodeTraversal  t  DiagnosticType  DUP_VAR_DECLARATION  HIDDEN_INTERFACE_PROPERTY_MISMATCH  HIDDEN_PROPERTY_MISMATCH  ILLEGAL_PROPERTY_ACCESS  INTERFACE_METHOD_NOT_IMPLEMENTED  INVALID_CAST  MISSING_EXTENDS_TAG_WARNING  TYPE_MISMATCH_WARNING  UNKNOWN_TYPEOF_VALUE  DiagnosticGroup  ALL_DIAGNOSTICS  Node  n  owner  FunctionType  ownerFn  List  mismatches  String  FOUND_REQUIRED  found  msg  propName  JSError  src    ", "output": "[PATCH]  [Delete]", "bugid": "499"}, {"instruction": "The following code contains a buggy line with the following test error:  AssertionFailedError:  expected:<2>  but  was:<1>  testTypeRedefinition  . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: ", "input": "[BUG]  [BUGGY]  if  ((leftType.isConstructor()  ||  leftType.isEnumType())  &&  (rightType.isConstructor()  ||  rightType.isEnumType()))  {  registerMismatch(rightType,  leftType,  null);  }  else  {  [FE]  AssertionFailedError:  expected:<2>  but  was:<1>  testTypeRedefinition  [CONTEXT]  JSType  leftType,  Node  owner,  String  propName)  {    if  (!leftType.isNoType()  &&  !rightType.canAssignTo(leftType))  {  [BUGGY]  if  ((leftType.isConstructor()  ||  leftType.isEnumType())  &&  (rightType.isConstructor()  ||  rightType.isEnumType()))  {  registerMismatch(rightType,  leftType,  null);  }  else  {  [BUGGY]        JSType  ownerType  =  getJSType(owner);  if  (ownerType.isFunctionPrototypeType())  {  FunctionType  ownerFn  =  ownerType.toObjectType().getOwnerFunction();  if  (ownerFn.isInterface()  &&  rightType.isFunctionType()  &&  leftType.isFunctionType())  {  [CLASS]    TypeValidator  TypeMismatch  [METHOD]  expectCanAssignToPropertyOf  [RETURN_TYPE]  boolean    NodeTraversal  t  Node  n  JSType  rightType  JSType  leftType  Node  owner  String  propName  [VARIABLES]  AbstractCompiler  compiler  JSTypeRegistry  typeRegistry  JSType  a  allValueTypes  alt  anyObjectType  b  caseType  expectedType  indexType  leftType  nullOrUndefined  objType  ownerType  rightType  switchType  type  typeA  typeB  boolean  report  shouldReport  NodeTraversal  t  DiagnosticType  DUP_VAR_DECLARATION  HIDDEN_INTERFACE_PROPERTY_MISMATCH  HIDDEN_PROPERTY_MISMATCH  ILLEGAL_PROPERTY_ACCESS  INTERFACE_METHOD_NOT_IMPLEMENTED  INVALID_CAST  MISSING_EXTENDS_TAG_WARNING  TYPE_MISMATCH_WARNING  UNKNOWN_TYPEOF_VALUE  DiagnosticGroup  ALL_DIAGNOSTICS  Node  n  owner  FunctionType  ownerFn  List  mismatches  String  FOUND_REQUIRED  found  msg  propName  JSError  src    ", "output": "[PATCH]  [Delete]", "bugid": "500"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: selected option expected:<bar> but was:<null> testOptionGroupLong . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: None", "input": "[BUG] [BUGGY] if (selected == null || selected.equals(option.getOpt())) { [FE] ComparisonFailure: selected option expected:<bar> but was:<null> testOptionGroupLong [CONTEXT] if (option == null) { selected = null; return; } [BUGGY] if (selected == null || selected.equals(option.getOpt())) { [BUGGY]  selected = option.getOpt(); } else { throw new AlreadySelectedException(this, option); } } [CLASS] OptionGroup [METHOD] setSelected [RETURN_TYPE] void Option option [VARIABLES] Option option boolean required String selected Map optionMap long serialVersionUID ", "output": "[PATCH] if (selected == null || selected.equals(option.getKey())) { ", "bugid": "501"}, {"instruction": "The following code contains a buggy line with the following test error: ComparisonFailure: selected option expected:<bar> but was:<null> testOptionGroupLong . The original buggy line is given after the special token: [BUGGY]. Please refer to buggy line, its context, error message and tests code to provide the fix code. The tests code which trigger this bug is given here: None", "input": "[BUG] [BUGGY]  selected = option.getOpt(); [FE] ComparisonFailure: selected option expected:<bar> but was:<null> testOptionGroupLong [CONTEXT] if (option == null) { selected = null; return; }  if (selected == null || selected.equals(option.getOpt())) { [BUGGY] selected = option.getOpt(); [BUGGY] } else { throw new AlreadySelectedException(this, option); } } [CLASS] OptionGroup [METHOD] setSelected [RETURN_TYPE] void Option option [VARIABLES] Option option boolean required String selected Map optionMap long serialVersionUID ", "output": "[PATCH]  selected = option.getKey(); ", "bugid": "502"}]